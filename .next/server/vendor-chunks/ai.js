"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData2),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.jsonSchema),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.parseStreamPart),\n/* harmony export */   processDataProtocolResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace/status.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name11 in all)\n    __defProp(target, name11, { get: all[name11], enumerable: true });\n};\n\n// streams/index.ts\n\n\n\n// core/index.ts\n\n\n// util/retry-with-exponential-backoff.ts\n\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name, message });\n    this[_a] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isRetryError(error) {\n    return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      reason: this.reason,\n      lastError: this.lastError,\n      errors: this.errors\n    };\n  }\n};\n_a = symbol;\n\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a11;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a11 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a11 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// core/telemetry/get-tracer.ts\n\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name11, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// core/telemetry/get-tracer.ts\nvar testTracer = void 0;\nfunction getTracer({ isEnabled }) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (testTracer) {\n    return testTracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.trace.getTracer(\"ai\");\n}\n\n// core/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name11,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name11, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          });\n          span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR,\n            message: error.message\n          });\n        } else {\n          span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR });\n        }\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\n\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value === void 0) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  var _a11;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a11 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a11 : false });\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const { embedding, usage, rawResponse } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a12;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a12 = modelResponse.usage) != null ? _a12 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                rawResponse: modelResponse.rawResponse\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n};\n\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// core/embed/embed-many.ts\nasync function embedMany({\n  model,\n  values,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  var _a11;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a11 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a11 : false });\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings: embeddings2, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a12;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a12 = modelResponse.usage) != null ? _a12 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings3, usage: usage2 };\n            }\n          });\n        });\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({ values, embeddings: embeddings2, usage });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      let tokens = 0;\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => chunk.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a12;\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers\n              });\n              const embeddings2 = modelResponse.embeddings;\n              const usage2 = (_a12 = modelResponse.usage) != null ? _a12 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings2, usage: usage2 };\n            }\n          });\n        });\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens }\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n// core/prompt/convert-to-language-model-prompt.ts\n\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name2, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isDownloadError(error) {\n    return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      statusCode: this.statusCode,\n      statusText: this.statusText,\n      cause: this.cause\n    };\n  }\n};\n_a2 = symbol2;\n\n// util/download.ts\nasync function download({\n  url,\n  fetchImplementation = fetch\n}) {\n  var _a11;\n  const urlText = url.toString();\n  try {\n    const response = await fetchImplementation(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: (_a11 = response.headers.get(\"content-type\")) != null ? _a11 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name3, message, cause });\n    this[_a3] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidDataContentError(error) {\n    return error instanceof Error && error.name === name3 && error.content != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      content: this.content\n    };\n  }\n};\n_a3 = symbol3;\n\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(Uint8Array),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(ArrayBuffer),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a11, _b;\n      return (_b = (_a11 = globalThis.Buffer) == null ? void 0 : _a11.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error(\"Error decoding Uint8Array to text\");\n  }\n}\n\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name4, message });\n    this[_a4] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidMessageRoleError(error) {\n    return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      role: this.role\n    };\n  }\n};\n_a4 = symbol4;\n\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  downloadImplementation = download\n}) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  const downloadedImages = modelSupportsImageUrls || prompt.messages == null ? null : await downloadImages(prompt.messages, downloadImplementation);\n  const promptType = prompt.type;\n  switch (promptType) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map(\n          (message) => convertToLanguageModelMessage(message, downloadedImages)\n        )\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = promptType;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message, downloadedImages) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => {\n          var _a11, _b, _c;\n          switch (part.type) {\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerMetadata: part.experimental_providerMetadata\n              };\n            }\n            case \"image\": {\n              if (part.image instanceof URL) {\n                if (downloadedImages == null) {\n                  return {\n                    type: \"image\",\n                    image: part.image,\n                    mimeType: part.mimeType,\n                    providerMetadata: part.experimental_providerMetadata\n                  };\n                } else {\n                  const downloadedImage = downloadedImages[part.image.toString()];\n                  return {\n                    type: \"image\",\n                    image: downloadedImage.data,\n                    mimeType: (_a11 = part.mimeType) != null ? _a11 : downloadedImage.mimeType,\n                    providerMetadata: part.experimental_providerMetadata\n                  };\n                }\n              }\n              if (typeof part.image === \"string\") {\n                try {\n                  const url = new URL(part.image);\n                  switch (url.protocol) {\n                    case \"http:\":\n                    case \"https:\": {\n                      if (downloadedImages == null) {\n                        return {\n                          type: \"image\",\n                          image: url,\n                          mimeType: part.mimeType,\n                          providerMetadata: part.experimental_providerMetadata\n                        };\n                      } else {\n                        const downloadedImage = downloadedImages[part.image];\n                        return {\n                          type: \"image\",\n                          image: downloadedImage.data,\n                          mimeType: (_b = part.mimeType) != null ? _b : downloadedImage.mimeType,\n                          providerMetadata: part.experimental_providerMetadata\n                        };\n                      }\n                    }\n                    case \"data:\": {\n                      try {\n                        const [header, base64Content] = part.image.split(\",\");\n                        const mimeType = header.split(\";\")[0].split(\":\")[1];\n                        if (mimeType == null || base64Content == null) {\n                          throw new Error(\"Invalid data URL format\");\n                        }\n                        return {\n                          type: \"image\",\n                          image: convertDataContentToUint8Array(base64Content),\n                          mimeType,\n                          providerMetadata: part.experimental_providerMetadata\n                        };\n                      } catch (error) {\n                        throw new Error(\n                          `Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(\n                            message\n                          )}`\n                        );\n                      }\n                    }\n                    default: {\n                      throw new Error(\n                        `Unsupported URL protocol: ${url.protocol}`\n                      );\n                    }\n                  }\n                } catch (_ignored) {\n                }\n              }\n              const imageUint8 = convertDataContentToUint8Array(part.image);\n              return {\n                type: \"image\",\n                image: imageUint8,\n                mimeType: (_c = part.mimeType) != null ? _c : detectImageMimeType(imageUint8),\n                providerMetadata: part.experimental_providerMetadata\n              };\n            }\n          }\n        }).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ).map((part) => {\n          const { experimental_providerMetadata, ...rest } = part;\n          return {\n            ...rest,\n            providerMetadata: experimental_providerMetadata\n          };\n        }),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          providerMetadata: part.experimental_providerMetadata\n        })),\n        providerMetadata: message.experimental_providerMetadata\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadImages(messages, downloadImplementation) {\n  const urls = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter((part) => part.type === \"image\").map((part) => part.image).map(\n    (part) => (\n      // support string urls in image parts:\n      typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part\n    )\n  ).filter((image) => image instanceof URL);\n  const downloadedImages = await Promise.all(\n    urls.map(async (url) => ({\n      url,\n      data: await downloadImplementation({ url })\n    }))\n  );\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data])\n  );\n}\n\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name5,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a5] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidArgumentError(error) {\n    return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      parameter: this.parameter,\n      value: this.value\n    };\n  }\n};\n_a5 = symbol5;\n\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/prompt/validate-prompt.ts\n\n\n\n\n// core/prompt/message.ts\n\n\n// core/types/provider-metadata.ts\n\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.lazy(\n  () => zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.null(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.number(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.array(jsonValueSchema)\n  ])\n);\n\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.record(\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema)\n);\n\n// core/prompt/content-part.ts\n\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"text\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"image\"),\n  image: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(URL)]),\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-call\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  args: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-result\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  result: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown(),\n  isError: zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean().optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\n\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"system\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"user\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([textPartSchema, imagePartSchema]))\n  ]),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"assistant\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([textPartSchema, toolCallPartSchema]))\n  ]),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(toolResultPartSchema),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema\n]);\n\n// core/prompt/validate-prompt.ts\nfunction validatePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  if (prompt.prompt != null) {\n    if (typeof prompt.prompt !== \"string\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n        prompt,\n        message: \"prompt must be a string\"\n      });\n    }\n    return {\n      type: \"prompt\",\n      prompt: prompt.prompt,\n      messages: void 0,\n      system: prompt.system\n    };\n  }\n  if (prompt.messages != null) {\n    const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n      value: prompt.messages,\n      schema: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(coreMessageSchema)\n    });\n    if (!validationResult.success) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n        prompt,\n        message: \"messages must be an array of CoreMessage\",\n        cause: validationResult.error\n      });\n    }\n    return {\n      type: \"messages\",\n      prompt: void 0,\n      messages: prompt.messages,\n      // only possible case bc of checks above\n      system: prompt.system\n    };\n  }\n  throw new Error(\"unreachable\");\n}\n\n// core/types/usage.ts\nfunction calculateLanguageModelUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, {\n  contentType,\n  dataStreamVersion\n}) {\n  var _a11;\n  const headers = new Headers((_a11 = init == null ? void 0 : init.headers) != null ? _a11 : {});\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", contentType);\n  }\n  if (dataStreamVersion !== void 0) {\n    headers.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n  }\n  return headers;\n}\n\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,\n  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX\n}) {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : void 0,\n    prompt != null && prompt.length > 0 ? \"\" : void 0,\n    // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : void 0,\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/no-object-generated-error.ts\n\nvar name6 = \"AI_NoObjectGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No object generated.\" } = {}) {\n    super({ name: name6, message });\n    this[_a6] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoObjectGeneratedError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a6 = symbol6;\n\n// core/generate-object/output-strategy.ts\n\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  validateFinalResult(value) {\n    return value === void 0 ? { success: false, error: new NoObjectGeneratedError() } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n  return {\n    type: \"enum\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: { type: \"array\", items: itemSchema }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      var _a11;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a11 = latestObject == null ? void 0 : latestObject.length) != null ? _a11 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(originalStream, {\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case \"object\": {\n              const array = chunk.object;\n              for (; publishedElements < array.length; publishedElements++) {\n                controller.enqueue(array[publishedElements]);\n              }\n              break;\n            }\n            case \"text-delta\":\n            case \"finish\":\n              break;\n            case \"error\":\n              controller.error(chunk.error);\n              break;\n            default: {\n              const _exhaustiveCheck = chunk;\n              throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n            }\n          }\n        }\n      });\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    validatePartialResult() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"partial results in enum mode\"\n      });\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (mode === \"auto\" || mode === \"tool\") {\n      throw new InvalidArgumentError({\n        parameter: \"mode\",\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.'\n      });\n    }\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aiobj-\", size: 24 });\nasync function generateObject({\n  model,\n  enum: enumValues,\n  // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = \"object\",\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  _internal: {\n    generateId: generateId3 = originalGenerateId,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  var _a11;\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n    mode = \"json\";\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a11 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a11 : false });\n  return recordSpan({\n    name: \"ai.generateObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.output\": outputStrategy.type,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let result;\n      let finishReason;\n      let usage;\n      let warnings;\n      let rawResponse;\n      let response;\n      let logprobs;\n      let resultProviderMetadata;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = validatePrompt({\n            system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n              prompt: system,\n              schema: outputStrategy.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a12, _b, _c, _d, _e, _f;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-json\",\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata,\n                  abortSignal,\n                  headers\n                });\n                if (result2.text === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                const responseData = {\n                  id: (_b = (_a12 = result2.response) == null ? void 0 : _a12.id) != null ? _b : generateId3(),\n                  timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                  modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                };\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": result2.finishReason,\n                      \"ai.response.object\": { output: () => result2.text },\n                      \"ai.response.id\": responseData.id,\n                      \"ai.response.model\": responseData.modelId,\n                      \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      // deprecated:\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.result.object\": { output: () => result2.text },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.response.id\": responseData.id,\n                      \"gen_ai.response.model\": responseData.modelId,\n                      \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText: result2.text, responseData };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          response = generateResult.responseData;\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = validatePrompt({\n            system,\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a12, _b, _c, _d, _e, _f, _g, _h;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-tool\",\n                    tool: {\n                      type: \"function\",\n                      name: schemaName != null ? schemaName : \"json\",\n                      description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                      parameters: outputStrategy.jsonSchema\n                    }\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata,\n                  abortSignal,\n                  headers\n                });\n                const objectText = (_b = (_a12 = result2.toolCalls) == null ? void 0 : _a12[0]) == null ? void 0 : _b.args;\n                if (objectText === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                const responseData = {\n                  id: (_d = (_c = result2.response) == null ? void 0 : _c.id) != null ? _d : generateId3(),\n                  timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                  modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                };\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": result2.finishReason,\n                      \"ai.response.object\": { output: () => objectText },\n                      \"ai.response.id\": responseData.id,\n                      \"ai.response.model\": responseData.modelId,\n                      \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      // deprecated:\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.result.object\": { output: () => objectText },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.response.id\": responseData.id,\n                      \"gen_ai.response.model\": responseData.modelId,\n                      \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText, responseData };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          response = generateResult.responseData;\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({ text: result });\n      if (!parseResult.success) {\n        throw parseResult.error;\n      }\n      const validationResult = outputStrategy.validateFinalResult(\n        parseResult.value\n      );\n      if (!validationResult.success) {\n        throw validationResult.error;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": finishReason,\n            \"ai.response.object\": {\n              output: () => JSON.stringify(validationResult.value)\n            },\n            \"ai.usage.promptTokens\": usage.promptTokens,\n            \"ai.usage.completionTokens\": usage.completionTokens,\n            // deprecated:\n            \"ai.finishReason\": finishReason,\n            \"ai.result.object\": {\n              output: () => JSON.stringify(validationResult.value)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateObjectResult({\n        object: validationResult.value,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        response: {\n          ...response,\n          headers: rawResponse == null ? void 0 : rawResponse.headers\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata\n      });\n    }\n  });\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.rawResponse = {\n      headers: options.response.headers\n    };\n    this.logprobs = options.logprobs;\n  }\n  toJsonResponse(init) {\n    var _a11;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_generateObject = generateObject;\n\n// core/generate-object/stream-object.ts\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get value() {\n    if (this.promise) {\n      return this.promise;\n    }\n    this.promise = new Promise((resolve, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    return this.promise;\n  }\n  resolve(value) {\n    var _a11;\n    this.status = { type: \"resolved\", value };\n    if (this.promise) {\n      (_a11 = this._resolve) == null ? void 0 : _a11.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a11;\n    this.status = { type: \"rejected\", error };\n    if (this.promise) {\n      (_a11 = this._reject) == null ? void 0 : _a11.call(this, error);\n    }\n  }\n};\n\n// core/util/now.ts\nfunction now() {\n  var _a11, _b;\n  return (_b = (_a11 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a11.now()) != null ? _b : Date.now();\n}\n\n// core/generate-object/stream-object.ts\n\n\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(init, {\n  contentType,\n  dataStreamVersion\n}) {\n  const headers = {};\n  if ((init == null ? void 0 : init.headers) != null) {\n    for (const [key, value] of Object.entries(init.headers)) {\n      headers[key] = value;\n    }\n  }\n  if (headers[\"Content-Type\"] == null) {\n    headers[\"Content-Type\"] = contentType;\n  }\n  if (dataStreamVersion !== void 0) {\n    headers[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n  }\n  return headers;\n}\n\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  response.writeHead(status != null ? status : 200, statusText, headers);\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aiobj-\", size: 24 });\nasync function streamObject({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = \"object\",\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  onFinish,\n  _internal: {\n    generateId: generateId3 = originalGenerateId2,\n    currentDate = () => /* @__PURE__ */ new Date(),\n    now: now2 = now\n  } = {},\n  ...settings\n}) {\n  var _a11;\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription\n  });\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n  if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n    mode = \"json\";\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a11 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a11 : false });\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  return recordSpan({\n    name: \"ai.streamObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.streamObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.output\": outputStrategy.type,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let callOptions;\n      let transformer;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = validatePrompt({\n            system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n              prompt: system,\n              schema: outputStrategy.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-json\",\n              schema: outputStrategy.jsonSchema,\n              name: schemaName,\n              description: schemaDescription\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            providerMetadata,\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform: (chunk, controller) => {\n              switch (chunk.type) {\n                case \"text-delta\":\n                  controller.enqueue(chunk.textDelta);\n                  break;\n                case \"response-metadata\":\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = validatePrompt({\n            system,\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-tool\",\n              tool: {\n                type: \"function\",\n                name: schemaName != null ? schemaName : \"json\",\n                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                parameters: outputStrategy.jsonSchema\n              }\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            providerMetadata,\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"tool-call-delta\":\n                  controller.enqueue(chunk.argsTextDelta);\n                  break;\n                case \"response-metadata\":\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan,\n        startTimestampMs\n      } = await retry(\n        () => recordSpan({\n          name: \"ai.streamObject.doStream\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: \"ai.streamObject.doStream\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.format\": {\n                input: () => callOptions.inputFormat\n              },\n              \"ai.prompt.messages\": {\n                input: () => JSON.stringify(callOptions.prompt)\n              },\n              \"ai.settings.mode\": mode,\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n              \"gen_ai.request.max_tokens\": settings.maxTokens,\n              \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n              \"gen_ai.request.temperature\": settings.temperature,\n              \"gen_ai.request.top_k\": settings.topK,\n              \"gen_ai.request.top_p\": settings.topP\n            }\n          }),\n          tracer,\n          endWhenDone: false,\n          fn: async (doStreamSpan2) => ({\n            startTimestampMs: now2(),\n            doStreamSpan: doStreamSpan2,\n            result: await model.doStream(callOptions)\n          })\n        })\n      );\n      return new DefaultStreamObjectResult({\n        outputStrategy,\n        stream: stream.pipeThrough(new TransformStream(transformer)),\n        warnings,\n        rawResponse,\n        onFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry,\n        startTimestampMs,\n        modelId: model.modelId,\n        now: now2,\n        currentDate,\n        generateId: generateId3\n      });\n    }\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    outputStrategy,\n    onFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry,\n    startTimestampMs,\n    modelId,\n    now: now2,\n    currentDate,\n    generateId: generateId3\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    this.outputStrategy = outputStrategy;\n    this.objectPromise = new DelayedPromise();\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n    this.response = responsePromise;\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise\n    } = createResolvablePromise();\n    this.experimental_providerMetadata = providerMetadataPromise;\n    let usage;\n    let finishReason;\n    let providerMetadata;\n    let object;\n    let error;\n    let accumulatedText = \"\";\n    let textDelta = \"\";\n    let response = {\n      id: generateId3(),\n      timestamp: currentDate(),\n      modelId\n    };\n    let latestObjectJson = void 0;\n    let latestObject = void 0;\n    let isFirstChunk = true;\n    let isFirstDelta = true;\n    const self = this;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          var _a11, _b, _c;\n          if (isFirstChunk) {\n            const msToFirstChunk = now2() - startTimestampMs;\n            isFirstChunk = false;\n            doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n              \"ai.stream.msToFirstChunk\": msToFirstChunk\n            });\n            doStreamSpan.setAttributes({\n              \"ai.stream.msToFirstChunk\": msToFirstChunk\n            });\n          }\n          if (typeof chunk === \"string\") {\n            accumulatedText += chunk;\n            textDelta += chunk;\n            const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.parsePartialJson)(accumulatedText);\n            if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n              const validationResult = outputStrategy.validatePartialResult({\n                value: currentObjectJson,\n                textDelta,\n                latestObject,\n                isFirstDelta,\n                isFinalDelta: parseState === \"successful-parse\"\n              });\n              if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.isDeepEqualData)(latestObject, validationResult.value.partial)) {\n                latestObjectJson = currentObjectJson;\n                latestObject = validationResult.value.partial;\n                controller.enqueue({\n                  type: \"object\",\n                  object: latestObject\n                });\n                controller.enqueue({\n                  type: \"text-delta\",\n                  textDelta: validationResult.value.textDelta\n                });\n                textDelta = \"\";\n                isFirstDelta = false;\n              }\n            }\n            return;\n          }\n          switch (chunk.type) {\n            case \"response-metadata\": {\n              response = {\n                id: (_a11 = chunk.id) != null ? _a11 : response.id,\n                timestamp: (_b = chunk.timestamp) != null ? _b : response.timestamp,\n                modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n              };\n              break;\n            }\n            case \"finish\": {\n              if (textDelta !== \"\") {\n                controller.enqueue({ type: \"text-delta\", textDelta });\n              }\n              finishReason = chunk.finishReason;\n              usage = calculateLanguageModelUsage(chunk.usage);\n              providerMetadata = chunk.providerMetadata;\n              controller.enqueue({ ...chunk, usage, response });\n              resolveUsage(usage);\n              resolveProviderMetadata(providerMetadata);\n              resolveResponse({\n                ...response,\n                headers: rawResponse == null ? void 0 : rawResponse.headers\n              });\n              const validationResult = outputStrategy.validateFinalResult(latestObjectJson);\n              if (validationResult.success) {\n                object = validationResult.value;\n                self.objectPromise.resolve(object);\n              } else {\n                error = validationResult.error;\n                self.objectPromise.reject(error);\n              }\n              break;\n            }\n            default: {\n              controller.enqueue(chunk);\n              break;\n            }\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          try {\n            const finalUsage = usage != null ? usage : {\n              promptTokens: NaN,\n              completionTokens: NaN,\n              totalTokens: NaN\n            };\n            doStreamSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.response.finishReason\": finishReason,\n                  \"ai.response.object\": {\n                    output: () => JSON.stringify(object)\n                  },\n                  \"ai.response.id\": response.id,\n                  \"ai.response.model\": response.modelId,\n                  \"ai.response.timestamp\": response.timestamp.toISOString(),\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  // deprecated\n                  \"ai.finishReason\": finishReason,\n                  \"ai.result.object\": { output: () => JSON.stringify(object) },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.response.finish_reasons\": [finishReason],\n                  \"gen_ai.response.id\": response.id,\n                  \"gen_ai.response.model\": response.modelId,\n                  \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                  \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                }\n              })\n            );\n            doStreamSpan.end();\n            rootSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.response.object\": {\n                    output: () => JSON.stringify(object)\n                  },\n                  // deprecated\n                  \"ai.result.object\": { output: () => JSON.stringify(object) }\n                }\n              })\n            );\n            await (onFinish == null ? void 0 : onFinish({\n              usage: finalUsage,\n              object,\n              error,\n              rawResponse,\n              response: {\n                ...response,\n                headers: rawResponse == null ? void 0 : rawResponse.headers\n              },\n              warnings,\n              experimental_providerMetadata: providerMetadata\n            }));\n          } catch (error2) {\n            controller.error(error2);\n          } finally {\n            rootSpan.end();\n          }\n        }\n      })\n    );\n  }\n  get object() {\n    return this.objectPromise.value;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"object\":\n            controller.enqueue(chunk.object);\n            break;\n          case \"text-delta\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.originalStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"text-delta\":\n            controller.enqueue(chunk.textDelta);\n            break;\n          case \"object\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream())\n    });\n  }\n  toTextStreamResponse(init) {\n    var _a11;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamObject = streamObject;\n\n// core/generate-text/generate-text.ts\n\n\n// errors/index.ts\n\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name7 = \"AI_InvalidToolArgumentsError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(\n      cause\n    )}`\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidToolArgumentsError(error) {\n    return error instanceof Error && error.name === name7 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      toolName: this.toolName,\n      toolArgs: this.toolArgs\n    };\n  }\n};\n_a7 = symbol7;\n\n// errors/no-such-tool-error.ts\n\nvar name8 = \"AI_NoSuchToolError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name8, message });\n    this[_a8] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchToolError(error) {\n    return error instanceof Error && error.name === name8 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      toolName: this.toolName,\n      availableTools: this.availableTools\n    };\n  }\n};\n_a8 = symbol8;\n\n// core/prompt/message-conversion-error.ts\n\nvar name9 = \"AI_MessageConversionError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name9, message });\n    this[_a9] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n  return object != null && Object.keys(object).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  return {\n    tools: Object.entries(tools).map(([name11, tool2]) => ({\n      type: \"function\",\n      name: name11,\n      description: tool2.description,\n      parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(tool2.parameters).jsonSchema\n    })),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({\n  text = \"\",\n  toolCalls,\n  toolResults\n}) {\n  const responseMessages = [];\n  responseMessages.push({\n    role: \"assistant\",\n    content: [{ type: \"text\", text }, ...toolCalls]\n  });\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResults.map((result) => ({\n        type: \"tool-result\",\n        toolCallId: result.toolCallId,\n        toolName: result.toolName,\n        result: result.result\n      }))\n    });\n  }\n  return responseMessages;\n}\n\n// core/generate-text/tool-call.ts\n\n\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n    text: toolCall.args,\n    schema: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.asSchema)(tool2.parameters)\n  });\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aitxt-\", size: 24 });\nasync function generateText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxAutomaticRoundtrips = 0,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  _internal: {\n    generateId: generateId3 = originalGenerateId3,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  var _a11;\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: \"maxSteps\",\n      value: maxSteps,\n      message: \"maxSteps must be at least 1\"\n    });\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a11 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a11 : false });\n  return recordSpan({\n    name: \"ai.generateText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateText\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.settings.maxSteps\": maxSteps\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a12, _b, _c, _d, _e;\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const validatedPrompt = validatePrompt({\n        system,\n        prompt,\n        messages\n      });\n      const mode = {\n        type: \"regular\",\n        ...prepareToolsAndToolChoice({ tools, toolChoice })\n      };\n      const callSettings = prepareCallSettings(settings);\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatedPrompt,\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      let currentModelResponse;\n      let currentToolCalls = [];\n      let currentToolResults = [];\n      let stepCount = 0;\n      const responseMessages = [];\n      const steps = [];\n      const usage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0\n      };\n      do {\n        const currentInputFormat = stepCount === 0 ? validatedPrompt.type : \"messages\";\n        currentModelResponse = await retry(\n          () => recordSpan({\n            name: \"ai.generateText.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateText.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.format\": { input: () => currentInputFormat },\n                \"ai.prompt.messages\": {\n                  input: () => JSON.stringify(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_k\": settings.topK,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a13, _b2, _c2, _d2, _e2, _f;\n              const result = await model.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: currentInputFormat,\n                prompt: promptMessages,\n                providerMetadata,\n                abortSignal,\n                headers\n              });\n              const responseData = {\n                id: (_b2 = (_a13 = result.response) == null ? void 0 : _a13.id) != null ? _b2 : generateId3(),\n                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                modelId: (_f = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f : model.modelId\n              };\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result.finishReason,\n                    \"ai.response.text\": {\n                      output: () => result.text\n                    },\n                    \"ai.response.toolCalls\": {\n                      output: () => JSON.stringify(result.toolCalls)\n                    },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": result.finishReason,\n                    \"ai.result.text\": {\n                      output: () => result.text\n                    },\n                    \"ai.result.toolCalls\": {\n                      output: () => JSON.stringify(result.toolCalls)\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result.finishReason],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                  }\n                })\n              );\n              return { ...result, response: responseData };\n            }\n          })\n        );\n        currentToolCalls = ((_a12 = currentModelResponse.toolCalls) != null ? _a12 : []).map(\n          (modelToolCall) => parseToolCall({ toolCall: modelToolCall, tools })\n        );\n        currentToolResults = tools == null ? [] : await executeTools({\n          toolCalls: currentToolCalls,\n          tools,\n          tracer,\n          telemetry\n        });\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage\n        );\n        usage.completionTokens += currentUsage.completionTokens;\n        usage.promptTokens += currentUsage.promptTokens;\n        usage.totalTokens += currentUsage.totalTokens;\n        steps.push({\n          text: (_b = currentModelResponse.text) != null ? _b : \"\",\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          response: {\n            ...currentModelResponse.response,\n            headers: (_c = currentModelResponse.rawResponse) == null ? void 0 : _c.headers\n          }\n        });\n        const newResponseMessages = toResponseMessages({\n          text: currentModelResponse.text,\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults\n        });\n        responseMessages.push(...newResponseMessages);\n        promptMessages.push(\n          ...newResponseMessages.map(\n            (message) => convertToLanguageModelMessage(message, null)\n          )\n        );\n      } while (\n        // there are tool calls:\n        currentToolCalls.length > 0 && // all current tool calls have results:\n        currentToolResults.length === currentToolCalls.length && // the number of steps is less than the maximum:\n        ++stepCount < maxSteps\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": currentModelResponse.finishReason,\n            \"ai.response.text\": {\n              output: () => currentModelResponse.text\n            },\n            \"ai.response.toolCalls\": {\n              output: () => JSON.stringify(currentModelResponse.toolCalls)\n            },\n            \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n            \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens,\n            // deprecated:\n            \"ai.finishReason\": currentModelResponse.finishReason,\n            \"ai.result.text\": {\n              output: () => currentModelResponse.text\n            },\n            \"ai.result.toolCalls\": {\n              output: () => JSON.stringify(currentModelResponse.toolCalls)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateTextResult({\n        // Always return a string so that the caller doesn't have to check for undefined.\n        // If they need to check if the model did not return any text,\n        // they can check the length of the string:\n        text: (_d = currentModelResponse.text) != null ? _d : \"\",\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        response: {\n          ...currentModelResponse.response,\n          headers: (_e = currentModelResponse.rawResponse) == null ? void 0 : _e.headers\n        },\n        logprobs: currentModelResponse.logprobs,\n        responseMessages,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata\n      });\n    }\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolCall.toolName,\n            \"ai.toolCall.id\": toolCall.toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(toolCall.args)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          const result2 = await tool2.execute(toolCall.args);\n          try {\n            span.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.toolCall.result\": {\n                    output: () => JSON.stringify(result2)\n                  }\n                }\n              })\n            );\n          } catch (ignored) {\n          }\n          return result2;\n        }\n      });\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.response = options.response;\n    this.responseMessages = options.responseMessages;\n    this.roundtrips = options.steps;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.rawResponse = {\n      headers: options.response.headers\n    };\n    this.logprobs = options.logprobs;\n  }\n};\nvar experimental_generateText = generateText;\n\n// core/generate-text/stream-text.ts\n\n\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      return;\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n    },\n    close: () => {\n      isClosed = true;\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    }\n  };\n}\n\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n  let lastRead1 = void 0;\n  let lastRead2 = void 0;\n  let stream1Done = false;\n  let stream2Done = false;\n  async function readStream1(controller) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n      const result = await lastRead1;\n      lastRead1 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  async function readStream2(controller) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n      const result = await lastRead2;\n      lastRead2 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n        const { result, reader } = await Promise.race([\n          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),\n          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))\n        ]);\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n        if (reader === reader1) {\n          lastRead1 = void 0;\n          if (result.done) {\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = void 0;\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    }\n  });\n}\n\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const activeToolCalls = {};\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"response-metadata\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call-delta\": {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: \"tool-call-streaming-start\",\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              });\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n            controller.enqueue({\n              type: \"tool-call-delta\",\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta\n            });\n          }\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_6__.generateId)();\n              outstandingToolCalls.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.args)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => tool2.execute(toolCall.args).then(\n                  (result) => {\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-result\",\n                      result\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                    try {\n                      span.setAttributes(\n                        selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.toolCall.result\": {\n                              output: () => JSON.stringify(result)\n                            }\n                          }\n                        })\n                      );\n                    } catch (ignored) {\n                    }\n                  },\n                  (error) => {\n                    toolResultsStreamController.enqueue({\n                      type: \"error\",\n                      error\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                  }\n                )\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata\n          });\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({ prefix: \"aitxt-\", size: 24 });\nasync function streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxToolRoundtrips = 0,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata: providerMetadata,\n  experimental_toolCallStreaming: toolCallStreaming = false,\n  onChunk,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId3 = originalGenerateId4,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  var _a11;\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: \"maxSteps\",\n      value: maxSteps,\n      message: \"maxSteps must be at least 1\"\n    });\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a11 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a11 : false });\n  return recordSpan({\n    name: \"ai.streamText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.settings.maxSteps\": maxSteps\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const startStep = async ({\n        promptMessages: promptMessages2,\n        promptType\n      }) => {\n        const {\n          result: { stream: stream2, warnings: warnings2, rawResponse: rawResponse2 },\n          doStreamSpan: doStreamSpan2,\n          startTimestampMs: startTimestampMs2\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamText.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamText.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.format\": {\n                  input: () => promptType\n                },\n                \"ai.prompt.messages\": {\n                  input: () => JSON.stringify(promptMessages2)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_k\": settings.topK,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan3) => ({\n              startTimestampMs: now2(),\n              // get before the call\n              doStreamSpan: doStreamSpan3,\n              result: await model.doStream({\n                mode: {\n                  type: \"regular\",\n                  ...prepareToolsAndToolChoice({ tools, toolChoice })\n                },\n                ...prepareCallSettings(settings),\n                inputFormat: promptType,\n                prompt: promptMessages2,\n                providerMetadata,\n                abortSignal,\n                headers\n              })\n            })\n          })\n        );\n        return {\n          result: {\n            stream: runToolsTransformation({\n              tools,\n              generatorStream: stream2,\n              toolCallStreaming,\n              tracer,\n              telemetry\n            }),\n            warnings: warnings2,\n            rawResponse: rawResponse2\n          },\n          doStreamSpan: doStreamSpan2,\n          startTimestampMs: startTimestampMs2\n        };\n      };\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatePrompt({ system, prompt, messages }),\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan,\n        startTimestampMs\n      } = await startStep({\n        promptType: validatePrompt({ system, prompt, messages }).type,\n        promptMessages\n      });\n      return new DefaultStreamTextResult({\n        stream,\n        warnings,\n        rawResponse,\n        onChunk,\n        onFinish,\n        onStepFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry,\n        startTimestampMs,\n        maxSteps,\n        startStep,\n        promptMessages,\n        modelId: model.modelId,\n        now: now2,\n        currentDate,\n        generateId: generateId3\n      });\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    onChunk,\n    onFinish,\n    onStepFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry,\n    startTimestampMs,\n    maxSteps,\n    startStep,\n    promptMessages,\n    modelId,\n    now: now2,\n    currentDate,\n    generateId: generateId3\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    const { resolve: resolveFinishReason, promise: finishReasonPromise } = createResolvablePromise();\n    this.finishReason = finishReasonPromise;\n    const { resolve: resolveText, promise: textPromise } = createResolvablePromise();\n    this.text = textPromise;\n    const { resolve: resolveToolCalls, promise: toolCallsPromise } = createResolvablePromise();\n    this.toolCalls = toolCallsPromise;\n    const { resolve: resolveToolResults, promise: toolResultsPromise } = createResolvablePromise();\n    this.toolResults = toolResultsPromise;\n    const { resolve: resolveSteps, promise: stepsPromise } = createResolvablePromise();\n    this.steps = stepsPromise;\n    const {\n      resolve: resolveProviderMetadata,\n      promise: providerMetadataPromise\n    } = createResolvablePromise();\n    this.experimental_providerMetadata = providerMetadataPromise;\n    const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n    this.response = responsePromise;\n    const {\n      stream: stitchableStream,\n      addStream,\n      close: closeStitchableStream\n    } = createStitchableStream();\n    this.originalStream = stitchableStream;\n    const stepResults = [];\n    const self = this;\n    function addStepStream({\n      stream: stream2,\n      startTimestamp,\n      doStreamSpan: doStreamSpan2,\n      currentStep,\n      promptMessages: promptMessages2,\n      usage = {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0\n      }\n    }) {\n      const stepToolCalls = [];\n      const stepToolResults = [];\n      let stepFinishReason = \"unknown\";\n      let stepUsage = {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0\n      };\n      let stepProviderMetadata;\n      let stepFirstChunk = true;\n      let stepText = \"\";\n      let stepLogProbs;\n      let stepResponse = {\n        id: generateId3(),\n        timestamp: currentDate(),\n        modelId\n      };\n      addStream(\n        stream2.pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a11, _b, _c;\n              if (stepFirstChunk) {\n                const msToFirstChunk = now2() - startTimestamp;\n                stepFirstChunk = false;\n                doStreamSpan2.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.response.msToFirstChunk\": msToFirstChunk,\n                  // deprecated:\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan2.setAttributes({\n                  \"ai.response.msToFirstChunk\": msToFirstChunk,\n                  // deprecated:\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                return;\n              }\n              const chunkType = chunk.type;\n              switch (chunkType) {\n                case \"text-delta\": {\n                  controller.enqueue(chunk);\n                  stepText += chunk.textDelta;\n                  await (onChunk == null ? void 0 : onChunk({ chunk }));\n                  break;\n                }\n                case \"tool-call\": {\n                  controller.enqueue(chunk);\n                  stepToolCalls.push(chunk);\n                  await (onChunk == null ? void 0 : onChunk({ chunk }));\n                  break;\n                }\n                case \"tool-result\": {\n                  controller.enqueue(chunk);\n                  stepToolResults.push(chunk);\n                  await (onChunk == null ? void 0 : onChunk({ chunk }));\n                  break;\n                }\n                case \"response-metadata\": {\n                  stepResponse = {\n                    id: (_a11 = chunk.id) != null ? _a11 : stepResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  stepUsage = chunk.usage;\n                  stepFinishReason = chunk.finishReason;\n                  stepProviderMetadata = chunk.experimental_providerMetadata;\n                  stepLogProbs = chunk.logprobs;\n                  const msToFinish = now2() - startTimestamp;\n                  doStreamSpan2.addEvent(\"ai.stream.finish\");\n                  doStreamSpan2.setAttributes({\n                    \"ai.response.msToFinish\": msToFinish,\n                    \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                  });\n                  break;\n                }\n                case \"tool-call-streaming-start\":\n                case \"tool-call-delta\": {\n                  controller.enqueue(chunk);\n                  await (onChunk == null ? void 0 : onChunk({ chunk }));\n                  break;\n                }\n                case \"error\": {\n                  controller.enqueue(chunk);\n                  stepFinishReason = \"error\";\n                  break;\n                }\n                default: {\n                  const exhaustiveCheck = chunkType;\n                  throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n              try {\n                doStreamSpan2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": stepFinishReason,\n                      \"ai.response.text\": { output: () => stepText },\n                      \"ai.response.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      },\n                      \"ai.response.id\": stepResponse.id,\n                      \"ai.response.model\": stepResponse.modelId,\n                      \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                      \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                      // deprecated\n                      \"ai.finishReason\": stepFinishReason,\n                      \"ai.result.text\": { output: () => stepText },\n                      \"ai.result.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                      \"gen_ai.response.id\": stepResponse.id,\n                      \"gen_ai.response.model\": stepResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                      \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                    }\n                  })\n                );\n              } catch (error) {\n              } finally {\n                doStreamSpan2.end();\n              }\n              controller.enqueue({\n                type: \"step-finish\",\n                finishReason: stepFinishReason,\n                usage: stepUsage,\n                experimental_providerMetadata: stepProviderMetadata,\n                logprobs: stepLogProbs,\n                response: stepResponse\n              });\n              const stepResult = {\n                text: stepText,\n                toolCalls: stepToolCalls,\n                toolResults: stepToolResults,\n                finishReason: stepFinishReason,\n                usage: stepUsage,\n                warnings: self.warnings,\n                logprobs: stepLogProbs,\n                response: stepResponse,\n                rawResponse: self.rawResponse\n              };\n              stepResults.push(stepResult);\n              await (onStepFinish == null ? void 0 : onStepFinish(stepResult));\n              const combinedUsage = {\n                promptTokens: usage.promptTokens + stepUsage.promptTokens,\n                completionTokens: usage.completionTokens + stepUsage.completionTokens,\n                totalTokens: usage.totalTokens + stepUsage.totalTokens\n              };\n              if (\n                // there are tool calls:\n                stepToolCalls.length > 0 && // all current tool calls have results:\n                stepToolResults.length === stepToolCalls.length && // the number of steps is less than the maximum:\n                currentStep + 1 < maxSteps\n              ) {\n                promptMessages2.push(\n                  ...toResponseMessages({\n                    text: stepText,\n                    toolCalls: stepToolCalls,\n                    toolResults: stepToolResults\n                  }).map(\n                    (message) => convertToLanguageModelMessage(message, null)\n                  )\n                );\n                const {\n                  result,\n                  doStreamSpan: doStreamSpan3,\n                  startTimestampMs: startTimestamp2\n                } = await startStep({\n                  promptType: \"messages\",\n                  promptMessages: promptMessages2\n                });\n                self.warnings = result.warnings;\n                self.rawResponse = result.rawResponse;\n                addStepStream({\n                  stream: result.stream,\n                  startTimestamp: startTimestamp2,\n                  doStreamSpan: doStreamSpan3,\n                  currentStep: currentStep + 1,\n                  promptMessages: promptMessages2,\n                  usage: combinedUsage\n                });\n                return;\n              }\n              try {\n                controller.enqueue({\n                  type: \"finish\",\n                  finishReason: stepFinishReason,\n                  usage: combinedUsage,\n                  experimental_providerMetadata: stepProviderMetadata,\n                  logprobs: stepLogProbs,\n                  response: stepResponse\n                });\n                closeStitchableStream();\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": stepFinishReason,\n                      \"ai.response.text\": { output: () => stepText },\n                      \"ai.response.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      },\n                      \"ai.usage.promptTokens\": combinedUsage.promptTokens,\n                      \"ai.usage.completionTokens\": combinedUsage.completionTokens,\n                      // deprecated\n                      \"ai.finishReason\": stepFinishReason,\n                      \"ai.result.text\": { output: () => stepText },\n                      \"ai.result.toolCalls\": {\n                        output: () => stepToolCallsJson\n                      }\n                    }\n                  })\n                );\n                resolveUsage(combinedUsage);\n                resolveFinishReason(stepFinishReason);\n                resolveText(stepText);\n                resolveToolCalls(stepToolCalls);\n                resolveProviderMetadata(stepProviderMetadata);\n                resolveToolResults(stepToolResults);\n                resolveResponse({\n                  ...stepResponse,\n                  headers: rawResponse == null ? void 0 : rawResponse.headers\n                });\n                resolveSteps(stepResults);\n                await (onFinish == null ? void 0 : onFinish({\n                  finishReason: stepFinishReason,\n                  logprobs: stepLogProbs,\n                  usage: combinedUsage,\n                  text: stepText,\n                  toolCalls: stepToolCalls,\n                  // The tool results are inferred as a never[] type, because they are\n                  // optional and the execute method with an inferred result type is\n                  // optional as well. Therefore we need to cast the toolResults to any.\n                  // The type exposed to the users will be correctly inferred.\n                  toolResults: stepToolResults,\n                  rawResponse,\n                  response: {\n                    ...stepResponse,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                  },\n                  warnings,\n                  experimental_providerMetadata: stepProviderMetadata,\n                  steps: stepResults\n                  // see tool results comment above\n                }));\n              } catch (error) {\n                controller.error(error);\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        )\n      );\n    }\n    addStepStream({\n      stream,\n      startTimestamp: startTimestampMs,\n      doStreamSpan,\n      currentStep: 0,\n      promptMessages,\n      usage: void 0\n    });\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.originalStream.tee();\n    this.originalStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          controller.enqueue(chunk.textDelta);\n        } else if (chunk.type === \"error\") {\n          controller.error(chunk.error);\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  toAIStream(callbacks = {}) {\n    return this.toDataStreamInternal({ callbacks });\n  }\n  toDataStreamInternal({\n    callbacks = {},\n    getErrorMessage: getErrorMessage4 = () => \"\",\n    // mask error messages for safety by default\n    sendUsage = true\n  } = {}) {\n    let aggregatedResponse = \"\";\n    const callbackTransformer = new TransformStream({\n      async start() {\n        if (callbacks.onStart)\n          await callbacks.onStart();\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"text-delta\") {\n          const textDelta = chunk.textDelta;\n          aggregatedResponse += textDelta;\n          if (callbacks.onToken)\n            await callbacks.onToken(textDelta);\n          if (callbacks.onText)\n            await callbacks.onText(textDelta);\n        }\n      },\n      async flush() {\n        if (callbacks.onCompletion)\n          await callbacks.onCompletion(aggregatedResponse);\n        if (callbacks.onFinal)\n          await callbacks.onFinal(aggregatedResponse);\n      }\n    });\n    const streamPartsTransformer = new TransformStream({\n      transform: async (chunk, controller) => {\n        const chunkType = chunk.type;\n        switch (chunkType) {\n          case \"text-delta\": {\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", chunk.textDelta));\n            break;\n          }\n          case \"tool-call-streaming-start\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_call_streaming_start\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              })\n            );\n            break;\n          }\n          case \"tool-call-delta\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_call_delta\", {\n                toolCallId: chunk.toolCallId,\n                argsTextDelta: chunk.argsTextDelta\n              })\n            );\n            break;\n          }\n          case \"tool-call\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_call\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args\n              })\n            );\n            break;\n          }\n          case \"tool-result\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"tool_result\", {\n                toolCallId: chunk.toolCallId,\n                result: chunk.result\n              })\n            );\n            break;\n          }\n          case \"error\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"error\", getErrorMessage4(chunk.error))\n            );\n            break;\n          }\n          case \"step-finish\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"finish_step\", {\n                finishReason: chunk.finishReason,\n                usage: sendUsage ? {\n                  promptTokens: chunk.usage.promptTokens,\n                  completionTokens: chunk.usage.completionTokens\n                } : void 0\n              })\n            );\n            break;\n          }\n          case \"finish\": {\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"finish_message\", {\n                finishReason: chunk.finishReason,\n                usage: sendUsage ? {\n                  promptTokens: chunk.usage.promptTokens,\n                  completionTokens: chunk.usage.completionTokens\n                } : void 0\n              })\n            );\n            break;\n          }\n          default: {\n            const exhaustiveCheck = chunkType;\n            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n    return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer).pipeThrough(new TextEncoderStream());\n  }\n  pipeAIStreamToResponse(response, init) {\n    return this.pipeDataStreamToResponse(response, init);\n  }\n  pipeDataStreamToResponse(response, options) {\n    const init = options == null ? void 0 : \"init\" in options ? options.init : {\n      headers: \"headers\" in options ? options.headers : void 0,\n      status: \"status\" in options ? options.status : void 0,\n      statusText: \"statusText\" in options ? options.statusText : void 0\n    };\n    const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n    const getErrorMessage4 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n    const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\",\n        dataStreamVersion: \"v1\"\n      }),\n      stream: this.toDataStream({ data, getErrorMessage: getErrorMessage4, sendUsage })\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream())\n    });\n  }\n  toAIStreamResponse(options) {\n    return this.toDataStreamResponse(options);\n  }\n  toDataStream(options) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n      sendUsage: options == null ? void 0 : options.sendUsage\n    });\n    return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n  }\n  toDataStreamResponse(options) {\n    var _a11;\n    const init = options == null ? void 0 : \"init\" in options ? options.init : {\n      headers: \"headers\" in options ? options.headers : void 0,\n      status: \"status\" in options ? options.status : void 0,\n      statusText: \"statusText\" in options ? options.statusText : void 0\n    };\n    const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n    const getErrorMessage4 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n    const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n    return new Response(\n      this.toDataStream({ data, getErrorMessage: getErrorMessage4, sendUsage }),\n      {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n          contentType: \"text/plain; charset=utf-8\",\n          dataStreamVersion: \"v1\"\n        })\n      }\n    );\n  }\n  toTextStreamResponse(init) {\n    var _a11;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamText = streamText;\n\n// core/middleware/wrap-language-model.ts\nvar experimental_wrapLanguageModel = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId\n}) => {\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n  return {\n    specificationVersion: \"v1\",\n    provider: providerId != null ? providerId : model.provider,\n    modelId: modelId != null ? modelId : model.modelId,\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      return wrapGenerate ? wrapGenerate({ doGenerate, params: transformedParams, model }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n  var _a11, _b, _c;\n  const parts = [];\n  for (const attachment of attachments) {\n    let url;\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n    switch (url.protocol) {\n      case \"http:\":\n      case \"https:\": {\n        if ((_a11 = attachment.contentType) == null ? void 0 : _a11.startsWith(\"image/\")) {\n          parts.push({ type: \"image\", image: url });\n        }\n        break;\n      }\n      case \"data:\": {\n        let header;\n        let base64Content;\n        let mimeType;\n        try {\n          [header, base64Content] = attachment.url.split(\",\");\n          mimeType = header.split(\";\")[0].split(\":\")[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n        if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n          parts.push({\n            type: \"image\",\n            image: convertDataContentToUint8Array(base64Content)\n          });\n        } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n          parts.push({\n            type: \"text\",\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content)\n            )\n          });\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n  return parts;\n}\n\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages) {\n  const coreMessages = [];\n  for (const message of messages) {\n    const { role, content, toolInvocations, experimental_attachments } = message;\n    switch (role) {\n      case \"system\": {\n        coreMessages.push({\n          role: \"system\",\n          content\n        });\n        break;\n      }\n      case \"user\": {\n        coreMessages.push({\n          role: \"user\",\n          content: experimental_attachments ? [\n            { type: \"text\", text: content },\n            ...attachmentsToParts(experimental_attachments)\n          ] : content\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (toolInvocations == null) {\n          coreMessages.push({ role: \"assistant\", content });\n          break;\n        }\n        coreMessages.push({\n          role: \"assistant\",\n          content: [\n            { type: \"text\", text: content },\n            ...toolInvocations.map(({ toolCallId, toolName, args }) => ({\n              type: \"tool-call\",\n              toolCallId,\n              toolName,\n              args\n            }))\n          ]\n        });\n        coreMessages.push({\n          role: \"tool\",\n          content: toolInvocations.map((ToolInvocation) => {\n            if (!(\"result\" in ToolInvocation)) {\n              throw new MessageConversionError({\n                originalMessage: message,\n                message: \"ToolInvocation must have a result: \" + JSON.stringify(ToolInvocation)\n              });\n            }\n            const { toolCallId, toolName, args, result } = ToolInvocation;\n            return {\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              args,\n              result\n            };\n          })\n        });\n        break;\n      }\n      case \"function\":\n      case \"data\":\n      case \"tool\": {\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return coreMessages;\n}\n\n// core/registry/custom-provider.ts\n\nfunction experimental_customProvider({\n  languageModels,\n  textEmbeddingModels,\n  fallbackProvider\n}) {\n  return {\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    textEmbeddingModel(modelId) {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"textEmbeddingModel\" });\n    }\n  };\n}\n\n// core/registry/no-such-provider-error.ts\n\nvar name10 = \"AI_NoSuchProviderError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name10, modelId, modelType, message });\n    this[_a10] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchProviderError(error) {\n    return error instanceof Error && error.name === name10 && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType,\n      providerId: this.providerId,\n      availableProviders: this.availableProviders\n    };\n  }\n};\n_a10 = symbol10;\n\n// core/registry/provider-registry.ts\n\nfunction experimental_createProviderRegistry(providers) {\n  const registry = new DefaultProviderRegistry();\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor() {\n    this.providers = {};\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: \"languageModel\",\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(\":\");\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId:modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + 1)];\n  }\n  languageModel(id) {\n    var _a11, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    const model = (_b = (_a11 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a11, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a11, _b, _c;\n    const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n    const provider = this.getProvider(providerId);\n    const model = (_c = (_a11 = provider.textEmbeddingModel) == null ? void 0 : _a11.call(provider, modelId)) != null ? _c : \"textEmbedding\" in provider ? (_b = provider.textEmbedding) == null ? void 0 : _b.call(provider, modelId) : void 0;\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(id) {\n    return this.textEmbeddingModel(id);\n  }\n};\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\n      `Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`\n    );\n  }\n  return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n  return vector1.reduce(\n    (accumulator, value, index) => accumulator + value * vector2[index],\n    0\n  );\n}\nfunction magnitude(vector) {\n  return Math.sqrt(dotProduct(vector, vector));\n}\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_7__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a11;\n      await ((_a11 = it.return) == null ? void 0 : _a11.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\n\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n\n// streams/stream-data.ts\nvar StreamData2 = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    this.isClosed = false;\n    this.warningTimeout = null;\n    const self = this;\n    this.stream = new ReadableStream({\n      start: async (controller) => {\n        self.controller = controller;\n        if (true) {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: (controller) => {\n      },\n      cancel: (reason) => {\n        this.isClosed = true;\n      }\n    });\n  }\n  async close() {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.close();\n    this.isClosed = true;\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"data\", [value]))\n    );\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"message_annotations\", [value]))\n    );\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData2 {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a11;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a12, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a12 = value.data.delta.content) == null ? void 0 : _a12[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a11 = error.message) != null ? _a11 : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a11, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a11 = response.body) != null ? _a11 : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a11;\n    return (_a11 = chunk.delta) == null ? void 0 : _a11.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a11;\n  const reader = (_a11 = res.body) == null ? void 0 : _a11.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a11, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a11 = chunk.candidates) == null ? void 0 : _a11[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a11, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a11 = value.token) == null ? void 0 : _a11.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a11, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a11 = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a11.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a11;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a11 = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a11.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n  toAIStream: () => toAIStream,\n  toDataStream: () => toDataStream,\n  toDataStreamResponse: () => toDataStreamResponse\n});\nfunction toAIStream(stream, callbacks) {\n  return toDataStream(stream, callbacks);\n}\nfunction toDataStream(stream, callbacks) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform: async (value, controller) => {\n        var _a11;\n        if (typeof value === \"string\") {\n          controller.enqueue(value);\n          return;\n        }\n        if (\"event\" in value) {\n          if (value.event === \"on_chat_model_stream\") {\n            forwardAIMessageChunk(\n              (_a11 = value.data) == null ? void 0 : _a11.chunk,\n              controller\n            );\n          }\n          return;\n        }\n        forwardAIMessageChunk(value, controller);\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse(stream, options) {\n  var _a11;\n  const dataStream = toDataStream(stream, options == null ? void 0 : options.callbacks);\n  const data = options == null ? void 0 : options.data;\n  const init = options == null ? void 0 : options.init;\n  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n  return new Response(responseStream, {\n    status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n    statusText: init == null ? void 0 : init.statusText,\n    headers: prepareResponseHeaders(init, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    })\n  });\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n  if (typeof chunk.content === \"string\") {\n    controller.enqueue(chunk.content);\n  } else {\n    const content = chunk.content;\n    for (const item of content) {\n      if (item.type === \"text\") {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a11, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a11 = chunk.choices[0]) == null ? void 0 : _a11.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a11, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a11 = choice.delta) == null ? void 0 : _a11.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a11, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a11 = json.choices[0]) == null ? void 0 : _a11.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.createChunkDecoder)();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_5__.formatStreamPart)(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a11;\n  const url = (_a11 = res.urls) == null ? void 0 : _a11.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n  var _a11;\n  response.writeHead((_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  let processedStream = res;\n  if (data) {\n    processedStream = mergeStreams(data.stream, res);\n  }\n  const reader = processedStream.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = mergeStreams(data.stream, res);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0NBQW9DO0FBQ3BFOztBQUVBO0FBTTBCO0FBQzRDOztBQUV0RTtBQUM4Qzs7QUFFOUM7QUFDZ0Q7QUFDdUI7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDO0FBQzlDO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBLCtCQUErQix3REFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsb0VBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLHdCQUF3QixhQUFhO0FBQ2pGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQ0FBa0MsMERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRUFBaUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxzQ0FBc0MsYUFBYTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUEwQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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YWNrOi8vY291bnNlbGxpbmctdGhyb3VnaC1iaWJsZS1mdWxsc3RhY2svLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanM/ZDU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUxMSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZTExLCB7IGdldDogYWxsW25hbWUxMV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzdHJlYW1zL2luZGV4LnRzXG5pbXBvcnQge1xuICBmb3JtYXRTdHJlYW1QYXJ0LFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHJlYWREYXRhU3RyZWFtLFxuICBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2Vcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEltcGwgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL2luZGV4LnRzXG5pbXBvcnQgeyBqc29uU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHV0aWwvZGVsYXkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncykge1xuICByZXR1cm4gZGVsYXlJbk1zID09PSB2b2lkIDAgPyBQcm9taXNlLnJlc29sdmUoKSA6IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuXG4vLyB1dGlsL3JldHJ5LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9SZXRyeUVycm9yXCI7XG52YXIgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG52YXIgX2E7XG52YXIgUmV0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1JldHJ5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lICYmIHR5cGVvZiBlcnJvci5yZWFzb24gPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShlcnJvci5lcnJvcnMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgcmVhc29uOiB0aGlzLnJlYXNvbixcbiAgICAgIGxhc3RFcnJvcjogdGhpcy5sYXN0RXJyb3IsXG4gICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzXG4gICAgfTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xuXG4vLyB1dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xudmFyIHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMlxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSk7XG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogXCJtYXhSZXRyaWVzRXhjZWVkZWRcIixcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBBUElDYWxsRXJyb3IuaXNBUElDYWxsRXJyb3IoZXJyb3IpICYmIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBhd2FpdCBkZWxheShkZWxheUluTXMpO1xuICAgICAgcmV0dXJuIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGYsXG4gICAgICAgIHsgbWF4UmV0cmllcywgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLCBiYWNrb2ZmRmFjdG9yIH0sXG4gICAgICAgIG5ld0Vycm9yc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRyeU51bWJlciA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiBcImVycm9yTm90UmV0cnlhYmxlXCIsXG4gICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2Fzc2VtYmxlLW9wZXJhdGlvbi1uYW1lLnRzXG5mdW5jdGlvbiBhc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICBvcGVyYXRpb25JZCxcbiAgdGVsZW1ldHJ5XG59KSB7XG4gIHJldHVybiB7XG4gICAgLy8gc3RhbmRhcmRpemVkIG9wZXJhdGlvbiBhbmQgcmVzb3VyY2UgbmFtZTpcbiAgICBcIm9wZXJhdGlvbi5uYW1lXCI6IGAke29wZXJhdGlvbklkfSR7KHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQpICE9IG51bGwgPyBgICR7dGVsZW1ldHJ5LmZ1bmN0aW9uSWR9YCA6IFwiXCJ9YCxcbiAgICBcInJlc291cmNlLm5hbWVcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCxcbiAgICAvLyBkZXRhaWxlZCwgQUkgU0RLIHNwZWNpZmljIGRhdGE6XG4gICAgXCJhaS5vcGVyYXRpb25JZFwiOiBvcGVyYXRpb25JZCxcbiAgICBcImFpLnRlbGVtZXRyeS5mdW5jdGlvbklkXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWRcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTE7XG4gIHJldHVybiB7XG4gICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgLy8gc2V0dGluZ3M6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBhdHRyaWJ1dGVzW2BhaS5zZXR0aW5ncy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pLFxuICAgIC8vIGFkZCBtZXRhZGF0YSBhcyBhdHRyaWJ1dGVzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKChfYTExID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkubWV0YWRhdGEpICE9IG51bGwgPyBfYTExIDoge30pLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkudGVsZW1ldHJ5Lm1ldGFkYXRhLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyByZXF1ZXN0IGhlYWRlcnNcbiAgICAuLi5PYmplY3QuZW50cmllcyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5yZXF1ZXN0LmhlYWRlcnMuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcblxuLy8gY29yZS90ZWxlbWV0cnkvbm9vcC10cmFjZXIudHNcbnZhciBub29wVHJhY2VyID0ge1xuICBzdGFydFNwYW4oKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuO1xuICB9LFxuICBzdGFydEFjdGl2ZVNwYW4obmFtZTExLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcxKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcyKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmczKG5vb3BTcGFuKTtcbiAgICB9XG4gIH1cbn07XG52YXIgbm9vcFNwYW4gPSB7XG4gIHNwYW5Db250ZXh0KCkge1xuICAgIHJldHVybiBub29wU3BhbkNvbnRleHQ7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmtzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHVwZGF0ZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaXNSZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICByZWNvcmRFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgbm9vcFNwYW5Db250ZXh0ID0ge1xuICB0cmFjZUlkOiBcIlwiLFxuICBzcGFuSWQ6IFwiXCIsXG4gIHRyYWNlRmxhZ3M6IDBcbn07XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbnZhciB0ZXN0VHJhY2VyID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0VHJhY2VyKHsgaXNFbmFibGVkIH0pIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbm9vcFRyYWNlcjtcbiAgfVxuICBpZiAodGVzdFRyYWNlcikge1xuICAgIHJldHVybiB0ZXN0VHJhY2VyO1xuICB9XG4gIHJldHVybiB0cmFjZS5nZXRUcmFjZXIoXCJhaVwiKTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvcmVjb3JkLXNwYW4udHNcbmltcG9ydCB7IFNwYW5TdGF0dXNDb2RlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuZnVuY3Rpb24gcmVjb3JkU3Bhbih7XG4gIG5hbWU6IG5hbWUxMSxcbiAgdHJhY2VyLFxuICBhdHRyaWJ1dGVzLFxuICBmbixcbiAgZW5kV2hlbkRvbmUgPSB0cnVlXG59KSB7XG4gIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUxMSwgeyBhdHRyaWJ1dGVzIH0sIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKHNwYW4pO1xuICAgICAgaWYgKGVuZFdoZW5Eb25lKSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L3NlbGVjdC10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIHRlbGVtZXRyeSxcbiAgYXR0cmlidXRlc1xufSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykucmVkdWNlKChhdHRyaWJ1dGVzMiwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImlucHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlucHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkSW5wdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuaW5wdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm91dHB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZE91dHB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5vdXRwdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHZhbHVlIH07XG4gIH0sIHt9KTtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWQoe1xuICBtb2RlbCxcbiAgdmFsdWUsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2ExMSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmlzRW5hYmxlZCkgIT0gbnVsbCA/IF9hMTEgOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgXCJhaS52YWx1ZVwiOiB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHsgZW1iZWRkaW5nLCB1c2FnZSwgcmF3UmVzcG9uc2UgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiAoXG4gICAgICAgICAgLy8gbmVzdGVkIHNwYW5zIHRvIGFsaWduIHdpdGggdGhlIGVtYmVkTWFueSB0ZWxlbWV0cnkgZGF0YTpcbiAgICAgICAgICByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWQuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjogeyBpbnB1dDogKCkgPT4gW0pTT04uc3RyaW5naWZ5KHZhbHVlKV0gfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTI7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFt2YWx1ZV0sXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5nc1swXTtcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTIgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExMiA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nMykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nMylcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVtYmVkZGluZzogZW1iZWRkaW5nMixcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHJhd1Jlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nXCI6IHsgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRSZXN1bHQoeyB2YWx1ZSwgZW1iZWRkaW5nLCB1c2FnZSwgcmF3UmVzcG9uc2UgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmVtYmVkZGluZyA9IG9wdGlvbnMuZW1iZWRkaW5nO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvc3BsaXQtYXJyYXkudHNcbmZ1bmN0aW9uIHNwbGl0QXJyYXkoYXJyYXksIGNodW5rU2l6ZSkge1xuICBpZiAoY2h1bmtTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgcmVzdWx0LnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGNvcmUvZW1iZWQvZW1iZWQtbWFueS50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWRNYW55KHtcbiAgbW9kZWwsXG4gIHZhbHVlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTExID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMSA6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZE1hbnlcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgbWF4RW1iZWRkaW5nc1BlckNhbGwgPSBtb2RlbC5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICAgIGlmIChtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTEyO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MzID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMiA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTEyIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczMubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMywgdXNhZ2U6IHVzYWdlMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7IHZhbHVlcywgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVDaHVua3MgPSBzcGxpdEFycmF5KHZhbHVlcywgbWF4RW1iZWRkaW5nc1BlckNhbGwpO1xuICAgICAgY29uc3QgZW1iZWRkaW5ncyA9IFtdO1xuICAgICAgbGV0IHRva2VucyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHZhbHVlQ2h1bmtzKSB7XG4gICAgICAgIGNvbnN0IHsgZW1iZWRkaW5nczogcmVzcG9uc2VFbWJlZGRpbmdzLCB1c2FnZSB9ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gY2h1bmsubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTEyO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBjaHVuayxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTIgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExMiA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlOiB1c2FnZTIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVtYmVkZGluZ3MucHVzaCguLi5yZXNwb25zZUVtYmVkZGluZ3MpO1xuICAgICAgICB0b2tlbnMgKz0gdXNhZ2UudG9rZW5zO1xuICAgICAgfVxuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoe1xuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIGVtYmVkZGluZ3MsXG4gICAgICAgIHVzYWdlOiB7IHRva2VucyB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZE1hbnlSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IG9wdGlvbnMuZW1iZWRkaW5ncztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciwgc2FmZVBhcnNlSlNPTiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHV0aWwvZG93bmxvYWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBEb3dubG9hZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0Rvd25sb2FkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMiAmJiB0eXBlb2YgZXJyb3IudXJsID09PSBcInN0cmluZ1wiICYmIChlcnJvci5zdGF0dXNDb2RlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c0NvZGUgPT09IFwibnVtYmVyXCIpICYmIChlcnJvci5zdGF0dXNUZXh0ID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlXG4gICAgfTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHV0aWwvZG93bmxvYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHtcbiAgdXJsLFxuICBmZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2hcbn0pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbGVtZW50YXRpb24odXJsVGV4dCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1pbWVUeXBlOiAoX2ExMSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPSBudWxsID8gX2ExMSA6IHZvaWQgMFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7IHVybDogdXJsVGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHNcbnZhciBtaW1lVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvZ2lmXCIsIGJ5dGVzOiBbNzEsIDczLCA3MF0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIiwgYnl0ZXM6IFsxMzcsIDgwLCA3OCwgNzFdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvanBlZ1wiLCBieXRlczogWzI1NSwgMjE2XSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3dlYnBcIiwgYnl0ZXM6IFs4MiwgNzMsIDcwLCA3MF0gfVxuXTtcbmZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2UpIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKSkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgSW52YWxpZERhdGFDb250ZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWREYXRhQ29udGVudEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTMgJiYgZXJyb3IuY29udGVudCAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgIH07XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG52YXIgZGF0YUNvbnRlbnRTY2hlbWEgPSB6LnVuaW9uKFtcbiAgei5zdHJpbmcoKSxcbiAgei5pbnN0YW5jZW9mKFVpbnQ4QXJyYXkpLFxuICB6Lmluc3RhbmNlb2YoQXJyYXlCdWZmZXIpLFxuICB6LmN1c3RvbShcbiAgICAvLyBCdWZmZXIgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBzb21lIGVudmlyb25tZW50cyBzdWNoIGFzIENsb3VkRmxhcmU6XG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX2ExMSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hMTEgPSBnbG9iYWxUaGlzLkJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuaXNCdWZmZXIodmFsdWUpKSAhPSBudWxsID8gX2IgOiBmYWxzZTtcbiAgICB9LFxuICAgIHsgbWVzc2FnZTogXCJNdXN0IGJlIGEgQnVmZmVyXCIgfVxuICApXG5dKTtcbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KHVpbnQ4QXJyYXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGRlY29kaW5nIFVpbnQ4QXJyYXkgdG8gdGV4dFwiKTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMucm9sZSA9IHJvbGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU0ICYmIHR5cGVvZiBlcnJvci5yb2xlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICByb2xlOiB0aGlzLnJvbGVcbiAgICB9O1xuICB9XG59O1xuX2E0ID0gc3ltYm9sNDtcblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPSB0cnVlLFxuICBkb3dubG9hZEltcGxlbWVudGF0aW9uID0gZG93bmxvYWRcbn0pIHtcbiAgY29uc3QgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzID0gW107XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgfHwgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwgPyBudWxsIDogYXdhaXQgZG93bmxvYWRJbWFnZXMocHJvbXB0Lm1lc3NhZ2VzLCBkb3dubG9hZEltcGxlbWVudGF0aW9uKTtcbiAgY29uc3QgcHJvbXB0VHlwZSA9IHByb21wdC50eXBlO1xuICBzd2l0Y2ggKHByb21wdFR5cGUpIHtcbiAgICBjYXNlIFwicHJvbXB0XCI6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBwcm9tcHQucHJvbXB0IH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibWVzc2FnZXNcIjoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoXG4gICAgICAgICAgKG1lc3NhZ2UpID0+IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRJbWFnZXMpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHByb21wdFR5cGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByb21wdCB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkSW1hZ2VzKSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICB2YXIgX2ExMSwgX2IsIF9jO1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkZWRJbWFnZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFydC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkZWRJbWFnZSA9IGRvd25sb2FkZWRJbWFnZXNbcGFydC5pbWFnZS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGRvd25sb2FkZWRJbWFnZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9hMTEgPSBwYXJ0Lm1pbWVUeXBlKSAhPSBudWxsID8gX2ExMSA6IGRvd25sb2FkZWRJbWFnZS5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LmltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocGFydC5pbWFnZSk7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzOlwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkZWRJbWFnZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRlZEltYWdlID0gZG93bmxvYWRlZEltYWdlc1twYXJ0LmltYWdlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGRvd25sb2FkZWRJbWFnZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9iID0gcGFydC5taW1lVHlwZSkgIT0gbnVsbCA/IF9iIDogZG93bmxvYWRlZEltYWdlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IHBhcnQuaW1hZ2Uuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7Z2V0RXJyb3JNZXNzYWdlMihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWBcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoX2lnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgaW1hZ2VVaW50OCA9IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShwYXJ0LmltYWdlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVWludDgsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IChfYyA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYyA6IGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2VVaW50OCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0czpcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCJcbiAgICAgICAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLCAuLi5yZXN0IH0gPSBwYXJ0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEltYWdlcyhtZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbikge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgPT09IFwidXNlclwiKS5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudCkuZmlsdGVyKFxuICAgIChjb250ZW50KSA9PiBBcnJheS5pc0FycmF5KGNvbnRlbnQpXG4gICkuZmxhdCgpLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIpLm1hcCgocGFydCkgPT4gcGFydC5pbWFnZSkubWFwKFxuICAgIChwYXJ0KSA9PiAoXG4gICAgICAvLyBzdXBwb3J0IHN0cmluZyB1cmxzIGluIGltYWdlIHBhcnRzOlxuICAgICAgdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIgJiYgKHBhcnQuc3RhcnRzV2l0aChcImh0dHA6XCIpIHx8IHBhcnQuc3RhcnRzV2l0aChcImh0dHBzOlwiKSkgPyBuZXcgVVJMKHBhcnQpIDogcGFydFxuICAgIClcbiAgKS5maWx0ZXIoKGltYWdlKSA9PiBpbWFnZSBpbnN0YW5jZW9mIFVSTCk7XG4gIGNvbnN0IGRvd25sb2FkZWRJbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB1cmxzLm1hcChhc3luYyAodXJsKSA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YTogYXdhaXQgZG93bmxvYWRJbXBsZW1lbnRhdGlvbih7IHVybCB9KVxuICAgIH0pKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRJbWFnZXMubWFwKCh7IHVybCwgZGF0YSB9KSA9PiBbdXJsLnRvU3RyaW5nKCksIGRhdGFdKVxuICApO1xufVxuXG4vLyBlcnJvcnMvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyYW1ldGVyLFxuICAgIHZhbHVlLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU1LFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gXG4gICAgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkQXJndW1lbnRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIHR5cGVvZiBlcnJvci5wYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnZhbHVlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwYXJhbWV0ZXI6IHRoaXMucGFyYW1ldGVyLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzdG9wU2VxdWVuY2VzLFxuICBzZWVkLFxuICBtYXhSZXRyaWVzXG59KSB7XG4gIGlmIChtYXhUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczogc3RvcFNlcXVlbmNlcyAhPSBudWxsICYmIHN0b3BTZXF1ZW5jZXMubGVuZ3RoID4gMCA/IHN0b3BTZXF1ZW5jZXMgOiB2b2lkIDAsXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMlxuICB9O1xufVxuXG4vLyBjb3JlL3Byb21wdC92YWxpZGF0ZS1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlVmFsaWRhdGVUeXBlcyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo1IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL2pzb24tdmFsdWUudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG52YXIganNvblZhbHVlU2NoZW1hID0gejIubGF6eShcbiAgKCkgPT4gejIudW5pb24oW1xuICAgIHoyLm51bGwoKSxcbiAgICB6Mi5zdHJpbmcoKSxcbiAgICB6Mi5udW1iZXIoKSxcbiAgICB6Mi5ib29sZWFuKCksXG4gICAgejIucmVjb3JkKHoyLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbnZhciBwcm92aWRlck1ldGFkYXRhU2NoZW1hID0gejMucmVjb3JkKFxuICB6My5zdHJpbmcoKSxcbiAgejMucmVjb3JkKHozLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kXCI7XG52YXIgdGV4dFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejQuc3RyaW5nKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGltYWdlUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgaW1hZ2U6IHo0LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejQuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciB0b29sQ2FsbFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidG9vbC1jYWxsXCIpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo0LnN0cmluZygpLFxuICBhcmdzOiB6NC51bmtub3duKClcbn0pO1xudmFyIHRvb2xSZXN1bHRQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtcmVzdWx0XCIpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo0LnN0cmluZygpLFxuICByZXN1bHQ6IHo0LnVua25vd24oKSxcbiAgaXNFcnJvcjogejQuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG52YXIgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwic3lzdGVtXCIpLFxuICBjb250ZW50OiB6NS5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVVzZXJNZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgcm9sZTogejUubGl0ZXJhbChcInVzZXJcIiksXG4gIGNvbnRlbnQ6IHo1LnVuaW9uKFtcbiAgICB6NS5zdHJpbmcoKSxcbiAgICB6NS5hcnJheSh6NS51bmlvbihbdGV4dFBhcnRTY2hlbWEsIGltYWdlUGFydFNjaGVtYV0pKVxuICBdKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoejUudW5pb24oW3RleHRQYXJ0U2NoZW1hLCB0b29sQ2FsbFBhcnRTY2hlbWFdKSlcbiAgXSksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVUb29sTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ0b29sXCIpLFxuICBjb250ZW50OiB6NS5hcnJheSh0b29sUmVzdWx0UGFydFNjaGVtYSksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVNZXNzYWdlU2NoZW1hID0gejUudW5pb24oW1xuICBjb3JlU3lzdGVtTWVzc2FnZVNjaGVtYSxcbiAgY29yZVVzZXJNZXNzYWdlU2NoZW1hLFxuICBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYSxcbiAgY29yZVRvb2xNZXNzYWdlU2NoZW1hXG5dKTtcblxuLy8gY29yZS9wcm9tcHQvdmFsaWRhdGUtcHJvbXB0LnRzXG5mdW5jdGlvbiB2YWxpZGF0ZVByb21wdChwcm9tcHQpIHtcbiAgaWYgKHByb21wdC5wcm9tcHQgPT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZVwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnN5c3RlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJzeXN0ZW0gbXVzdCBiZSBhIHN0cmluZ1wiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJvbXB0LnByb21wdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogXCJwcm9tcHQgbXVzdCBiZSBhIHN0cmluZ1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHJvbXB0XCIsXG4gICAgICBwcm9tcHQ6IHByb21wdC5wcm9tcHQsXG4gICAgICBtZXNzYWdlczogdm9pZCAwLFxuICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gICAgfTtcbiAgfVxuICBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgICAgdmFsdWU6IHByb21wdC5tZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogejYuYXJyYXkoY29yZU1lc3NhZ2VTY2hlbWEpXG4gICAgfSk7XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZVwiLFxuICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1lc3NhZ2VzXCIsXG4gICAgICBwcm9tcHQ6IHZvaWQgMCxcbiAgICAgIG1lc3NhZ2VzOiBwcm9tcHQubWVzc2FnZXMsXG4gICAgICAvLyBvbmx5IHBvc3NpYmxlIGNhc2UgYmMgb2YgY2hlY2tzIGFib3ZlXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xufVxuXG4vLyBjb3JlL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyB1c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgIT0gbnVsbCA/IF9hMTEgOiB7fSk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzLnNldChcIlgtVmVyY2VsLUFJLURhdGEtU3RyZWFtXCIsIGRhdGFTdHJlYW1WZXJzaW9uKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24taW5zdHJ1Y3Rpb24udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xudmFyIERFRkFVTFRfR0VORVJJQ19TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIEpTT04uXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICBwcm9tcHQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9QUkVGSVggOiB2b2lkIDAsXG4gIHNjaGVtYVN1ZmZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfU1VGRklYIDogREVGQVVMVF9HRU5FUklDX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gcHJvbXB0IDogdm9pZCAwLFxuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gXCJcIiA6IHZvaWQgMCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHByb21wdCBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHNjaGVtYSkgOiB2b2lkIDAsXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L25vLW9iamVjdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjYgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU2ID0gXCJBSV9Ob09iamVjdEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBOb09iamVjdEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNiB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIk5vIG9iamVjdCBnZW5lcmF0ZWQuXCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNOb09iamVjdEdlbmVyYXRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTY7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlLCB0cmFuc2Zvcm1lcikge1xuICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKVxuICApO1xuICB0cmFuc2Zvcm1lZFN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gdHJhbnNmb3JtZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH0gOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1lZFN0cmVhbTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG52YXIgbm9TY2hlbWFPdXRwdXRTdHJhdGVneSA9IHtcbiAgdHlwZTogXCJuby1zY2hlbWFcIixcbiAganNvblNjaGVtYTogdm9pZCAwLFxuICB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogeyBwYXJ0aWFsOiB2YWx1ZSwgdGV4dERlbHRhIH0gfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCkgfSA6IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gbm8tc2NoZW1hIG1vZGVcIlxuICAgIH0pO1xuICB9XG59O1xudmFyIG9iamVjdE91dHB1dFN0cmF0ZWd5ID0gKHNjaGVtYSkgPT4gKHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAganNvblNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWEsXG4gIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICBwYXJ0aWFsOiB2YWx1ZSxcbiAgICAgICAgdGV4dERlbHRhXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBvYmplY3QgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn0pO1xudmFyIGFycmF5T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiB7XG4gIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0gc2NoZW1hLmpzb25TY2hlbWE7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyBhcnJheSBvZiBlbGVtZW50cywgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBhcnJheSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgYXJyYXlzIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgZ3JhbW1hci1ndWlkZWQgZ2VuZXJhdGlvblxuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBlbGVtZW50czogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiBpdGVtU2NoZW1hIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wiZWxlbWVudHNcIl0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCBsYXRlc3RPYmplY3QsIGlzRmlyc3REZWx0YSwgaXNGaW5hbERlbHRhIH0pIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgY29uc3QgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKGkgPT09IGlucHV0QXJyYXkubGVuZ3RoIC0gMSAmJiAhaXNGaW5hbERlbHRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGlzaGVkRWxlbWVudENvdW50ID0gKF9hMTEgPSBsYXRlc3RPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdE9iamVjdC5sZW5ndGgpICE9IG51bGwgPyBfYTExIDogMDtcbiAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgaWYgKGlzRmlyc3REZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJbXCI7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaGVkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCIsXCI7XG4gICAgICB9XG4gICAgICB0ZXh0RGVsdGEgKz0gcmVzdWx0QXJyYXkuc2xpY2UocHVibGlzaGVkRWxlbWVudENvdW50KS5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLFwiKTtcbiAgICAgIGlmIChpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiByZXN1bHRBcnJheSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBlbGVtZW50c1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSB2YWx1ZS5lbGVtZW50cztcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpbnB1dEFycmF5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlOiBlbGVtZW50LCBzY2hlbWEgfSk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogaW5wdXRBcnJheSB9O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbShvcmlnaW5hbFN0cmVhbSkge1xuICAgICAgbGV0IHB1Ymxpc2hlZEVsZW1lbnRzID0gMDtcbiAgICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKG9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gY2h1bmsub2JqZWN0O1xuICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheS5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXJyYXlbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW51bU91dHB1dFN0cmF0ZWd5ID0gKGVudW1WYWx1ZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJlc3VsdCwgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBlbnVtIHZhbHVlIGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBlbnVtcyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIHRvcC1sZXZlbCBlbnVtc1xuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwicGFydGlhbCByZXN1bHRzIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgc3dpdGNoIChvdXRwdXQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gb2JqZWN0T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWEoc2NoZW1hKSk7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYXJyYXlPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvdmFsaWRhdGUtb2JqZWN0LWdlbmVyYXRpb24taW5wdXQudHNcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgb3V0cHV0LFxuICBtb2RlLFxuICBzY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIGlmIChvdXRwdXQgIT0gbnVsbCAmJiBvdXRwdXQgIT09IFwib2JqZWN0XCIgJiYgb3V0cHV0ICE9PSBcImFycmF5XCIgJiYgb3V0cHV0ICE9PSBcImVudW1cIiAmJiBvdXRwdXQgIT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm91dHB1dFwiLFxuICAgICAgdmFsdWU6IG91dHB1dCxcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBvdXRwdXQgdHlwZS5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChvdXRwdXQgPT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtb2RlXCIsXG4gICAgICAgIHZhbHVlOiBtb2RlLFxuICAgICAgICBtZXNzYWdlOiAnTW9kZSBtdXN0IGJlIFwianNvblwiIGZvciBuby1zY2hlbWEgb3V0cHV0LidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyByZXF1aXJlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiRWxlbWVudCBzY2hlbWEgaXMgcmVxdWlyZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImVudW1cIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIHJlcXVpcmVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZW51bVZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKHsgcHJlZml4OiBcImFpb2JqLVwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHtcbiAgbW9kZWwsXG4gIGVudW06IGVudW1WYWx1ZXMsXG4gIC8vIHJlbmFtZSBiYyBlbnVtIGlzIHJlc2VydmVkIGJ5IHR5cGVzY3JpcHRcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIG1vZGUsXG4gIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkLFxuICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2ExMTtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBtb2RlLFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2ExMSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmlzRW5hYmxlZCkgIT0gbnVsbCA/IF9hMTEgOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgIFwiYWkuc2NoZW1hLmRlc2NyaXB0aW9uXCI6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlLFxuICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgbGV0IHVzYWdlO1xuICAgICAgbGV0IHdhcm5pbmdzO1xuICAgICAgbGV0IHJhd1Jlc3BvbnNlO1xuICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgbGV0IGxvZ3Byb2JzO1xuICAgICAgbGV0IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IHZhbGlkYXRlUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSA9PSBudWxsID8gaW5qZWN0SnNvbkluc3RydWN0aW9uKHsgcHJvbXB0OiBzeXN0ZW0gfSkgOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gc3lzdGVtIDogaW5qZWN0SnNvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICAgICAgcHJvbXB0OiBzeXN0ZW0sXG4gICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaW5wdXRGb3JtYXQgPSB2YWxpZGF0ZWRQcm9tcHQudHlwZTtcbiAgICAgICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTEyLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC1qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIudGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9iID0gKF9hMTIgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi5pZCkgIT0gbnVsbCA/IF9iIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kID0gKF9jID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfZiA9IChfZSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5tb2RlbElkKSAhPSBudWxsID8gX2YgOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiByZXN1bHQyLnRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiByZXN1bHQyLnRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UucHJvbXB0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdDIsIG9iamVjdFRleHQ6IHJlc3VsdDIudGV4dCwgcmVzcG9uc2VEYXRhIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC5vYmplY3RUZXh0O1xuICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgICAgIHJlc3VsdFByb3ZpZGVyTWV0YWRhdGEgPSBnZW5lcmF0ZVJlc3VsdC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSB2YWxpZGF0ZVByb21wdCh7XG4gICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaW5wdXRGb3JtYXQgPSB2YWxpZGF0ZWRQcm9tcHQudHlwZTtcbiAgICAgICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTEyLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lICE9IG51bGwgPyBzY2hlbWFOYW1lIDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0VGV4dCA9IChfYiA9IChfYTEyID0gcmVzdWx0Mi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXJncztcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0VGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9kID0gKF9jID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmlkKSAhPSBudWxsID8gX2QgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2YgPSAoX2UgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UudGltZXN0YW1wKSAhPSBudWxsID8gX2YgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9oID0gKF9nID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1vZGVsSWQpICE9IG51bGwgPyBfaCA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IG9iamVjdFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiBvYmplY3RUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQyLmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dCwgcmVzcG9uc2VEYXRhIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC5vYmplY3RUZXh0O1xuICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgICAgIHJlc3VsdFByb3ZpZGVyTWV0YWRhdGEgPSBnZW5lcmF0ZVJlc3VsdC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IHJlc3VsdCB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBwYXJzZVJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZUZpbmFsUmVzdWx0KFxuICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZVxuICAgICAgKTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsaWRhdGlvblJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbGlkYXRpb25SZXN1bHQudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgb2JqZWN0OiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0ge1xuICAgICAgaGVhZGVyczogb3B0aW9ucy5yZXNwb25zZS5oZWFkZXJzXG4gICAgfTtcbiAgICB0aGlzLmxvZ3Byb2JzID0gb3B0aW9ucy5sb2dwcm9icztcbiAgfVxuICB0b0pzb25SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMTE7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh0aGlzLm9iamVjdCksIHtcbiAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU9iamVjdCA9IGdlbmVyYXRlT2JqZWN0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5pbXBvcnQge1xuICBpc0RlZXBFcXVhbERhdGEsXG4gIHBhcnNlUGFydGlhbEpzb25cbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyB1dGlsL2RlbGF5ZWQtcHJvbWlzZS50c1xudmFyIERlbGF5ZWRQcm9taXNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJwZW5kaW5nXCIgfTtcbiAgICB0aGlzLl9yZXNvbHZlID0gdm9pZCAwO1xuICAgIHRoaXMuX3JlamVjdCA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXNvbHZlKHRoaXMuc3RhdHVzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHJlamVjdCh0aGlzLnN0YXR1cy5lcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICB9XG4gIHJlc29sdmUodmFsdWUpIHtcbiAgICB2YXIgX2ExMTtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZXNvbHZlZFwiLCB2YWx1ZSB9O1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIChfYTExID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlamVjdChlcnJvcikge1xuICAgIHZhciBfYTExO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlamVjdGVkXCIsIGVycm9yIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTEgPSB0aGlzLl9yZWplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY29yZS91dGlsL25vdy50c1xuZnVuY3Rpb24gbm93KCkge1xuICB2YXIgX2ExMSwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2ExMSA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLm5vdygpKSAhPSBudWxsID8gX2IgOiBEYXRlLm5vdygpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvcHJlcGFyZS1vdXRnb2luZy1odHRwLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGluaXQsIHtcbiAgY29udGVudFR5cGUsXG4gIGRhdGFTdHJlYW1WZXJzaW9uXG59KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKChpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbml0LmhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBjb250ZW50VHlwZTtcbiAgfVxuICBpZiAoZGF0YVN0cmVhbVZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbXCJYLVZlcmNlbC1BSS1EYXRhLVN0cmVhbVwiXSA9IGRhdGFTdHJlYW1WZXJzaW9uO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBjb3JlL3V0aWwvd3JpdGUtdG8tc2VydmVyLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW1cbn0pIHtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogMjAwLCBzdGF0dXNUZXh0LCBoZWFkZXJzKTtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgfVxuICB9O1xuICByZWFkKCk7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQyID0gY3JlYXRlSWRHZW5lcmF0b3IyKHsgcHJlZml4OiBcImFpb2JqLVwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgb25GaW5pc2gsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMixcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgIG5vdzogbm93MiA9IG5vd1xuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhciBfYTExO1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIG1vZGUsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHsgb3V0cHV0LCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2ExMSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmlzRW5hYmxlZCkgIT0gbnVsbCA/IF9hMTEgOiBmYWxzZSB9KTtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zY2hlbWFcIjogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSAhPSBudWxsID8geyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSkgfSA6IHZvaWQgMCxcbiAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxsT3B0aW9ucztcbiAgICAgIGxldCB0cmFuc2Zvcm1lcjtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gdmFsaWRhdGVQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hID09IG51bGwgPyBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oeyBwcm9tcHQ6IHN5c3RlbSB9KSA6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IHZhbGlkYXRlUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lICE9IG51bGwgPyBzY2hlbWFOYW1lIDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmFyZ3NUZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSB9LFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjYWxsT3B0aW9ucy5pbnB1dEZvcm1hdFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGNhbGxPcHRpb25zLnByb21wdClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMikgPT4gKHtcbiAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oY2FsbE9wdGlvbnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcikpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICByb290U3BhbixcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgIG5vdzogbm93MixcbiAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgb25GaW5pc2gsXG4gICAgcm9vdFNwYW4sXG4gICAgZG9TdHJlYW1TcGFuLFxuICAgIHRlbGVtZXRyeSxcbiAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgIG1vZGVsSWQsXG4gICAgbm93OiBub3cyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgICB0aGlzLm9iamVjdFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVVc2FnZSwgcHJvbWlzZTogdXNhZ2VQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVzcG9uc2UsIHByb21pc2U6IHJlc3BvbnNlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVQcm92aWRlck1ldGFkYXRhLFxuICAgICAgcHJvbWlzZTogcHJvdmlkZXJNZXRhZGF0YVByb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YVByb21pc2U7XG4gICAgbGV0IHVzYWdlO1xuICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgbGV0IG9iamVjdDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgaWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICBtb2RlbElkXG4gICAgfTtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0SnNvbiA9IHZvaWQgMDtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgIGxldCBpc0ZpcnN0RGVsdGEgPSB0cnVlO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYztcbiAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLCBzdGF0ZTogcGFyc2VTdGF0ZSB9ID0gcGFyc2VQYXJ0aWFsSnNvbihhY2N1bXVsYXRlZFRleHQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRPYmplY3RKc29uICE9PSB2b2lkIDAgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3RKc29uLCBjdXJyZW50T2JqZWN0SnNvbikpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLFxuICAgICAgICAgICAgICAgIHRleHREZWx0YSxcbiAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgICAgICAgICAgIGlzRmluYWxEZWx0YTogcGFyc2VTdGF0ZSA9PT0gXCJzdWNjZXNzZnVsLXBhcnNlXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3QsIHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbCkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3RKc29uID0gY3VycmVudE9iamVjdEpzb247XG4gICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUudGV4dERlbHRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpc0ZpcnN0RGVsdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2ExMSA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExMSA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiByZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jIDogcmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICBpZiAodGV4dERlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHREZWx0YSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgIHVzYWdlID0gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKTtcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IC4uLmNodW5rLCB1c2FnZSwgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgIHJlc29sdmVVc2FnZSh1c2FnZSk7XG4gICAgICAgICAgICAgIHJlc29sdmVQcm92aWRlck1ldGFkYXRhKHByb3ZpZGVyTWV0YWRhdGEpO1xuICAgICAgICAgICAgICByZXNvbHZlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVGaW5hbFJlc3VsdChsYXRlc3RPYmplY3RKc29uKTtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlc29sdmUob2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpIH0sXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiBmaW5hbFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGdldCBvYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLm9iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZWxlbWVudFN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRTdHJhdGVneS5jcmVhdGVFbGVtZW50U3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0pO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSksXG4gICAgICBzdHJlYW06IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMTE7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgICBzdGF0dXM6IChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfc3RyZWFtT2JqZWN0ID0gc3RyZWFtT2JqZWN0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gZXJyb3JzL2luZGV4LnRzXG5pbXBvcnQge1xuICBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMCxcbiAgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gZXJyb3JzL2ludmFsaWQtdG9vbC1hcmd1bWVudHMtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNyA9IFwiQUlfSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbEFyZ3MsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UzKFxuICAgICAgY2F1c2VcbiAgICApfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50b29sQXJncyA9IHRvb2xBcmdzO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjcpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNyAmJiB0eXBlb2YgZXJyb3IudG9vbE5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnRvb2xBcmdzID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRoaXMudG9vbEFyZ3NcbiAgICB9O1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gZXJyb3JzL25vLXN1Y2gtdG9vbC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTggPSBcIkFJX05vU3VjaFRvb2xFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTm9TdWNoVG9vbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sTmFtZSxcbiAgICBhdmFpbGFibGVUb29scyA9IHZvaWQgMCxcbiAgICBtZXNzYWdlID0gYE1vZGVsIHRyaWVkIHRvIGNhbGwgdW5hdmFpbGFibGUgdG9vbCAnJHt0b29sTmFtZX0nLiAke2F2YWlsYWJsZVRvb2xzID09PSB2b2lkIDAgPyBcIk5vIHRvb2xzIGFyZSBhdmFpbGFibGUuXCIgOiBgQXZhaWxhYmxlIHRvb2xzOiAke2F2YWlsYWJsZVRvb2xzLmpvaW4oXCIsIFwiKX0uYH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICAgIHRoaXMuYXZhaWxhYmxlVG9vbHMgPSBhdmFpbGFibGVUb29scztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaFRvb2xFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU4ICYmIFwidG9vbE5hbWVcIiBpbiBlcnJvciAmJiBlcnJvci50b29sTmFtZSAhPSB2b2lkIDAgJiYgdHlwZW9mIGVycm9yLm5hbWUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IHRoaXMuYXZhaWxhYmxlVG9vbHNcbiAgICB9O1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS1jb252ZXJzaW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOSA9IFwiQUlfTWVzc2FnZUNvbnZlcnNpb25FcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTl9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG52YXIgTWVzc2FnZUNvbnZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3JpZ2luYWxNZXNzYWdlLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjkpO1xuICB9XG59O1xuX2E5ID0gc3ltYm9sOTtcblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hMiB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPiAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sczogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUxMSwgdG9vbDJdKSA9PiAoe1xuICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgZGVzY3JpcHRpb246IHRvb2wyLmRlc2NyaXB0aW9uLFxuICAgICAgcGFyYW1ldGVyczogYXNTY2hlbWEyKHRvb2wyLnBhcmFtZXRlcnMpLmpzb25TY2hlbWFcbiAgICB9KSksXG4gICAgdG9vbENob2ljZTogdG9vbENob2ljZSA9PSBudWxsID8geyB0eXBlOiBcImF1dG9cIiB9IDogdHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfSA6IHsgdHlwZTogXCJ0b29sXCIsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3RvLXJlc3BvbnNlLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICB0ZXh0ID0gXCJcIixcbiAgdG9vbENhbGxzLFxuICB0b29sUmVzdWx0c1xufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dCB9LCAuLi50b29sQ2FsbHNdXG4gIH0pO1xuICBpZiAodG9vbFJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgIGNvbnRlbnQ6IHRvb2xSZXN1bHRzLm1hcCgocmVzdWx0KSA9PiAoe1xuICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgIHRvb2xDYWxsSWQ6IHJlc3VsdC50b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZTogcmVzdWx0LnRvb2xOYW1lLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdC5yZXN1bHRcbiAgICAgIH0pKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXNwb25zZU1lc3NhZ2VzO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvdG9vbC1jYWxsLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hMyB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xOYW1lID0gdG9vbENhbGwudG9vbE5hbWU7XG4gIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSB9KTtcbiAgfVxuICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04yKHtcbiAgICB0ZXh0OiB0b29sQ2FsbC5hcmdzLFxuICAgIHNjaGVtYTogYXNTY2hlbWEzKHRvb2wyLnBhcmFtZXRlcnMpXG4gIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICB0b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWUsXG4gICAgYXJnczogcGFyc2VSZXN1bHQudmFsdWVcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQzID0gY3JlYXRlSWRHZW5lcmF0b3IzKHsgcHJlZml4OiBcImFpdHh0LVwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgbWF4QXV0b21hdGljUm91bmR0cmlwcyA9IDAsXG4gIG1heFRvb2xSb3VuZHRyaXBzID0gbWF4QXV0b21hdGljUm91bmR0cmlwcyxcbiAgbWF4U3RlcHMgPSBtYXhUb29sUm91bmR0cmlwcyAhPSBudWxsID8gbWF4VG9vbFJvdW5kdHJpcHMgKyAxIDogMSxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgX2ludGVybmFsOiB7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2ExMTtcbiAgaWYgKG1heFN0ZXBzIDwgMSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwibWF4U3RlcHNcIixcbiAgICAgIHZhbHVlOiBtYXhTdGVwcyxcbiAgICAgIG1lc3NhZ2U6IFwibWF4U3RlcHMgbXVzdCBiZSBhdCBsZWFzdCAxXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTExID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMSA6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tYXhTdGVwc1wiOiBtYXhTdGVwc1xuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIHZhciBfYTEyLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IHZhbGlkYXRlUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vZGUgPSB7XG4gICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSlcbiAgICAgIH07XG4gICAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgfSk7XG4gICAgICBsZXQgY3VycmVudE1vZGVsUmVzcG9uc2U7XG4gICAgICBsZXQgY3VycmVudFRvb2xDYWxscyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRUb29sUmVzdWx0cyA9IFtdO1xuICAgICAgbGV0IHN0ZXBDb3VudCA9IDA7XG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgY29uc3QgdXNhZ2UgPSB7XG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHByb21wdFRva2VuczogMCxcbiAgICAgICAgdG90YWxUb2tlbnM6IDBcbiAgICAgIH07XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbnB1dEZvcm1hdCA9IHN0ZXBDb3VudCA9PT0gMCA/IHZhbGlkYXRlZFByb21wdC50eXBlIDogXCJtZXNzYWdlc1wiO1xuICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHsgaW5wdXQ6ICgpID0+IGN1cnJlbnRJbnB1dEZvcm1hdCB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBzZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTMsIF9iMiwgX2MyLCBfZDIsIF9lMiwgX2Y7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgLi4uY2FsbFNldHRpbmdzLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBjdXJyZW50SW5wdXRGb3JtYXQsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9iMiA9IChfYTEzID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMy5pZCkgIT0gbnVsbCA/IF9iMiA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QyID0gKF9jMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi50aW1lc3RhbXApICE9IG51bGwgPyBfZDIgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfZiA9IChfZTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZTIubW9kZWxJZCkgIT0gbnVsbCA/IF9mIDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gcmVzdWx0LnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnRvb2xDYWxscylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJlc3VsdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShyZXN1bHQudG9vbENhbGxzKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbENhbGxzID0gKChfYTEyID0gY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKSAhPSBudWxsID8gX2ExMiA6IFtdKS5tYXAoXG4gICAgICAgICAgKG1vZGVsVG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoeyB0b29sQ2FsbDogbW9kZWxUb29sQ2FsbCwgdG9vbHMgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzID0gdG9vbHMgPT0gbnVsbCA/IFtdIDogYXdhaXQgZXhlY3V0ZVRvb2xzKHtcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VycmVudFVzYWdlID0gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKFxuICAgICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlXG4gICAgICAgICk7XG4gICAgICAgIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgKz0gY3VycmVudFVzYWdlLmNvbXBsZXRpb25Ub2tlbnM7XG4gICAgICAgIHVzYWdlLnByb21wdFRva2VucyArPSBjdXJyZW50VXNhZ2UucHJvbXB0VG9rZW5zO1xuICAgICAgICB1c2FnZS50b3RhbFRva2VucyArPSBjdXJyZW50VXNhZ2UudG90YWxUb2tlbnM7XG4gICAgICAgIHN0ZXBzLnB1c2goe1xuICAgICAgICAgIHRleHQ6IChfYiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIsXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IChfYyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaGVhZGVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlTWVzc2FnZXMgPSB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgIHRleHQ6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRleHQsXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCguLi5uZXdSZXNwb25zZU1lc3NhZ2VzKTtcbiAgICAgICAgcHJvbXB0TWVzc2FnZXMucHVzaChcbiAgICAgICAgICAuLi5uZXdSZXNwb25zZU1lc3NhZ2VzLm1hcChcbiAgICAgICAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBudWxsKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICBjdXJyZW50VG9vbFJlc3VsdHMubGVuZ3RoID09PSBjdXJyZW50VG9vbENhbGxzLmxlbmd0aCAmJiAvLyB0aGUgbnVtYmVyIG9mIHN0ZXBzIGlzIGxlc3MgdGhhbiB0aGUgbWF4aW11bTpcbiAgICAgICAgKytzdGVwQ291bnQgPCBtYXhTdGVwc1xuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGEgc3RyaW5nIHNvIHRoYXQgdGhlIGNhbGxlciBkb2Vzbid0IGhhdmUgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZC5cbiAgICAgICAgLy8gSWYgdGhleSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb2RlbCBkaWQgbm90IHJldHVybiBhbnkgdGV4dCxcbiAgICAgICAgLy8gdGhleSBjYW4gY2hlY2sgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nOlxuICAgICAgICB0ZXh0OiAoX2QgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2QgOiBcIlwiLFxuICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgIGhlYWRlcnM6IChfZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgIHN0ZXBzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgY29uc3QgdG9vbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0b29sQ2FsbHMubWFwKGFzeW5jICh0b29sQ2FsbCkgPT4ge1xuICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sQ2FsbC50b29sTmFtZV07XG4gICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leGVjdXRlKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWNvcmRTcGFuKHtcbiAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodG9vbENhbGwuYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICB0cmFjZXIsXG4gICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0MilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICByZXN1bHRcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIHRvb2xSZXN1bHRzLmZpbHRlcihcbiAgICAocmVzdWx0KSA9PiByZXN1bHQgIT0gbnVsbFxuICApO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy50b29sQ2FsbHMgPSBvcHRpb25zLnRvb2xDYWxscztcbiAgICB0aGlzLnRvb2xSZXN1bHRzID0gb3B0aW9ucy50b29sUmVzdWx0cztcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMucmVzcG9uc2VNZXNzYWdlcyA9IG9wdGlvbnMucmVzcG9uc2VNZXNzYWdlcztcbiAgICB0aGlzLnJvdW5kdHJpcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHtcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMucmVzcG9uc2UuaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCA9IGdlbmVyYXRlVGV4dDtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvY3JlYXRlLXN0aXRjaGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCkge1xuICBsZXQgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gIGxldCBjb250cm9sbGVyID0gbnVsbDtcbiAgbGV0IGlzQ2xvc2VkID0gZmFsc2U7XG4gIGNvbnN0IHByb2Nlc3NQdWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpbm5lclN0cmVhbVJlYWRlcnNbMF0ucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF3YWl0IHByb2Nlc3NQdWxsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnNoaWZ0KCk7XG4gICAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IHByb2Nlc3NQdWxsLFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBpbm5lclN0cmVhbVJlYWRlcnMpIHtcbiAgICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRTdHJlYW06IChpbm5lclN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaW5uZXIgc3RyZWFtOiBvdXRlciBzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgfVxuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnB1c2goaW5uZXJTdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgIH0sXG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9tZXJnZS1zdHJlYW1zLnRzXG5mdW5jdGlvbiBtZXJnZVN0cmVhbXMoc3RyZWFtMSwgc3RyZWFtMikge1xuICBjb25zdCByZWFkZXIxID0gc3RyZWFtMS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgcmVhZGVyMiA9IHN0cmVhbTIuZ2V0UmVhZGVyKCk7XG4gIGxldCBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gIGxldCBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gIGxldCBzdHJlYW0xRG9uZSA9IGZhbHNlO1xuICBsZXQgc3RyZWFtMkRvbmUgPSBmYWxzZTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTEoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQxID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDE7XG4gICAgICBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTIoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQyID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDI7XG4gICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RyZWFtMURvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMihjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbTJEb25lKSB7XG4gICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTEoY29udHJvbGxlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHJlYWRlcjEucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHJlYWRlcjIucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCByZWFkZXIgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgbGFzdFJlYWQxLnRoZW4oKHJlc3VsdDIpID0+ICh7IHJlc3VsdDogcmVzdWx0MiwgcmVhZGVyOiByZWFkZXIxIH0pKSxcbiAgICAgICAgICBsYXN0UmVhZDIudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjIgfSkpXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRlciA9PT0gcmVhZGVyMSkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgc3RyZWFtMURvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBzdHJlYW0yRG9uZSA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmVhZGVyMS5jYW5jZWwoKTtcbiAgICAgIHJlYWRlcjIuY2FuY2VsKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgdG9vbHMsXG4gIGdlbmVyYXRvclN0cmVhbSxcbiAgdG9vbENhbGxTdHJlYW1pbmcsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5XG59KSB7XG4gIGxldCBjYW5DbG9zZSA9IGZhbHNlO1xuICBjb25zdCBvdXRzdGFuZGluZ1Rvb2xDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICBjb25zdCB0b29sUmVzdWx0c1N0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBhY3RpdmVUb29sQ2FsbHMgPSB7fTtcbiAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtZGVsdGFcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBjaHVuay5hcmdzVGV4dERlbHRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsOiBjaHVuayxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRvb2xDYWxsKTtcbiAgICAgICAgICAgIGlmICh0b29sMi5leGVjdXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvbklkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5hZGQodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjaHVuay5sb2dwcm9icyxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UoY2h1bmsudXNhZ2UpLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgaWYgKG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQ0ID0gY3JlYXRlSWRHZW5lcmF0b3I0KHsgcHJlZml4OiBcImFpdHh0LVwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heFRvb2xSb3VuZHRyaXBzID0gMCxcbiAgbWF4U3RlcHMgPSBtYXhUb29sUm91bmR0cmlwcyAhPSBudWxsID8gbWF4VG9vbFJvdW5kdHJpcHMgKyAxIDogMSxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgZXhwZXJpbWVudGFsX3Rvb2xDYWxsU3RyZWFtaW5nOiB0b29sQ2FsbFN0cmVhbWluZyA9IGZhbHNlLFxuICBvbkNodW5rLFxuICBvbkZpbmlzaCxcbiAgb25TdGVwRmluaXNoLFxuICBfaW50ZXJuYWw6IHtcbiAgICBub3c6IG5vdzIgPSBub3csXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQ0LFxuICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2ExMTtcbiAgaWYgKG1heFN0ZXBzIDwgMSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwibWF4U3RlcHNcIixcbiAgICAgIHZhbHVlOiBtYXhTdGVwcyxcbiAgICAgIG1lc3NhZ2U6IFwibWF4U3RlcHMgbXVzdCBiZSBhdCBsZWFzdCAxXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTExID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2ExMSA6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0U3RlcCA9IGFzeW5jICh7XG4gICAgICAgIHByb21wdE1lc3NhZ2VzOiBwcm9tcHRNZXNzYWdlczIsXG4gICAgICAgIHByb21wdFR5cGVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW06IHN0cmVhbTIsIHdhcm5pbmdzOiB3YXJuaW5nczIsIHJhd1Jlc3BvbnNlOiByYXdSZXNwb25zZTIgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXBNczJcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gcHJvbXB0VHlwZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzMilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBzZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMykgPT4gKHtcbiAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICAvLyBnZXQgYmVmb3JlIHRoZSBjYWxsXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMyxcbiAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBwcm9tcHRUeXBlLFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMyLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgc3RyZWFtOiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5nczIsXG4gICAgICAgICAgICByYXdSZXNwb25zZTogcmF3UmVzcG9uc2UyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXBNczJcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pLFxuICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSB9LFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgIH0gPSBhd2FpdCBzdGFydFN0ZXAoe1xuICAgICAgICBwcm9tcHRUeXBlOiB2YWxpZGF0ZVByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KS50eXBlLFxuICAgICAgICBwcm9tcHRNZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0KHtcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgIG9uQ2h1bmssXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBvblN0ZXBGaW5pc2gsXG4gICAgICAgIHJvb3RTcGFuLFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgc3RhcnRUaW1lc3RhbXBNcyxcbiAgICAgICAgbWF4U3RlcHMsXG4gICAgICAgIHN0YXJ0U3RlcCxcbiAgICAgICAgcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgIG5vdzogbm93MixcbiAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc3RyZWFtLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlLFxuICAgIG9uQ2h1bmssXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIHJvb3RTcGFuLFxuICAgIGRvU3RyZWFtU3BhbixcbiAgICB0ZWxlbWV0cnksXG4gICAgc3RhcnRUaW1lc3RhbXBNcyxcbiAgICBtYXhTdGVwcyxcbiAgICBzdGFydFN0ZXAsXG4gICAgcHJvbXB0TWVzc2FnZXMsXG4gICAgbW9kZWxJZCxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDNcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZUZpbmlzaFJlYXNvbiwgcHJvbWlzZTogZmluaXNoUmVhc29uUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvblByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVGV4dCwgcHJvbWlzZTogdGV4dFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50ZXh0ID0gdGV4dFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVG9vbENhbGxzLCBwcm9taXNlOiB0b29sQ2FsbHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbENhbGxzID0gdG9vbENhbGxzUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUb29sUmVzdWx0cywgcHJvbWlzZTogdG9vbFJlc3VsdHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSB0b29sUmVzdWx0c1Byb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlU3RlcHMsIHByb21pc2U6IHN0ZXBzUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnN0ZXBzID0gc3RlcHNQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVQcm92aWRlck1ldGFkYXRhLFxuICAgICAgcHJvbWlzZTogcHJvdmlkZXJNZXRhZGF0YVByb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVzcG9uc2UsIHByb21pc2U6IHJlc3BvbnNlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0cmVhbTogc3RpdGNoYWJsZVN0cmVhbSxcbiAgICAgIGFkZFN0cmVhbSxcbiAgICAgIGNsb3NlOiBjbG9zZVN0aXRjaGFibGVTdHJlYW1cbiAgICB9ID0gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtO1xuICAgIGNvbnN0IHN0ZXBSZXN1bHRzID0gW107XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gYWRkU3RlcFN0cmVhbSh7XG4gICAgICBzdHJlYW06IHN0cmVhbTIsXG4gICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgcHJvbXB0TWVzc2FnZXM6IHByb21wdE1lc3NhZ2VzMixcbiAgICAgIHVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICB9XG4gICAgfSkge1xuICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IFtdO1xuICAgICAgY29uc3Qgc3RlcFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgc3RlcEZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICAgICAgbGV0IHN0ZXBVc2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfTtcbiAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIGxldCBzdGVwRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICBsZXQgc3RlcFRleHQgPSBcIlwiO1xuICAgICAgbGV0IHN0ZXBMb2dQcm9icztcbiAgICAgIGxldCBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgIG1vZGVsSWRcbiAgICAgIH07XG4gICAgICBhZGRTdHJlYW0oXG4gICAgICAgIHN0cmVhbTIucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYztcbiAgICAgICAgICAgICAgaWYgKHN0ZXBGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBzdGVwRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmssXG4gICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudGV4dERlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBzdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuayB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBzdGVwVG9vbFJlc3VsdHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogKF9hMTEgPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTEgOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MgOiBzdGVwUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgICAgIHN0ZXBVc2FnZSA9IGNodW5rLnVzYWdlO1xuICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgIHN0ZXBQcm92aWRlck1ldGFkYXRhID0gY2h1bmsuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICBzdGVwTG9nUHJvYnMgPSBjaHVuay5sb2dwcm9icztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaW5pc2ggPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmluaXNoXCIpO1xuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmluaXNoXCI6IG1zVG9GaW5pc2gsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuYXZnQ29tcGxldGlvblRva2Vuc1BlclNlY29uZFwiOiAxZTMgKiBzdGVwVXNhZ2UuY29tcGxldGlvblRva2VucyAvIG1zVG9GaW5pc2hcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuayB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHNKc29uID0gc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBzdGVwVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbc3RlcEZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHN0ZXBSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzdGVwVXNhZ2UsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHN0ZXBSZXNwb25zZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc3RlcFJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IHN0ZXBUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHN0ZXBUb29sUmVzdWx0cyxcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICB3YXJuaW5nczogc2VsZi53YXJuaW5ncyxcbiAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBzdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IHNlbGYucmF3UmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3RlcFJlc3VsdHMucHVzaChzdGVwUmVzdWx0KTtcbiAgICAgICAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKHN0ZXBSZXN1bHQpKTtcbiAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRVc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyArIHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogdXNhZ2UuY29tcGxldGlvblRva2VucyArIHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiB1c2FnZS50b3RhbFRva2VucyArIHN0ZXBVc2FnZS50b3RhbFRva2Vuc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICAgICAgICAgIHN0ZXBUb29sUmVzdWx0cy5sZW5ndGggPT09IHN0ZXBUb29sQ2FsbHMubGVuZ3RoICYmIC8vIHRoZSBudW1iZXIgb2Ygc3RlcHMgaXMgbGVzcyB0aGFuIHRoZSBtYXhpbXVtOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwICsgMSA8IG1heFN0ZXBzXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21wdE1lc3NhZ2VzMi5wdXNoKFxuICAgICAgICAgICAgICAgICAgLi4udG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsczogc3RlcFRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHN0ZXBUb29sUmVzdWx0c1xuICAgICAgICAgICAgICAgICAgfSkubWFwKFxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgbnVsbClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMyxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IHN0YXJ0VGltZXN0YW1wMlxuICAgICAgICAgICAgICAgIH0gPSBhd2FpdCBzdGFydFN0ZXAoe1xuICAgICAgICAgICAgICAgICAgcHJvbXB0VHlwZTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgcHJvbXB0TWVzc2FnZXM6IHByb21wdE1lc3NhZ2VzMlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYud2FybmluZ3MgPSByZXN1bHQud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgc2VsZi5yYXdSZXNwb25zZSA9IHJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBhZGRTdGVwU3RyZWFtKHtcbiAgICAgICAgICAgICAgICAgIHN0cmVhbTogcmVzdWx0LnN0cmVhbSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wOiBzdGFydFRpbWVzdGFtcDIsXG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjMsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogY3VycmVudFN0ZXAgKyAxLFxuICAgICAgICAgICAgICAgICAgcHJvbXB0TWVzc2FnZXM6IHByb21wdE1lc3NhZ2VzMixcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZTogc3RlcFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvc2VTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gc3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHN0ZXBUb29sQ2FsbHNKc29uXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjb21iaW5lZFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY29tYmluZWRVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlVXNhZ2UoY29tYmluZWRVc2FnZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUZpbmlzaFJlYXNvbihzdGVwRmluaXNoUmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlVGV4dChzdGVwVGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRvb2xDYWxscyhzdGVwVG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YShzdGVwUHJvdmlkZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRvb2xSZXN1bHRzKHN0ZXBUb29sUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVN0ZXBzKHN0ZXBSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgICAgLy8gVGhlIHRvb2wgcmVzdWx0cyBhcmUgaW5mZXJyZWQgYXMgYSBuZXZlcltdIHR5cGUsIGJlY2F1c2UgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIGFuZCB0aGUgZXhlY3V0ZSBtZXRob2Qgd2l0aCBhbiBpbmZlcnJlZCByZXN1bHQgdHlwZSBpc1xuICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYXMgd2VsbC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gY2FzdCB0aGUgdG9vbFJlc3VsdHMgdG8gYW55LlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIHR5cGUgZXhwb3NlZCB0byB0aGUgdXNlcnMgd2lsbCBiZSBjb3JyZWN0bHkgaW5mZXJyZWQuXG4gICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcFRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBzdGVwczogc3RlcFJlc3VsdHNcbiAgICAgICAgICAgICAgICAgIC8vIHNlZSB0b29sIHJlc3VsdHMgY29tbWVudCBhYm92ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGFkZFN0ZXBTdHJlYW0oe1xuICAgICAgc3RyZWFtLFxuICAgICAgc3RhcnRUaW1lc3RhbXA6IHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICBjdXJyZW50U3RlcDogMCxcbiAgICAgIHByb21wdE1lc3NhZ2VzLFxuICAgICAgdXNhZ2U6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICBTcGxpdCBvdXQgYSBuZXcgc3RyZWFtIGZyb20gdGhlIG9yaWdpbmFsIHN0cmVhbS5cbiAgVGhlIG9yaWdpbmFsIHN0cmVhbSBpcyByZXBsYWNlZCB0byBhbGxvdyBmb3IgZnVydGhlciBzcGxpdHRpbmcsXG4gIHNpbmNlIHdlIGRvIG5vdCBrbm93IGhvdyBtYW55IHRpbWVzIHRoZSBzdHJlYW0gd2lsbCBiZSBzcGxpdC5cbiAgXG4gIE5vdGU6IHRoaXMgbGVhZHMgdG8gYnVmZmVyaW5nIHRoZSBzdHJlYW0gY29udGVudCBvbiB0aGUgc2VydmVyLlxuICBIb3dldmVyLCB0aGUgTExNIHJlc3VsdHMgYXJlIGV4cGVjdGVkIHRvIGJlIHNtYWxsIGVub3VnaCB0byBub3QgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICB0ZWVTdHJlYW0oKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gdGhpcy5vcmlnaW5hbFN0cmVhbS50ZWUoKTtcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RyZWFtMjtcbiAgICByZXR1cm4gc3RyZWFtMTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLnRlZVN0cmVhbSgpLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmsudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLnRlZVN0cmVhbSgpLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0b0FJU3RyZWFtKGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRhU3RyZWFtSW50ZXJuYWwoeyBjYWxsYmFja3MgfSk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtSW50ZXJuYWwoe1xuICAgIGNhbGxiYWNrcyA9IHt9LFxuICAgIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNCA9ICgpID0+IFwiXCIsXG4gICAgLy8gbWFzayBlcnJvciBtZXNzYWdlcyBmb3Igc2FmZXR5IGJ5IGRlZmF1bHRcbiAgICBzZW5kVXNhZ2UgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IGNhbGxiYWNrVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgY29uc3QgdGV4dERlbHRhID0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSB0ZXh0RGVsdGE7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKVxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4odGV4dERlbHRhKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dClcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQodGV4dERlbHRhKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbilcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbClcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIGNodW5rLnRleHREZWx0YSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9jYWxsX2RlbHRhXCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IGNodW5rLmFyZ3NUZXh0RGVsdGFcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGNodW5rLmFyZ3NcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfcmVzdWx0XCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogY2h1bmsucmVzdWx0XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJlcnJvclwiLCBnZXRFcnJvck1lc3NhZ2U0KGNodW5rLmVycm9yKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInN0ZXAtZmluaXNoXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImZpbmlzaF9zdGVwXCIsIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICB1c2FnZTogc2VuZFVzYWdlID8ge1xuICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImZpbmlzaF9tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICB1c2FnZTogc2VuZFVzYWdlID8ge1xuICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChjYWxsYmFja1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChzdHJlYW1QYXJ0c1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG4gIH1cbiAgcGlwZUFJU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCk7XG4gIH1cbiAgcGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiaW5pdFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmluaXQgOiB7XG4gICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogdm9pZCAwLFxuICAgICAgc3RhdHVzOiBcInN0YXR1c1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1c1RleHQ6IFwic3RhdHVzVGV4dFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImRhdGFcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kYXRhIDogdm9pZCAwO1xuICAgIGNvbnN0IGdldEVycm9yTWVzc2FnZTQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImdldEVycm9yTWVzc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmdldEVycm9yTWVzc2FnZSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZW5kVXNhZ2UgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcInNlbmRVc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlbmRVc2FnZSA6IHZvaWQgMDtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXM6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRvRGF0YVN0cmVhbSh7IGRhdGEsIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNCwgc2VuZFVzYWdlIH0pXG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHVzOiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIHRvQUlTdHJlYW1SZXNwb25zZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucyk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICAgIGdldEVycm9yTWVzc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UsXG4gICAgICBzZW5kVXNhZ2U6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VuZFVzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpID8gbWVyZ2VTdHJlYW1zKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YS5zdHJlYW0sIHN0cmVhbSkgOiBzdHJlYW07XG4gIH1cbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucykge1xuICAgIHZhciBfYTExO1xuICAgIGNvbnN0IGluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImluaXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pbml0IDoge1xuICAgICAgaGVhZGVyczogXCJoZWFkZXJzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaGVhZGVycyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1czogXCJzdGF0dXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiB2b2lkIDAsXG4gICAgICBzdGF0dXNUZXh0OiBcInN0YXR1c1RleHRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJkYXRhXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcbiAgICBjb25zdCBnZXRFcnJvck1lc3NhZ2U0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJnZXRFcnJvck1lc3NhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VuZFVzYWdlID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJzZW5kVXNhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zZW5kVXNhZ2UgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIHRoaXMudG9EYXRhU3RyZWFtKHsgZGF0YSwgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U0LCBzZW5kVXNhZ2UgfSksXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExMTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0ID0gc3RyZWFtVGV4dDtcblxuLy8gY29yZS9taWRkbGV3YXJlL3dyYXAtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciBleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogeyB0cmFuc2Zvcm1QYXJhbXMsIHdyYXBHZW5lcmF0ZSwgd3JhcFN0cmVhbSB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSB9KSA6IHBhcmFtcztcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYxXCIsXG4gICAgcHJvdmlkZXI6IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogbW9kZWwubW9kZWxJZCxcbiAgICBkZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU6IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSxcbiAgICBzdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0czogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7IGRvR2VuZXJhdGUsIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9HZW5lcmF0ZSgpO1xuICAgIH0sXG4gICAgYXN5bmMgZG9TdHJlYW0ocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zLCB0eXBlOiBcInN0cmVhbVwiIH0pO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcFN0cmVhbSA/IHdyYXBTdHJlYW0oeyBkb1N0cmVhbSwgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcywgbW9kZWwgfSkgOiBkb1N0cmVhbSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIGNvcmUvcHJvbXB0L2F0dGFjaG1lbnRzLXRvLXBhcnRzLnRzXG5mdW5jdGlvbiBhdHRhY2htZW50c1RvUGFydHMoYXR0YWNobWVudHMpIHtcbiAgdmFyIF9hMTEsIF9iLCBfYztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChhdHRhY2htZW50LnVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICBpZiAoKF9hMTEgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhOlwiOiB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGxldCBiYXNlNjRDb250ZW50O1xuICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBhdHRhY2htZW50LnVybC5zcGxpdChcIixcIik7XG4gICAgICAgICAgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2MgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KFxuICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBjb25zdCB7IHJvbGUsIGNvbnRlbnQsIHRvb2xJbnZvY2F0aW9ucywgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzIH0gPSBtZXNzYWdlO1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzID8gW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cylcbiAgICAgICAgICBdIDogY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucy5tYXAoKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICBjb250ZW50OiB0b29sSW52b2NhdGlvbnMubWFwKChUb29sSW52b2NhdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKCEoXCJyZXN1bHRcIiBpbiBUb29sSW52b2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRvb2xJbnZvY2F0aW9uIG11c3QgaGF2ZSBhIHJlc3VsdDogXCIgKyBKU09OLnN0cmluZ2lmeShUb29sSW52b2NhdGlvbilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBhcmdzLCByZXN1bHQgfSA9IFRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcmVNZXNzYWdlcztcbn1cblxuLy8gY29yZS9yZWdpc3RyeS9jdXN0b20tcHJvdmlkZXIudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyKHtcbiAgbGFuZ3VhZ2VNb2RlbHMsXG4gIHRleHRFbWJlZGRpbmdNb2RlbHMsXG4gIGZhbGxiYWNrUHJvdmlkZXJcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBsYW5ndWFnZU1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChsYW5ndWFnZU1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gbGFuZ3VhZ2VNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICB0ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHRleHRFbWJlZGRpbmdNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHRleHRFbWJlZGRpbmdNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHRleHRFbWJlZGRpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCIgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBjb3JlL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExLCBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaFByb3ZpZGVyRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgTm9TdWNoTW9kZWxFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgcHJvdmlkZXJJZCxcbiAgICBhdmFpbGFibGVQcm92aWRlcnMsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoIHByb3ZpZGVyOiAke3Byb3ZpZGVySWR9IChhdmFpbGFibGUgcHJvdmlkZXJzOiAke2F2YWlsYWJsZVByb3ZpZGVycy5qb2luKCl9KWBcbiAgfSkge1xuICAgIHN1cGVyKHsgZXJyb3JOYW1lOiBuYW1lMTAsIG1vZGVsSWQsIG1vZGVsVHlwZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgIHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzID0gYXZhaWxhYmxlUHJvdmlkZXJzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hQcm92aWRlckVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEwICYmIHR5cGVvZiBlcnJvci5wcm92aWRlcklkID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZXJyb3IuYXZhaWxhYmxlUHJvdmlkZXJzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbW9kZWxUeXBlOiB0aGlzLm1vZGVsVHlwZSxcbiAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgIGF2YWlsYWJsZVByb3ZpZGVyczogdGhpcy5hdmFpbGFibGVQcm92aWRlcnNcbiAgICB9O1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L3Byb3ZpZGVyLXJlZ2lzdHJ5LnRzXG5pbXBvcnQgeyBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5KHByb3ZpZGVycykge1xuICBjb25zdCByZWdpc3RyeSA9IG5ldyBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSgpO1xuICBmb3IgKGNvbnN0IFtpZCwgcHJvdmlkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVycykpIHtcbiAgICByZWdpc3RyeS5yZWdpc3RlclByb3ZpZGVyKHsgaWQsIHByb3ZpZGVyIH0pO1xuICB9XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbnZhciBleHBlcmltZW50YWxfY3JlYXRlTW9kZWxSZWdpc3RyeSA9IGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICB9XG4gIHJlZ2lzdGVyUHJvdmlkZXIoe1xuICAgIGlkLFxuICAgIHByb3ZpZGVyXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVyc1tpZF0gPSBwcm92aWRlcjtcbiAgfVxuICBnZXRQcm92aWRlcihpZCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiLFxuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCwgbW9kZWxUeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKFwiOlwiKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCAke21vZGVsVHlwZX0gaWQgZm9yIHJlZ2lzdHJ5OiAke2lkfSAobXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwicHJvdmlkZXJJZDptb2RlbElkXCIpYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaWQuc2xpY2UoMCwgaW5kZXgpLCBpZC5zbGljZShpbmRleCArIDEpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTEsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJsYW5ndWFnZU1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9iID0gKF9hMTEgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpKS5sYW5ndWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTExLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICB0ZXh0RW1iZWRkaW5nTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExMSwgX2IsIF9jO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9jID0gKF9hMTEgPSBwcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpKSAhPSBudWxsID8gX2MgOiBcInRleHRFbWJlZGRpbmdcIiBpbiBwcm92aWRlciA/IChfYiA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKSA6IHZvaWQgMDtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGB0ZXh0RW1iZWRkaW5nTW9kZWxgIGluc3RlYWQuXG4gICAqL1xuICB0ZXh0RW1iZWRkaW5nKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEVtYmVkZGluZ01vZGVsKGlkKTtcbiAgfVxufTtcblxuLy8gY29yZS90b29sL3Rvb2wudHNcbmZ1bmN0aW9uIHRvb2wodG9vbDIpIHtcbiAgcmV0dXJuIHRvb2wyO1xufVxuXG4vLyBjb3JlL3V0aWwvY29zaW5lLXNpbWlsYXJpdHkudHNcbmZ1bmN0aW9uIGNvc2luZVNpbWlsYXJpdHkodmVjdG9yMSwgdmVjdG9yMikge1xuICBpZiAodmVjdG9yMS5sZW5ndGggIT09IHZlY3RvcjIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFZlY3RvcnMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCAodmVjdG9yMTogJHt2ZWN0b3IxLmxlbmd0aH0gZWxlbWVudHMsIHZlY3RvcjI6ICR7dmVjdG9yMi5sZW5ndGh9IGVsZW1lbnRzKWBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb3RQcm9kdWN0KHZlY3RvcjEsIHZlY3RvcjIpIC8gKG1hZ25pdHVkZSh2ZWN0b3IxKSAqIG1hZ25pdHVkZSh2ZWN0b3IyKSk7XG59XG5mdW5jdGlvbiBkb3RQcm9kdWN0KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgcmV0dXJuIHZlY3RvcjEucmVkdWNlKFxuICAgIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4KSA9PiBhY2N1bXVsYXRvciArIHZhbHVlICogdmVjdG9yMltpbmRleF0sXG4gICAgMFxuICApO1xufVxuZnVuY3Rpb24gbWFnbml0dWRlKHZlY3Rvcikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGRvdFByb2R1Y3QodmVjdG9yLCB2ZWN0b3IpKTtcbn1cblxuLy8gc3RyZWFtcy9haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlclxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBldmVudC5kYXRhID09PSBcIltET05FXVwiIHx8IC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgIGV2ZW50LmV2ZW50ID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgICB9KSA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UuY29udGVudDtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCkpO1xuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IGNvbnRlbnQ7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKGNvbnRlbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQgJiYgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgY29uc3QgaXNPcGVuQUlDYWxsYmFja3MgPSBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmICFpc09wZW5BSUNhbGxiYWNrcykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgcmV0dXJuIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsXCIgaW4gY2FsbGJhY2tzO1xufVxuZnVuY3Rpb24gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKSB7XG4gIGxldCBpc1N0cmVhbVN0YXJ0ID0gdHJ1ZTtcbiAgcmV0dXJuICh0ZXh0KSA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW1TdGFydCgpO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5mdW5jdGlvbiBBSVN0cmVhbShyZXNwb25zZSwgY3VzdG9tUGFyc2VyLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGBSZXNwb25zZSBlcnJvcjogJHtlcnJvclRleHR9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoXCJSZXNwb25zZSBlcnJvcjogTm8gcmVzcG9uc2UgYm9keVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXNwb25zZUJvZHlTdHJlYW0gPSByZXNwb25zZS5ib2R5IHx8IGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTtcbiAgcmV0dXJuIHJlc3BvbnNlQm9keVN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gIGxldCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICB2YXIgX2ExMTtcbiAgICAgIGF3YWl0ICgoX2ExMSA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChpdCwgcmVhc29uKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW0tZGF0YS50c1xuaW1wb3J0IHsgZm9ybWF0U3RyZWFtUGFydCBhcyBmb3JtYXRTdHJlYW1QYXJ0MiB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvY29uc3RhbnRzLnRzXG52YXIgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TID0gMTUgKiAxZTM7XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbnZhciBTdHJlYW1EYXRhMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy53YXJuaW5nVGltZW91dCA9IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgc2VsZi53YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIlRoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgP1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcImRhdGFcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxuICBhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJ0ZXh0XCIsIG1lc3NhZ2UpKSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfU3RyZWFtRGF0YSA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtRGF0YTIge1xufTtcblxuLy8gc3RyZWFtcy9hbnRocm9waWMtc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZUFudGhyb3BpY1N0cmVhbSgpIHtcbiAgbGV0IHByZXZpb3VzID0gXCJcIjtcbiAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgaWYgKFwiZXJyb3JcIiBpbiBqc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7anNvbi5lcnJvci50eXBlfTogJHtqc29uLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGlmICghKFwiY29tcGxldGlvblwiIGluIGpzb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBqc29uLmNvbXBsZXRpb247XG4gICAgaWYgKCFwcmV2aW91cyB8fCB0ZXh0Lmxlbmd0aCA+IHByZXZpb3VzLmxlbmd0aCAmJiB0ZXh0LnN0YXJ0c1dpdGgocHJldmlvdXMpKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHRleHQuc2xpY2UocHJldmlvdXMubGVuZ3RoKTtcbiAgICAgIHByZXZpb3VzID0gdGV4dDtcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJjb21wbGV0aW9uXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay5jb21wbGV0aW9uO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfSBlbHNlIGlmIChcImRlbHRhXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHsgZGVsdGEgfSA9IGNodW5rO1xuICAgICAgaWYgKFwidGV4dFwiIGluIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBkZWx0YS50ZXh0O1xuICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQW50aHJvcGljU3RyZWFtKHJlcywgY2IpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFJU3RyZWFtKHJlcywgcGFyc2VBbnRocm9waWNTdHJlYW0oKSwgY2IpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgICApO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvYXNzaXN0YW50LXJlc3BvbnNlLnRzXG5pbXBvcnQge1xuICBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQzXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBBc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExMTtcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRGF0YU1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiZGF0YV9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmRFcnJvciA9IChlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImVycm9yXCIsIGVycm9yTWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IGFzeW5jIChzdHJlYW0yKSA9PiB7XG4gICAgICAgIHZhciBfYTEyLCBfYjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJlYW0yKSB7XG4gICAgICAgICAgc3dpdGNoICh2YWx1ZS5ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmNyZWF0ZWRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogeyB2YWx1ZTogXCJcIiB9IH1dXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9hMTIgPSB2YWx1ZS5kYXRhLmRlbHRhLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyWzBdO1xuICAgICAgICAgICAgICBpZiAoKGNvbnRlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRlbnQudHlwZSkgPT09IFwidGV4dFwiICYmICgoX2IgPSBjb250ZW50LnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYi52YWx1ZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJ0ZXh0XCIsIGNvbnRlbnQudGV4dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4uY29tcGxldGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb25cIjoge1xuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0MyhcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiwge1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvY2VzczIoe1xuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2UsXG4gICAgICAgICAgZm9yd2FyZFN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2ExMSA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYTExIDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UgPSBBc3Npc3RhbnRSZXNwb25zZTtcblxuLy8gc3RyZWFtcy9hd3MtYmVkcm9jay1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgdmFyIF9hMTEsIF9iO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgKF9hMTEgPSByZXNwb25zZS5ib2R5KSAhPSBudWxsID8gX2ExMSA6IFtdKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoX2IgPSBjaHVuay5jaHVuaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJ5dGVzO1xuICAgIGlmIChieXRlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVua1RleHQgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gICAgICBjb25zdCBjaHVua0pTT04gPSBKU09OLnBhcnNlKGNodW5rVGV4dCk7XG4gICAgICBjb25zdCBkZWx0YSA9IGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmsoY2h1bmtKU09OKTtcbiAgICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkIGRlbHRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiB7XG4gICAgdmFyIF9hMTE7XG4gICAgcmV0dXJuIChfYTExID0gY2h1bmsuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLnRleHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuY29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuayA9PSBudWxsID8gdm9pZCAwIDogY2h1bmsudGV4dCk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5nZW5lcmF0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShcbiAgICBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2NvaGVyZS1zdHJlYW0udHNcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xpbmVzKGxpbmVzLCBjb250cm9sbGVyKSB7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IHsgdGV4dCwgaXNfZmluaXNoZWQgfSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgaWYgKCFpc19maW5pc2hlZCkge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEFuZFByb2Nlc3NMaW5lcyhyZWFkZXIsIGNvbnRyb2xsZXIpIHtcbiAgbGV0IHNlZ21lbnQgPSBcIlwiO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNodW5rLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VnbWVudCArPSB1dGY4RGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBzZWdtZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9nKTtcbiAgICBzZWdtZW50ID0gbGluZXNBcnJheS5wb3AoKSB8fCBcIlwiO1xuICAgIGF3YWl0IHByb2Nlc3NMaW5lcyhsaW5lc0FycmF5LCBjb250cm9sbGVyKTtcbiAgfVxuICBpZiAoc2VnbWVudCkge1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBbc2VnbWVudF07XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGNvbnRyb2xsZXIuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjIocmVzKSB7XG4gIHZhciBfYTExO1xuICBjb25zdCByZWFkZXIgPSAoX2ExMSA9IHJlcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5nZXRSZWFkZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcik7XG4gICAgfVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMihzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoY2h1bmsuZXZlbnRUeXBlID09PSBcInRleHQtZ2VuZXJhdGlvblwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsudGV4dDtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQ29oZXJlU3RyZWFtKHJlYWRlciwgY2FsbGJhY2tzKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZWFkZXIpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMihyZWFkZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVhZGVyKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9nb29nbGUtZ2VuZXJhdGl2ZS1haS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMyhyZXNwb25zZSkge1xuICB2YXIgX2ExMSwgX2IsIF9jO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlLnN0cmVhbSkge1xuICAgIGNvbnN0IHBhcnRzID0gKF9jID0gKF9iID0gKF9hMTEgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5wYXJ0cztcbiAgICBpZiAocGFydHMgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzWzBdO1xuICAgIGlmICh0eXBlb2YgZmlyc3RQYXJ0LnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHlpZWxkIGZpcnN0UGFydC50ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gR29vZ2xlR2VuZXJhdGl2ZUFJU3RyZWFtKHJlc3BvbnNlLCBjYikge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMyhyZXNwb25zZSkpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2h1Z2dpbmdmYWNlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMyhyZXMpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTExLCBfYjtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlcy5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbSgoX2IgPSAoX2ExMSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiKTtcbiAgICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHZhbHVlLmdlbmVyYXRlZF90ZXh0ICE9IG51bGwgJiYgdmFsdWUuZ2VuZXJhdGVkX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGV4dCA9PT0gXCI8L3M+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZG9mdGV4dHw+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZHw+XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBIdWdnaW5nRmFjZVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICByZXR1cm4gY3JlYXRlUGFyc2VyMyhyZXMpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9pbmtlZXAtc3RyZWFtLnRzXG5mdW5jdGlvbiBJbmtlZXBTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXMuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIGJvZHkgaXMgbnVsbFwiKTtcbiAgfVxuICBsZXQgY2hhdF9zZXNzaW9uX2lkID0gXCJcIjtcbiAgbGV0IHJlY29yZHNfY2l0ZWQ7XG4gIGNvbnN0IGlua2VlcEV2ZW50UGFyc2VyID0gKGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2ExMSwgX2I7XG4gICAgY29uc3QgeyBldmVudCB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnQgPT09IFwicmVjb3Jkc19jaXRlZFwiKSB7XG4gICAgICByZWNvcmRzX2NpdGVkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIChfYTExID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWNvcmRzQ2l0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwoY2FsbGJhY2tzLCByZWNvcmRzX2NpdGVkKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ID09PSBcIm1lc3NhZ2VfY2h1bmtcIikge1xuICAgICAgY29uc3QgaW5rZWVwTWVzc2FnZUNodW5rID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIGNoYXRfc2Vzc2lvbl9pZCA9IChfYiA9IGlua2VlcE1lc3NhZ2VDaHVuay5jaGF0X3Nlc3Npb25faWQpICE9IG51bGwgPyBfYiA6IGNoYXRfc2Vzc2lvbl9pZDtcbiAgICAgIHJldHVybiBpbmtlZXBNZXNzYWdlQ2h1bmsuY29udGVudF9jaHVuaztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9O1xuICBsZXQgeyBvblJlY29yZHNDaXRlZCwgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MgfSA9IGNhbGxiYWNrcyB8fCB7fTtcbiAgcGFzc1Rocm91Z2hDYWxsYmFja3MgPSB7XG4gICAgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MsXG4gICAgb25GaW5hbDogKGNvbXBsZXRpb24pID0+IHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgY29uc3QgaW5rZWVwT25GaW5hbE1ldGFkYXRhID0ge1xuICAgICAgICBjaGF0X3Nlc3Npb25faWQsXG4gICAgICAgIHJlY29yZHNfY2l0ZWRcbiAgICAgIH07XG4gICAgICAoX2ExMSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRmluYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwoY2FsbGJhY2tzLCBjb21wbGV0aW9uLCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEFJU3RyZWFtKHJlcywgaW5rZWVwRXZlbnRQYXJzZXIsIHBhc3NUaHJvdWdoQ2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1hZGFwdGVyLnRzXG52YXIgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cywge1xuICB0b0FJU3RyZWFtOiAoKSA9PiB0b0FJU3RyZWFtLFxuICB0b0RhdGFTdHJlYW06ICgpID0+IHRvRGF0YVN0cmVhbSxcbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2U6ICgpID0+IHRvRGF0YVN0cmVhbVJlc3BvbnNlXG59KTtcbmZ1bmN0aW9uIHRvQUlTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvRGF0YVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcyk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKHZhbHVlLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHZhciBfYTExO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZXZlbnRcIiBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5ldmVudCA9PT0gXCJvbl9jaGF0X21vZGVsX3N0cmVhbVwiKSB7XG4gICAgICAgICAgICBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsoXG4gICAgICAgICAgICAgIChfYTExID0gdmFsdWUuZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2h1bmssXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsodmFsdWUsIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtUmVzcG9uc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBfYTExO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtKHN0cmVhbSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jYWxsYmFja3MpO1xuICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhO1xuICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbml0O1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gZm9yd2FyZEFJTWVzc2FnZUNodW5rKGNodW5rLCBjb250cm9sbGVyKSB7XG4gIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gY2h1bmsuY29udGVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29udGVudCkge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGl0ZW0udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLXN0cmVhbS50c1xuZnVuY3Rpb24gTGFuZ0NoYWluU3RyZWFtKGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgY29uc3QgcnVucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICBhd2FpdCB3cml0ZXIuYWJvcnQoZSk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVN0YXJ0ID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5hZGQocnVuSWQpO1xuICB9O1xuICBjb25zdCBoYW5kbGVFbmQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgaWYgKHJ1bnMuc2l6ZSA9PT0gMCkge1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogc3RyZWFtLnJlYWRhYmxlLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKSxcbiAgICB3cml0ZXIsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGhhbmRsZUxMTU5ld1Rva2VuOiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUodG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTVN0YXJ0OiBhc3luYyAoX2xsbSwgX3Byb21wdHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluU3RhcnQ6IGFzeW5jIChfY2hhaW4sIF9pbnB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVuZDogYXN5bmMgKF9vdXRwdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbFN0YXJ0OiBhc3luYyAoX3Rvb2wsIF9pbnB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvbWlzdHJhbC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNChzdHJlYW0pIHtcbiAgdmFyIF9hMTEsIF9iO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2IgPSAoX2ExMSA9IGNodW5rLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwIHx8IGNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBjb250ZW50O1xuICB9XG59XG5mdW5jdGlvbiBNaXN0cmFsU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNChyZXNwb25zZSkpO1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDRcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHBhcnNlT3BlbkFJU3RyZWFtKCkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIChkYXRhKSA9PiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU1KHN0cmVhbSkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwicHJvbXB0RmlsdGVyUmVzdWx0c1wiIGluIGNodW5rKSB7XG4gICAgICBjaHVuayA9IHtcbiAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICBjcmVhdGVkOiBjaHVuay5jcmVhdGVkLmdldERhdGUoKSxcbiAgICAgICAgb2JqZWN0OiBjaHVuay5vYmplY3QsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBtb2RlbDogY2h1bmsubW9kZWwsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBjaG9pY2VzOiBjaHVuay5jaG9pY2VzLm1hcCgoY2hvaWNlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IChfYTExID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jb250ZW50LFxuICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiAoX2IgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICAgIHJvbGU6IChfYyA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJvbGUsXG4gICAgICAgICAgICAgIHRvb2xfY2FsbHM6ICgoX2UgPSAoX2QgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5sZW5ndGgpID8gKF9nID0gKF9mID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2YudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cubWFwKCh0b29sQ2FsbCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlXG4gICAgICAgICAgICAgIH0pKSA6IHZvaWQgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBpbmRleDogY2hvaWNlLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCkge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gIHJldHVybiAoanNvbikgPT4ge1xuICAgIHZhciBfYTExLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX28sIF9wLCBfcSwgX3I7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSAoX2ExMSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuZGVsdGE7XG4gICAgICBpZiAoKF9iID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfZSA9IChfZCA9IChfYyA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfY1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2UubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGRlbHRhLnRvb2xfY2FsbHNbMF07XG4gICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYHtcInRvb2xfY2FsbHNcIjpbIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2YgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBgXCJ9fSwge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZyA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2cubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX2ggPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2guYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfaSA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaS5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfbCA9IChfayA9IChfaiA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfalswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2wuYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfbyA9IChfbiA9IChfbSA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX28uYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKCgoX3AgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcC5maW5pc2hfcmVhc29uKSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIgfHwgKChfcSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9xLmZpbmlzaF9yZWFzb24pID09PSBcInN0b3BcIikpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fSdcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoX3IgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfci5maW5pc2hfcmVhc29uKSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fV19J1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oXG4gICAgICBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikgJiYganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgPyBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA6IGlzQ29tcGxldGlvbihqc29uKSA/IGpzb24uY2hvaWNlc1swXS50ZXh0IDogXCJcIlxuICAgICk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG4gIGZ1bmN0aW9uIGNsZWFudXBBcmd1bWVudHMoYXJndW1lbnRDaHVuaykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxmL2csIFwiXFxcXGZcIik7XG4gICAgcmV0dXJuIGAke2VzY2FwZWRQYXJ0aWFsSnNvbn1gO1xuICB9XG59XG52YXIgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgXCJpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXNcIlxuKTtcbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJkZWx0YVwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGlvbihkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJ0ZXh0XCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gT3BlbkFJU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IGNiID0gY2FsbGJhY2tzO1xuICBsZXQgc3RyZWFtO1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgLi4uY2JcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAuLi5jYixcbiAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jYlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNhbGxiYWNrcykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlcyA9IGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID0gaXNGaXJzdENodW5rICYmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fCBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaXNGaXJzdENodW5rICYmIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICBsZXQgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sMiBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sMi5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sMi5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sX2NhbGxfaWQsIGZ1bmN0aW9uX25hbWUsIHRvb2xfY2FsbF9yZXN1bHQgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2VJbmRleCA9PT0gMCA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsczogcGF5bG9hZC50b29sX2NhbGxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVzdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6XCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gXCJmdW5jdGlvbl9jYWxsXCIgOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQ0KFwidGV4dFwiLCBmdW5jdGlvblJlc3BvbnNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uU3RhcnQ6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB2b2lkIDA7XG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9yZXBsaWNhdGUtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBSZXBsaWNhdGVTdHJlYW0ocmVzLCBjYiwgb3B0aW9ucykge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgdXJsID0gKF9hMTEgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuc3RyZWFtO1xuICBpZiAoIXVybCkge1xuICAgIGlmIChyZXMuZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHN0cmVhbSBVUkwgaW4gUmVwbGljYXRlIHJlc3BvbnNlXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50U3RyZWFtID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIEFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEFJU3RyZWFtKGV2ZW50U3RyZWFtLCB2b2lkIDAsIGNiKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gc3RyZWFtVG9SZXNwb25zZShyZXMsIHJlc3BvbnNlLCBpbml0LCBkYXRhKSB7XG4gIHZhciBfYTExO1xuICByZXNwb25zZS53cml0ZUhlYWQoKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsIHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgfSk7XG4gIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gIGlmIChkYXRhKSB7XG4gICAgcHJvY2Vzc2VkU3RyZWFtID0gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCByZXMpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHByb2Nlc3NlZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgIHJlYWQoKTtcbiAgICB9KTtcbiAgfVxuICByZWFkKCk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXRleHQtcmVzcG9uc2UudHNcbnZhciBTdHJlYW1pbmdUZXh0UmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocmVzLCBpbml0LCBkYXRhKSB7XG4gICAgbGV0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcztcbiAgICBpZiAoZGF0YSkge1xuICAgICAgcHJvY2Vzc2VkU3RyZWFtID0gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCByZXMpO1xuICAgIH1cbiAgICBzdXBlcihwcm9jZXNzZWRTdHJlYW0sIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHN0cmVhbXMvaW5kZXgudHNcbnZhciBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRJbXBsO1xudmFyIG5hbm9pZCA9IGdlbmVyYXRlSWRJbXBsO1xuZXhwb3J0IHtcbiAgQUlTREtFcnJvcjEwIGFzIEFJU0RLRXJyb3IsXG4gIEFJU3RyZWFtLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtLFxuICBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtLFxuICBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtLFxuICBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtLFxuICBBV1NCZWRyb2NrU3RyZWFtLFxuICBBbnRocm9waWNTdHJlYW0sXG4gIEFzc2lzdGFudFJlc3BvbnNlLFxuICBDb2hlcmVTdHJlYW0sXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbSxcbiAgSHVnZ2luZ0ZhY2VTdHJlYW0sXG4gIElua2VlcFN0cmVhbSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWREYXRhQ29udGVudEVycm9yLFxuICBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yMiBhcyBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgYXMgTGFuZ0NoYWluQWRhcHRlcixcbiAgTGFuZ0NoYWluU3RyZWFtLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IsXG4gIE1pc3RyYWxTdHJlYW0sXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIE9wZW5BSVN0cmVhbSxcbiAgUmVwbGljYXRlU3RyZWFtLFxuICBSZXRyeUVycm9yLFxuICBTdHJlYW1EYXRhMiBhcyBTdHJlYW1EYXRhLFxuICBTdHJlYW1pbmdUZXh0UmVzcG9uc2UsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IyIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMiBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgY29udmVydFRvQ29yZU1lc3NhZ2VzLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcixcbiAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyLFxuICBlbWJlZCxcbiAgZW1iZWRNYW55LFxuICBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhLFxuICBleHBlcmltZW50YWxfY3JlYXRlTW9kZWxSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGV4cGVyaW1lbnRhbF9jdXN0b21Qcm92aWRlcixcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0LFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0LFxuICBleHBlcmltZW50YWxfc3RyZWFtT2JqZWN0LFxuICBleHBlcmltZW50YWxfc3RyZWFtVGV4dCxcbiAgZXhwZXJpbWVudGFsX3dyYXBMYW5ndWFnZU1vZGVsLFxuICBmb3JtYXRTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkMiBhcyBnZW5lcmF0ZUlkLFxuICBnZW5lcmF0ZU9iamVjdCxcbiAgZ2VuZXJhdGVUZXh0LFxuICBqc29uU2NoZW1hLFxuICBuYW5vaWQsXG4gIHBhcnNlU3RyZWFtUGFydCxcbiAgcHJvY2Vzc0RhdGFQcm90b2NvbFJlc3BvbnNlLFxuICByZWFkRGF0YVN0cmVhbSxcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgc3RyZWFtT2JqZWN0LFxuICBzdHJlYW1UZXh0LFxuICBzdHJlYW1Ub1Jlc3BvbnNlLFxuICB0b29sLFxuICB0cmltU3RhcnRPZlN0cmVhbUhlbHBlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncGeneratorToReadableStream: () => (/* binding */ convertAsyncGeneratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isParseableJson: () => (/* binding */ isParseableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventsource-parser/stream */ \"(rsc)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-generator-to-readable-stream.ts\nfunction convertAsyncGeneratorToReadableStream(stream) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\nvar createIdGenerator = ({\n  prefix = \"\",\n  size: defaultSize = 7,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n} = {}) => {\n  const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n  return (size) => `${prefix}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n\n// src/validate-types.ts\n\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isTypeValidationError(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar isParseableJson = isParsableJson;\n\n// src/post-to-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/post-to-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/response-handler.ts\n\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__.EventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value\n  };\n};\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ21EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sb0JBQW9CLGlFQUFjO0FBQ2xDLHNCQUFzQixPQUFPLEVBQUUsZ0JBQWdCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0Isa0JBQWtCLGFBQWE7QUFDL0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZEQUFlO0FBQzdCLGtCQUFrQixhQUFhLHlDQUF5QyxvQkFBb0I7QUFDNUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0Isa0JBQWtCLGFBQWEseUNBQXlDLG9CQUFvQixxQkFBcUIseUJBQXlCO0FBQzFJ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QUMxRTtBQUNBO0FBQ0EsY0FBYyxvRUFBc0IsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtDQUFrQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYywwREFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBZ0NFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3Vuc2VsbGluZy10aHJvdWdoLWJpYmxlLWZ1bGxzdGFjay8uL25vZGVfbW9kdWxlcy9haS9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcz9hMWQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21iaW5lLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGNvbWJpbmVIZWFkZXJzKC4uLmhlYWRlcnMpIHtcbiAgcmV0dXJuIGhlYWRlcnMucmVkdWNlKFxuICAgIChjb21iaW5lZEhlYWRlcnMsIGN1cnJlbnRIZWFkZXJzKSA9PiAoe1xuICAgICAgLi4uY29tYmluZWRIZWFkZXJzLFxuICAgICAgLi4uY3VycmVudEhlYWRlcnMgIT0gbnVsbCA/IGN1cnJlbnRIZWFkZXJzIDoge31cbiAgICB9KSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBzcmMvY29udmVydC1hc3luYy1nZW5lcmF0b3ItdG8tcmVhZGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjb252ZXJ0QXN5bmNHZW5lcmF0b3JUb1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29uc3VtZXIgd2FudHMgdG8gcHVsbCBtb3JlIGRhdGEgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFQ+fSBjb250cm9sbGVyIC0gVGhlIGNvbnRyb2xsZXIgdG8gZW5xdWV1ZSBkYXRhIGludG8gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN1bWVyIGNhbmNlbHMgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2V4dHJhY3QtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSkge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1pZC50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBjcmVhdGVJZEdlbmVyYXRvciA9ICh7XG4gIHByZWZpeCA9IFwiXCIsXG4gIHNpemU6IGRlZmF1bHRTaXplID0gNyxcbiAgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCJcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBjdXN0b21BbHBoYWJldChhbHBoYWJldCwgZGVmYXVsdFNpemUpO1xuICByZXR1cm4gKHNpemUpID0+IGAke3ByZWZpeH0ke2dlbmVyYXRvcihzaXplKX1gO1xufTtcbnZhciBnZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3IoKTtcblxuLy8gc3JjL2dldC1lcnJvci1tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG59XG5cbi8vIHNyYy9pcy1hYm9ydC1lcnJvci50c1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKTtcbn1cblxuLy8gc3JjL2xvYWQtYXBpLWtleS50c1xuaW1wb3J0IHsgTG9hZEFQSUtleUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRBcGlLZXkoe1xuICBhcGlLZXksXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBhcGlLZXlQYXJhbWV0ZXJOYW1lID0gXCJhcGlLZXlcIixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBhcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYXBpS2V5O1xuICB9XG4gIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBhcGlLZXkgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gc3JjL2xvYWQtc2V0dGluZy50c1xuaW1wb3J0IHsgTG9hZFNldHRpbmdFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIHNldHRpbmdOYW1lLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvbG9hZC1vcHRpb25hbC1zZXR0aW5nLnRzXG5mdW5jdGlvbiBsb2FkT3B0aW9uYWxTZXR0aW5nKHtcbiAgc2V0dGluZ1ZhbHVlLFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZVxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsIHx8IHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXR0aW5nVmFsdWUgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChzZXR0aW5nVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygc2V0dGluZ1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuaW1wb3J0IHtcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCBTZWN1cmVKU09OIGZyb20gXCJzZWN1cmUtanNvbi1wYXJzZVwiO1xuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvdmFsaWRhdG9yLnRzXG52YXIgdmFsaWRhdG9yU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS52YWxpZGF0b3JcIik7XG5mdW5jdGlvbiB2YWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHsgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsIHZhbGlkYXRlIH07XG59XG5mdW5jdGlvbiBpc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbGlkYXRvclN5bWJvbCBpbiB2YWx1ZSAmJiB2YWx1ZVt2YWxpZGF0b3JTeW1ib2xdID09PSB0cnVlICYmIFwidmFsaWRhdGVcIiBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1ZhbGlkYXRvcih2YWx1ZSkgPyB2YWx1ZSA6IHpvZFZhbGlkYXRvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB6b2RWYWxpZGF0b3Ioem9kU2NoZW1hKSB7XG4gIHJldHVybiB2YWxpZGF0b3IoKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gem9kU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hXG59KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuZnVuY3Rpb24gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hXG59KSB7XG4gIGNvbnN0IHZhbGlkYXRvcjIgPSBhc1ZhbGlkYXRvcihzY2hlbWEpO1xuICB0cnkge1xuICAgIGlmICh2YWxpZGF0b3IyLnZhbGlkYXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvcjIudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiBlcnJvciB9KVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmZ1bmN0aW9uIHBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gU2VjdXJlSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChKU09OUGFyc2VFcnJvci5pc0pTT05QYXJzZUVycm9yKGVycm9yKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yMi5pc1R5cGVWYWxpZGF0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBTZWN1cmVKU09OLnBhcnNlKHRleHQpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IEpTT05QYXJzZUVycm9yLmlzSlNPTlBhcnNlRXJyb3IoZXJyb3IpID8gZXJyb3IgOiBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc1BhcnNhYmxlSnNvbihpbnB1dCkge1xuICB0cnkge1xuICAgIFNlY3VyZUpTT04ucGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgaXNQYXJzZWFibGVKc29uID0gaXNQYXJzYWJsZUpzb247XG5cbi8vIHNyYy9wb3N0LXRvLWFwaS50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3JlbW92ZS11bmRlZmluZWQtZW50cmllcy50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhyZWNvcmQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbClcbiAgKTtcbn1cblxuLy8gc3JjL3Bvc3QtdG8tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczoge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmhlYWRlcnNcbiAgfSxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIHZhbHVlczogYm9keVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSk7XG52YXIgcG9zdFRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGJvZHksXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgLy8gcmV0cnkgd2hlbiBuZXR3b3JrIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLWhhbmRsZXIudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLCBFbXB0eVJlc3BvbnNlQm9keUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXIvc3RyZWFtXCI7XG52YXIgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyID0gKHtcbiAgZXJyb3JTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlLFxuICBpc1JldHJ5YWJsZVxufSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2VCb2R5LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiBlcnJvclRvTWVzc2FnZShwYXJzZWRFcnJvciksXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGRhdGE6IHBhcnNlZEVycm9yLFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlLCBwYXJzZWRFcnJvcilcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKHsgZGF0YSB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEsXG4gICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmtUZXh0LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rVGV4dC5lbmRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBidWZmZXIgKyBjaHVua1RleHQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1RleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZVNjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHNhZmVQYXJzZUpTT04oe1xuICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hXG4gIH0pO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFwYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlXG4gIH07XG59O1xuXG4vLyBzcmMvdWludDgtdXRpbHMudHNcbnZhciB7IGJ0b2EsIGF0b2IgfSA9IGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykge1xuICBjb25zdCBiYXNlNjRVcmwgPSBiYXNlNjRTdHJpbmcucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIGNvbnN0IGxhdGluMXN0cmluZyA9IGF0b2IoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsYXRpbjFzdHJpbmcsIChieXRlKSA9PiBieXRlLmNvZGVQb2ludEF0KDApKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoYXJyYXkpIHtcbiAgbGV0IGxhdGluMXN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsYXRpbjFzdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGxhdGluMXN0cmluZyk7XG59XG5cbi8vIHNyYy93aXRob3V0LXRyYWlsaW5nLXNsYXNoLnRzXG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PSBudWxsID8gdm9pZCAwIDogdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbn1cbmV4cG9ydCB7XG4gIGFzVmFsaWRhdG9yLFxuICBjb21iaW5lSGVhZGVycyxcbiAgY29udmVydEFzeW5jR2VuZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbiAgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIsXG4gIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMsXG4gIGdlbmVyYXRlSWQsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgaXNBYm9ydEVycm9yLFxuICBpc1BhcnNhYmxlSnNvbixcbiAgaXNQYXJzZWFibGVKc29uLFxuICBpc1ZhbGlkYXRvcixcbiAgbG9hZEFwaUtleSxcbiAgbG9hZE9wdGlvbmFsU2V0dGluZyxcbiAgbG9hZFNldHRpbmcsXG4gIHBhcnNlSlNPTixcbiAgcG9zdEpzb25Ub0FwaSxcbiAgcG9zdFRvQXBpLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdG9yLFxuICB2YWxpZGF0b3JTeW1ib2wsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICB6b2RWYWxpZGF0b3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name13,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name13;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker14) {\n    const markerSymbol = Symbol.for(marker14);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message\n    };\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error) {\n    return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data\n    };\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(error) {\n    return error instanceof Error && error.name === name2;\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-prompt-error.ts\nvar name3 = \"AI_InvalidPromptError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt: prompt2,\n    message,\n    cause\n  }) {\n    super({ name: name3, message: `Invalid prompt: ${message}`, cause });\n    this[_a4] = true;\n    this.prompt = prompt2;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error) {\n    return error instanceof Error && error.name === name3 && prompt != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      prompt: this.prompt\n    };\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-response-data-error.ts\nvar name4 = \"AI_InvalidResponseDataError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name4, message });\n    this[_a5] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(error) {\n    return error instanceof Error && error.name === name4 && error.data != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      data: this.data\n    };\n  }\n};\n_a5 = symbol5;\n\n// src/errors/json-parse-error.ts\nvar name5 = \"AI_JSONParseError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name5,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a6] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error) {\n    return error instanceof Error && error.name === name5 && \"text\" in error && typeof error.text === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      valueText: this.text\n    };\n  }\n};\n_a6 = symbol6;\n\n// src/errors/load-api-key-error.ts\nvar name6 = \"AI_LoadAPIKeyError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name6, message });\n    this[_a7] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-setting-error.ts\nvar name7 = \"AI_LoadSettingError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error) {\n    return error instanceof Error && error.name === name7;\n  }\n};\n_a8 = symbol8;\n\n// src/errors/no-content-generated-error.ts\nvar name8 = \"AI_NoContentGeneratedError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(error) {\n    return error instanceof Error && error.name === name8;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-such-model-error.ts\nvar name9 = \"AI_NoSuchModelError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name9,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a10] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchModelError(error) {\n    return error instanceof Error && error.name === name9 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType\n    };\n  }\n};\n_a10 = symbol10;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name10 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name10,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a11] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(error) {\n    return error instanceof Error && error.name === name10 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values\n    };\n  }\n};\n_a11 = symbol11;\n\n// src/errors/type-validation-error.ts\nvar name11 = \"AI_TypeValidationError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name11,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a12] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error) {\n    return error instanceof Error && error.name === name11;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      value: this.value\n    };\n  }\n};\n_a12 = symbol12;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name12 = \"AI_UnsupportedFunctionalityError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({ functionality }) {\n    super({\n      name: name12,\n      message: `'${functionality}' functionality not supported.`\n    });\n    this[_a13] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(error) {\n    return error instanceof Error && error.name === name12 && typeof error.functionality === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      functionality: this.functionality\n    };\n  }\n};\n_a13 = symbol13;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVkseUNBQXlDLFFBQVEsVUFBVTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0QsR0FBRztBQUNILFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUixZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVUsSUFBSSxRQUFRO0FBQy9DLEdBQUc7QUFDSCxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxrQkFBa0IsU0FBUyxnQkFBZ0IseUJBQXlCLDhCQUE4Qix1QkFBdUIsdUJBQXVCO0FBQ25OLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLGlEQUFpRCxzQkFBc0I7QUFDdkUsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0hBQWdILGNBQWM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1CRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY291bnNlbGxpbmctdGhyb3VnaC1iaWJsZS1mdWxsc3RhY2svLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanM/MDI0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3JzL2FpLXNkay1lcnJvci50c1xudmFyIG1hcmtlciA9IFwidmVyY2VsLmFpLmVycm9yXCI7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIF9BSVNES0Vycm9yID0gY2xhc3MgX0FJU0RLRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEFJIFNESyBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gW3BhcmFtcy5jYXVzZV0gLSBUaGUgdW5kZXJseWluZyBjYXVzZSBvZiB0aGUgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTEzLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lMTM7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gX0FJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIHN0YXRpYyBoYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KSB7XG4gICAgY29uc3QgbWFya2VyU3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG4gICAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIG1hcmtlclN5bWJvbCBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gXCJib29sZWFuXCIgJiYgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXJyb3IncyBuYW1lLCBtZXNzYWdlLCBhbmQgY2F1c2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG52YXIgQUlTREtFcnJvciA9IF9BSVNES0Vycm9yO1xuXG4vLyBzcmMvZXJyb3JzL2FwaS1jYWxsLWVycm9yLnRzXG52YXIgbmFtZSA9IFwiQUlfQVBJQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIEFQSUNhbGxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHVybCxcbiAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICByZXNwb25zZUJvZHksXG4gICAgY2F1c2UsXG4gICAgaXNSZXRyeWFibGUgPSBzdGF0dXNDb2RlICE9IG51bGwgJiYgKHN0YXR1c0NvZGUgPT09IDQwOCB8fCAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICBzdGF0dXNDb2RlID09PSA0MDkgfHwgLy8gY29uZmxpY3RcbiAgICBzdGF0dXNDb2RlID09PSA0MjkgfHwgLy8gdG9vIG1hbnkgcmVxdWVzdHNcbiAgICBzdGF0dXNDb2RlID49IDUwMCksXG4gICAgLy8gc2VydmVyIGVycm9yXG4gICAgZGF0YVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMucmVxdWVzdEJvZHlWYWx1ZXMgPSByZXF1ZXN0Qm9keVZhbHVlcztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xuICAgIHRoaXMucmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5O1xuICAgIHRoaXMuaXNSZXRyeWFibGUgPSBpc1JldHJ5YWJsZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc0FQSUNhbGxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUgJiYgdHlwZW9mIGVycm9yLnVybCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IucmVxdWVzdEJvZHlWYWx1ZXMgPT09IFwib2JqZWN0XCIgJiYgKGVycm9yLnN0YXR1c0NvZGUgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzQ29kZSA9PT0gXCJudW1iZXJcIikgJiYgKGVycm9yLnJlc3BvbnNlSGVhZGVycyA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5yZXNwb25zZUhlYWRlcnMgPT09IFwib2JqZWN0XCIpICYmIChlcnJvci5yZXNwb25zZUJvZHkgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IucmVzcG9uc2VCb2R5ID09PSBcInN0cmluZ1wiKSAmJiAoZXJyb3IuY2F1c2UgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IuY2F1c2UgPT09IFwib2JqZWN0XCIpICYmIHR5cGVvZiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gXCJib29sZWFuXCIgJiYgKGVycm9yLmRhdGEgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IuZGF0YSA9PT0gXCJvYmplY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHRoaXMucmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICByZXNwb25zZUhlYWRlcnM6IHRoaXMucmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5OiB0aGlzLnJlc3BvbnNlQm9keSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgaXNSZXRyeWFibGU6IHRoaXMuaXNSZXRyeWFibGUsXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNFbXB0eVJlc3BvbnNlQm9keUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTI7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3JzL2dldC1lcnJvci1tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG59XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1wcm9tcHQtZXJyb3IudHNcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZFByb21wdEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkUHJvbXB0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcHJvbXB0OiBwcm9tcHQyLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2U6IGBJbnZhbGlkIHByb21wdDogJHttZXNzYWdlfWAsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5wcm9tcHQgPSBwcm9tcHQyO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkUHJvbXB0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMyAmJiBwcm9tcHQgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcHJvbXB0OiB0aGlzLnByb21wdFxuICAgIH07XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcmVzcG9uc2UtZGF0YS1lcnJvci50c1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1O1xudmFyIEludmFsaWRSZXNwb25zZURhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCByZXNwb25zZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgZXJyb3IuZGF0YSAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gc3JjL2Vycm9ycy9qc29uLXBhcnNlLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0pTT05QYXJzZUVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBKU09OUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdGV4dCwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU1LFxuICAgICAgbWVzc2FnZTogYEpTT04gcGFyc2luZyBmYWlsZWQ6IFRleHQ6ICR7dGV4dH0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNKU09OUGFyc2VFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIFwidGV4dFwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci50ZXh0ID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHZhbHVlVGV4dDogdGhpcy50ZXh0XG4gICAgfTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1hcGkta2V5LWVycm9yLnRzXG52YXIgbmFtZTYgPSBcIkFJX0xvYWRBUElLZXlFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgTG9hZEFQSUtleUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc0xvYWRBUElLZXlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU2O1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gc3JjL2Vycm9ycy9sb2FkLXNldHRpbmctZXJyb3IudHNcbnZhciBuYW1lNyA9IFwiQUlfTG9hZFNldHRpbmdFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTG9hZFNldHRpbmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNMb2FkU2V0dGluZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTc7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL25vLWNvbnRlbnQtZ2VuZXJhdGVkLWVycm9yLnRzXG52YXIgbmFtZTggPSBcIkFJX05vQ29udGVudEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc05vQ29udGVudEdlbmVyYXRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTg7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tc3VjaC1tb2RlbC1lcnJvci50c1xudmFyIG5hbWU5ID0gXCJBSV9Ob1N1Y2hNb2RlbEVycm9yXCI7XG52YXIgbWFya2VyMTAgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTl9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lOSxcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggJHttb2RlbFR5cGV9OiAke21vZGVsSWR9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBlcnJvck5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gICAgdGhpcy5tb2RlbElkID0gbW9kZWxJZDtcbiAgICB0aGlzLm1vZGVsVHlwZSA9IG1vZGVsVHlwZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaE1vZGVsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOSAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IubW9kZWxUeXBlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtb2RlbFR5cGU6IHRoaXMubW9kZWxUeXBlXG4gICAgfTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTEwID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEwLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMCAmJiBcInByb3ZpZGVyXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnByb3ZpZGVyID09PSBcInN0cmluZ1wiICYmIFwibW9kZWxJZFwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5tb2RlbElkID09PSBcInN0cmluZ1wiICYmIFwibWF4RW1iZWRkaW5nc1BlckNhbGxcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubWF4RW1iZWRkaW5nc1BlckNhbGwgPT09IFwibnVtYmVyXCIgJiYgXCJ2YWx1ZXNcIiBpbiBlcnJvciAmJiBBcnJheS5pc0FycmF5KGVycm9yLnZhbHVlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzXG4gICAgfTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90eXBlLXZhbGlkYXRpb24tZXJyb3IudHNcbnZhciBuYW1lMTEgPSBcIkFJX1R5cGVWYWxpZGF0aW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgX1R5cGVWYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBfVHlwZVZhbGlkYXRpb25FcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFR5cGUgdmFsaWRhdGlvbiBmYWlsZWQ6IFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGFuIGVycm9yIGludG8gYSBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKiBJZiB0aGUgY2F1c2UgaXMgYWxyZWFkeSBhIFR5cGVWYWxpZGF0aW9uRXJyb3Igd2l0aCB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyB0aGUgY2F1c2UuXG4gICAqIE90aGVyd2lzZSwgaXQgY3JlYXRlcyBhIG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHdyYXBwaW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMudmFsdWUgLSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMuY2F1c2UgLSBUaGUgb3JpZ2luYWwgZXJyb3Igb3IgY2F1c2Ugb2YgdGhlIHZhbGlkYXRpb24gZmFpbHVyZS5cbiAgICogQHJldHVybnMge1R5cGVWYWxpZGF0aW9uRXJyb3J9IEEgVHlwZVZhbGlkYXRpb25FcnJvciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKHtcbiAgICB2YWx1ZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgcmV0dXJuIF9UeXBlVmFsaWRhdGlvbkVycm9yLmlzSW5zdGFuY2UoY2F1c2UpICYmIGNhdXNlLnZhbHVlID09PSB2YWx1ZSA/IGNhdXNlIDogbmV3IF9UeXBlVmFsaWRhdGlvbkVycm9yKHsgdmFsdWUsIGNhdXNlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1R5cGVWYWxpZGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTE7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG59O1xuX2ExMiA9IHN5bWJvbDEyO1xudmFyIFR5cGVWYWxpZGF0aW9uRXJyb3IgPSBfVHlwZVZhbGlkYXRpb25FcnJvcjtcblxuLy8gc3JjL2Vycm9ycy91bnN1cHBvcnRlZC1mdW5jdGlvbmFsaXR5LWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9VbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMn1gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgZnVuY3Rpb25hbGl0eSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEyLFxuICAgICAgbWVzc2FnZTogYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMuZnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uYWxpdHk7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc1Vuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEyICYmIHR5cGVvZiBlcnJvci5mdW5jdGlvbmFsaXR5ID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBmdW5jdGlvbmFsaXR5OiB0aGlzLmZ1bmN0aW9uYWxpdHlcbiAgICB9O1xuICB9XG59O1xuX2ExMyA9IHN5bWJvbDEzO1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBMb2FkU2V0dGluZ0Vycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgaXNKU09OVmFsdWVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ })

};
;