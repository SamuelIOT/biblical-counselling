"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ai-sdk";
exports.ids = ["vendor-chunks/@ai-sdk"];
exports.modules = {

/***/ "(rsc)/./node_modules/@ai-sdk/openai/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@ai-sdk/openai/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenAI: () => (/* binding */ OpenAI),\n/* harmony export */   createOpenAI: () => (/* binding */ createOpenAI),\n/* harmony export */   openai: () => (/* binding */ openai)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\n// src/openai-facade.ts\n\n\n// src/openai-chat-language-model.ts\n\n\n\n\n// src/convert-to-openai-chat-messages.ts\n\n\nfunction convertToOpenAIChatMessages({\n  prompt,\n  useLegacyFunctionCalling = false\n}) {\n  const messages = [];\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        messages.push({ role: \"system\", content });\n        break;\n      }\n      case \"user\": {\n        if (content.length === 1 && content[0].type === \"text\") {\n          messages.push({ role: \"user\", content: content[0].text });\n          break;\n        }\n        messages.push({\n          role: \"user\",\n          content: content.map((part) => {\n            var _a;\n            switch (part.type) {\n              case \"text\": {\n                return { type: \"text\", text: part.text };\n              }\n              case \"image\": {\n                return {\n                  type: \"image_url\",\n                  image_url: {\n                    url: part.image instanceof URL ? part.image.toString() : `data:${(_a = part.mimeType) != null ? _a : \"image/jpeg\"};base64,${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(part.image)}`\n                  }\n                };\n              }\n            }\n          })\n        });\n        break;\n      }\n      case \"assistant\": {\n        let text = \"\";\n        const toolCalls = [];\n        for (const part of content) {\n          switch (part.type) {\n            case \"text\": {\n              text += part.text;\n              break;\n            }\n            case \"tool-call\": {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: \"function\",\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args)\n                }\n              });\n              break;\n            }\n            default: {\n              const _exhaustiveCheck = part;\n              throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n            }\n          }\n        }\n        if (useLegacyFunctionCalling) {\n          if (toolCalls.length > 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n              functionality: \"useLegacyFunctionCalling with multiple tool calls in one message\"\n            });\n          }\n          messages.push({\n            role: \"assistant\",\n            content: text,\n            function_call: toolCalls.length > 0 ? toolCalls[0].function : void 0\n          });\n        } else {\n          messages.push({\n            role: \"assistant\",\n            content: text,\n            tool_calls: toolCalls.length > 0 ? toolCalls : void 0\n          });\n        }\n        break;\n      }\n      case \"tool\": {\n        for (const toolResponse of content) {\n          if (useLegacyFunctionCalling) {\n            messages.push({\n              role: \"function\",\n              name: toolResponse.toolName,\n              content: JSON.stringify(toolResponse.result)\n            });\n          } else {\n            messages.push({\n              role: \"tool\",\n              tool_call_id: toolResponse.toolCallId,\n              content: JSON.stringify(toolResponse.result)\n            });\n          }\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return messages;\n}\n\n// src/map-openai-chat-logprobs.ts\nfunction mapOpenAIChatLogProbsOutput(logprobs) {\n  var _a, _b;\n  return (_b = (_a = logprobs == null ? void 0 : logprobs.content) == null ? void 0 : _a.map(({ token, logprob, top_logprobs }) => ({\n    token,\n    logprob,\n    topLogprobs: top_logprobs ? top_logprobs.map(({ token: token2, logprob: logprob2 }) => ({\n      token: token2,\n      logprob: logprob2\n    })) : []\n  }))) != null ? _b : void 0;\n}\n\n// src/map-openai-finish-reason.ts\nfunction mapOpenAIFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\n\n// src/openai-error.ts\n\n\nvar openAIErrorDataSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  error: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    message: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n    type: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n    param: zod__WEBPACK_IMPORTED_MODULE_2__.z.any().nullable(),\n    code: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullable()\n  })\n});\nvar openaiFailedResponseHandler = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n  errorSchema: openAIErrorDataSchema,\n  errorToMessage: (data) => data.error.message\n});\n\n// src/openai-chat-language-model.ts\nvar OpenAIChatLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get supportsStructuredOutputs() {\n    return this.settings.structuredOutputs === true;\n  }\n  get defaultObjectGenerationMode() {\n    return this.supportsStructuredOutputs ? \"json\" : \"tool\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed\n  }) {\n    var _a;\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type === \"json\" && responseFormat.schema != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format schema is not supported\"\n      });\n    }\n    const useLegacyFunctionCalling = this.settings.useLegacyFunctionCalling;\n    if (useLegacyFunctionCalling && this.settings.parallelToolCalls === true) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: \"useLegacyFunctionCalling with parallelToolCalls\"\n      });\n    }\n    if (useLegacyFunctionCalling && this.settings.structuredOutputs === true) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: \"structuredOutputs with useLegacyFunctionCalling\"\n      });\n    }\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === \"number\" ? true : void 0,\n      top_logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      stop: stopSequences,\n      seed,\n      // response format:\n      response_format: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? { type: \"json_object\" } : void 0,\n      // messages:\n      messages: convertToOpenAIChatMessages({\n        prompt,\n        useLegacyFunctionCalling\n      })\n    };\n    switch (type) {\n      case \"regular\": {\n        return {\n          args: {\n            ...baseArgs,\n            ...prepareToolsAndToolChoice({\n              mode,\n              useLegacyFunctionCalling,\n              structuredOutputs: this.settings.structuredOutputs\n            })\n          },\n          warnings\n        };\n      }\n      case \"object-json\": {\n        return {\n          args: {\n            ...baseArgs,\n            response_format: this.settings.structuredOutputs === true ? {\n              type: \"json_schema\",\n              json_schema: {\n                schema: mode.schema,\n                strict: true,\n                name: (_a = mode.name) != null ? _a : \"response\",\n                description: mode.description\n              }\n            } : { type: \"json_object\" }\n          },\n          warnings\n        };\n      }\n      case \"object-tool\": {\n        return {\n          args: useLegacyFunctionCalling ? {\n            ...baseArgs,\n            function_call: {\n              name: mode.tool.name\n            },\n            functions: [\n              {\n                name: mode.tool.name,\n                description: mode.tool.description,\n                parameters: mode.tool.parameters\n              }\n            ]\n          } : {\n            ...baseArgs,\n            tool_choice: {\n              type: \"function\",\n              function: { name: mode.tool.name }\n            },\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: mode.tool.name,\n                  description: mode.tool.description,\n                  parameters: mode.tool.parameters\n                },\n                strict: this.settings.structuredOutputs === true ? true : void 0\n              }\n            ]\n          },\n          warnings\n        };\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  async doGenerate(options) {\n    var _a, _b;\n    const { args, warnings } = this.getArgs(options);\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openAIChatResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { messages: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n    return {\n      text: (_a = choice.message.content) != null ? _a : void 0,\n      toolCalls: this.settings.useLegacyFunctionCalling && choice.message.function_call ? [\n        {\n          toolCallType: \"function\",\n          toolCallId: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n          toolName: choice.message.function_call.name,\n          args: choice.message.function_call.arguments\n        }\n      ] : (_b = choice.message.tool_calls) == null ? void 0 : _b.map((toolCall) => {\n        var _a2;\n        return {\n          toolCallType: \"function\",\n          toolCallId: (_a2 = toolCall.id) != null ? _a2 : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n          toolName: toolCall.function.name,\n          args: toolCall.function.arguments\n        };\n      }),\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      logprobs: mapOpenAIChatLogProbsOutput(choice.logprobs)\n    };\n  }\n  async doStream(options) {\n    const { args, warnings } = this.getArgs(options);\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? { include_usage: true } : void 0\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createEventSourceResponseHandler)(\n        openaiChatChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { messages: rawPrompt, ...rawSettings } = args;\n    const toolCalls = [];\n    let finishReason = \"other\";\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    let logprobs;\n    const { useLegacyFunctionCalling } = this.settings;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens\n              };\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.delta) == null) {\n              return;\n            }\n            const delta = choice.delta;\n            if (delta.content != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: delta.content\n              });\n            }\n            const mappedLogprobs = mapOpenAIChatLogProbsOutput(\n              choice == null ? void 0 : choice.logprobs\n            );\n            if (mappedLogprobs == null ? void 0 : mappedLogprobs.length) {\n              if (logprobs === void 0) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n            const mappedToolCalls = useLegacyFunctionCalling && delta.function_call != null ? [\n              {\n                type: \"function\",\n                id: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                function: delta.function_call,\n                index: 0\n              }\n            ] : delta.tool_calls;\n            if (mappedToolCalls != null) {\n              for (const toolCallDelta of mappedToolCalls) {\n                const index = toolCallDelta.index;\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== \"function\") {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`\n                    });\n                  }\n                  if (toolCallDelta.id == null) {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`\n                    });\n                  }\n                  if (((_a = toolCallDelta.function) == null ? void 0 : _a.name) == null) {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`\n                    });\n                  }\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: \"function\",\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: (_b = toolCallDelta.function.arguments) != null ? _b : \"\"\n                    }\n                  };\n                  const toolCall2 = toolCalls[index];\n                  if (((_c = toolCall2.function) == null ? void 0 : _c.name) != null && ((_d = toolCall2.function) == null ? void 0 : _d.arguments) != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isParsableJson)(toolCall2.function.arguments)) {\n                    controller.enqueue({\n                      type: \"tool-call-delta\",\n                      toolCallType: \"function\",\n                      toolCallId: toolCall2.id,\n                      toolName: toolCall2.function.name,\n                      argsTextDelta: toolCall2.function.arguments\n                    });\n                    controller.enqueue({\n                      type: \"tool-call\",\n                      toolCallType: \"function\",\n                      toolCallId: (_e = toolCall2.id) != null ? _e : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                      toolName: toolCall2.function.name,\n                      args: toolCall2.function.arguments\n                    });\n                  }\n                  continue;\n                }\n                const toolCall = toolCalls[index];\n                if (((_f = toolCallDelta.function) == null ? void 0 : _f.arguments) != null) {\n                  toolCall.function.arguments += (_h = (_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null ? _h : \"\";\n                }\n                controller.enqueue({\n                  type: \"tool-call-delta\",\n                  toolCallType: \"function\",\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: (_i = toolCallDelta.function.arguments) != null ? _i : \"\"\n                });\n                if (((_j = toolCall.function) == null ? void 0 : _j.name) != null && ((_k = toolCall.function) == null ? void 0 : _k.arguments) != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isParsableJson)(toolCall.function.arguments)) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallType: \"function\",\n                    toolCallId: (_l = toolCall.id) != null ? _l : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments\n                  });\n                }\n              }\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              logprobs,\n              usage\n            });\n          }\n        })\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings\n    };\n  }\n};\nvar openAIChatResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      message: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        role: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"assistant\").nullish(),\n        content: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n        function_call: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n          name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n        }).nullish(),\n        tool_calls: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n          zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n            id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n            type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"function\"),\n            function: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n              name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n              arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n            })\n          })\n        ).nullish()\n      }),\n      index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n      logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        content: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n          zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n            token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n            logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n            top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n              zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n              })\n            )\n          })\n        ).nullable()\n      }).nullish(),\n      finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish()\n    })\n  ),\n  usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n    completion_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n  })\n});\nvar openaiChatChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.union([\n  zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n      zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        delta: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          role: zod__WEBPACK_IMPORTED_MODULE_2__.z.enum([\"assistant\"]).nullish(),\n          content: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n          function_call: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n            name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().optional(),\n            arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().optional()\n          }).nullish(),\n          tool_calls: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n            zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n              index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n              id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n              type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"function\").optional(),\n              function: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n                arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish()\n              })\n            })\n          ).nullish()\n        }).nullish(),\n        logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          content: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n            zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n              token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n              logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n              top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n                zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                  token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                  logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n                })\n              )\n            })\n          ).nullable()\n        }).nullish(),\n        finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullable().optional(),\n        index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n      })\n    ),\n    usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n      completion_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n    }).nullish()\n  }),\n  openAIErrorDataSchema\n]);\nfunction prepareToolsAndToolChoice({\n  mode,\n  useLegacyFunctionCalling = false,\n  structuredOutputs = false\n}) {\n  var _a;\n  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;\n  if (tools == null) {\n    return { tools: void 0, tool_choice: void 0 };\n  }\n  const toolChoice = mode.toolChoice;\n  if (useLegacyFunctionCalling) {\n    const mappedFunctions = tools.map((tool) => ({\n      name: tool.name,\n      description: tool.description,\n      parameters: tool.parameters\n    }));\n    if (toolChoice == null) {\n      return { functions: mappedFunctions, function_call: void 0 };\n    }\n    const type2 = toolChoice.type;\n    switch (type2) {\n      case \"auto\":\n      case \"none\":\n      case void 0:\n        return {\n          functions: mappedFunctions,\n          function_call: void 0\n        };\n      case \"required\":\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"useLegacyFunctionCalling and toolChoice: required\"\n        });\n      default:\n        return {\n          functions: mappedFunctions,\n          function_call: { name: toolChoice.toolName }\n        };\n    }\n  }\n  const mappedTools = tools.map((tool) => ({\n    type: \"function\",\n    function: {\n      name: tool.name,\n      description: tool.description,\n      parameters: tool.parameters\n    },\n    strict: structuredOutputs === true ? true : void 0\n  }));\n  if (toolChoice == null) {\n    return { tools: mappedTools, tool_choice: void 0 };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return { tools: mappedTools, tool_choice: type };\n    case \"tool\":\n      return {\n        tools: mappedTools,\n        tool_choice: {\n          type: \"function\",\n          function: {\n            name: toolChoice.toolName\n          }\n        }\n      };\n    default: {\n      const _exhaustiveCheck = type;\n      throw new Error(`Unsupported tool choice type: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/openai-completion-language-model.ts\n\n\n\n\n// src/convert-to-openai-completion-prompt.ts\n\nfunction convertToOpenAICompletionPrompt({\n  prompt,\n  inputFormat,\n  user = \"user\",\n  assistant = \"assistant\"\n}) {\n  if (inputFormat === \"prompt\" && prompt.length === 1 && prompt[0].role === \"user\" && prompt[0].content.length === 1 && prompt[0].content[0].type === \"text\") {\n    return { prompt: prompt[0].content[0].text };\n  }\n  let text = \"\";\n  if (prompt[0].role === \"system\") {\n    text += `${prompt[0].content}\n\n`;\n    prompt = prompt.slice(1);\n  }\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n          message: \"Unexpected system message in prompt: ${content}\",\n          prompt\n        });\n      }\n      case \"user\": {\n        const userMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"image\": {\n              throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"images\"\n              });\n            }\n          }\n        }).join(\"\");\n        text += `${user}:\n${userMessage}\n\n`;\n        break;\n      }\n      case \"assistant\": {\n        const assistantMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"tool-call\": {\n              throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"tool-call messages\"\n              });\n            }\n          }\n        }).join(\"\");\n        text += `${assistant}:\n${assistantMessage}\n\n`;\n        break;\n      }\n      case \"tool\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"tool messages\"\n        });\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  text += `${assistant}:\n`;\n  return {\n    prompt: text,\n    stopSequences: [`\n${user}:`]\n  };\n}\n\n// src/map-openai-completion-logprobs.ts\nfunction mapOpenAICompletionLogProbs(logprobs) {\n  return logprobs == null ? void 0 : logprobs.tokens.map((token, index) => ({\n    token,\n    logprob: logprobs.token_logprobs[index],\n    topLogprobs: logprobs.top_logprobs ? Object.entries(logprobs.top_logprobs[index]).map(\n      ([token2, logprob]) => ({\n        token: token2,\n        logprob\n      })\n    ) : []\n  }));\n}\n\n// src/openai-completion-language-model.ts\nvar OpenAICompletionLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = void 0;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  getArgs({\n    mode,\n    inputFormat,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    seed\n  }) {\n    var _a;\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type !== \"text\") {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format is not supported.\"\n      });\n    }\n    const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt, inputFormat });\n    const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      echo: this.settings.echo,\n      logit_bias: this.settings.logitBias,\n      logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      // prompt:\n      prompt: completionPrompt,\n      // stop sequences:\n      stop: stop.length > 0 ? stop : void 0\n    };\n    switch (type) {\n      case \"regular\": {\n        if ((_a = mode.tools) == null ? void 0 : _a.length) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n            functionality: \"tools\"\n          });\n        }\n        if (mode.toolChoice) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n            functionality: \"toolChoice\"\n          });\n        }\n        return { args: baseArgs, warnings };\n      }\n      case \"object-json\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"object-json mode\"\n        });\n      }\n      case \"object-tool\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"object-tool mode\"\n        });\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  async doGenerate(options) {\n    const { args, warnings } = this.getArgs(options);\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openAICompletionResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n    return {\n      text: choice.text,\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens\n      },\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      logprobs: mapOpenAICompletionLogProbs(choice.logprobs),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings\n    };\n  }\n  async doStream(options) {\n    const { args, warnings } = this.getArgs(options);\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? { include_usage: true } : void 0\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createEventSourceResponseHandler)(\n        openaiCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    let finishReason = \"other\";\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    let logprobs;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens\n              };\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.text) != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: choice.text\n              });\n            }\n            const mappedLogprobs = mapOpenAICompletionLogProbs(\n              choice == null ? void 0 : choice.logprobs\n            );\n            if (mappedLogprobs == null ? void 0 : mappedLogprobs.length) {\n              if (logprobs === void 0) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              logprobs,\n              usage\n            });\n          }\n        })\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings\n    };\n  }\n};\nvar openAICompletionResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      text: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.string()),\n        token_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.number()),\n        top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.record(zod__WEBPACK_IMPORTED_MODULE_2__.z.string(), zod__WEBPACK_IMPORTED_MODULE_2__.z.number())).nullable()\n      }).nullable().optional()\n    })\n  ),\n  usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n    completion_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n  })\n});\nvar openaiCompletionChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.union([\n  zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n      zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        text: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n        finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n        index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n        logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.string()),\n          token_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.number()),\n          top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.record(zod__WEBPACK_IMPORTED_MODULE_2__.z.string(), zod__WEBPACK_IMPORTED_MODULE_2__.z.number())).nullable()\n        }).nullable().optional()\n      })\n    ),\n    usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n      completion_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n    }).optional().nullable()\n  }),\n  openAIErrorDataSchema\n]);\n\n// src/openai-facade.ts\nvar OpenAI = class {\n  /**\n   * Creates a new OpenAI provider instance.\n   */\n  constructor(options = {}) {\n    var _a, _b;\n    this.baseURL = (_b = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.withoutTrailingSlash)((_a = options.baseURL) != null ? _a : options.baseUrl)) != null ? _b : \"https://api.openai.com/v1\";\n    this.apiKey = options.apiKey;\n    this.organization = options.organization;\n    this.project = options.project;\n    this.headers = options.headers;\n  }\n  get baseConfig() {\n    return {\n      organization: this.organization,\n      baseURL: this.baseURL,\n      headers: () => ({\n        Authorization: `Bearer ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.loadApiKey)({\n          apiKey: this.apiKey,\n          environmentVariableName: \"OPENAI_API_KEY\",\n          description: \"OpenAI\"\n        })}`,\n        \"OpenAI-Organization\": this.organization,\n        \"OpenAI-Project\": this.project,\n        ...this.headers\n      })\n    };\n  }\n  chat(modelId, settings = {}) {\n    return new OpenAIChatLanguageModel(modelId, settings, {\n      provider: \"openai.chat\",\n      ...this.baseConfig,\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    });\n  }\n  completion(modelId, settings = {}) {\n    return new OpenAICompletionLanguageModel(modelId, settings, {\n      provider: \"openai.completion\",\n      ...this.baseConfig,\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    });\n  }\n};\n\n// src/openai-provider.ts\n\n\n// src/openai-embedding-model.ts\n\n\n\nvar OpenAIEmbeddingModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get maxEmbeddingsPerCall() {\n    var _a;\n    return (_a = this.settings.maxEmbeddingsPerCall) != null ? _a : 2048;\n  }\n  get supportsParallelCalls() {\n    var _a;\n    return (_a = this.settings.supportsParallelCalls) != null ? _a : true;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal\n  }) {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values\n      });\n    }\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/embeddings\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: \"float\",\n        dimensions: this.settings.dimensions,\n        user: this.settings.user\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openaiTextEmbeddingResponseSchema\n      ),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      embeddings: response.data.map((item) => item.embedding),\n      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,\n      rawResponse: { headers: responseHeaders }\n    };\n  }\n};\nvar openaiTextEmbeddingResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  data: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ embedding: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.number()) })),\n  usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number() }).nullish()\n});\n\n// src/openai-provider.ts\nfunction createOpenAI(options = {}) {\n  var _a, _b, _c;\n  const baseURL = (_b = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.withoutTrailingSlash)((_a = options.baseURL) != null ? _a : options.baseUrl)) != null ? _b : \"https://api.openai.com/v1\";\n  const compatibility = (_c = options.compatibility) != null ? _c : \"compatible\";\n  const getHeaders = () => ({\n    Authorization: `Bearer ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.loadApiKey)({\n      apiKey: options.apiKey,\n      environmentVariableName: \"OPENAI_API_KEY\",\n      description: \"OpenAI\"\n    })}`,\n    \"OpenAI-Organization\": options.organization,\n    \"OpenAI-Project\": options.project,\n    ...options.headers\n  });\n  const createChatModel = (modelId, settings = {}) => new OpenAIChatLanguageModel(modelId, settings, {\n    provider: \"openai.chat\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch\n  });\n  const createCompletionModel = (modelId, settings = {}) => new OpenAICompletionLanguageModel(modelId, settings, {\n    provider: \"openai.completion\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch\n  });\n  const createEmbeddingModel = (modelId, settings = {}) => new OpenAIEmbeddingModel(modelId, settings, {\n    provider: \"openai.embedding\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createLanguageModel = (modelId, settings) => {\n    if (new.target) {\n      throw new Error(\n        \"The OpenAI model function cannot be called with the new keyword.\"\n      );\n    }\n    if (modelId === \"gpt-3.5-turbo-instruct\") {\n      return createCompletionModel(\n        modelId,\n        settings\n      );\n    }\n    return createChatModel(modelId, settings);\n  };\n  const provider = function(modelId, settings) {\n    return createLanguageModel(modelId, settings);\n  };\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  return provider;\n}\nvar openai = createOpenAI({\n  compatibility: \"strict\"\n  // strict for OpenAI API\n});\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9vcGVuYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDMEU7O0FBRTFFO0FBSTBCO0FBUU07QUFDRjs7QUFFOUI7QUFHMEI7QUFDeUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixrREFBa0QsU0FBUyxpRkFBeUIsYUFBYTtBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQTZCO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0dB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3Vuc2VsbGluZy10aHJvdWdoLWJpYmxlLWZ1bGxzdGFjay8uL25vZGVfbW9kdWxlcy9AYWktc2RrL29wZW5haS9kaXN0L2luZGV4Lm1qcz9iYjkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9vcGVuYWktZmFjYWRlLnRzXG5pbXBvcnQgeyBsb2FkQXBpS2V5LCB3aXRob3V0VHJhaWxpbmdTbGFzaCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9vcGVuYWktY2hhdC1sYW5ndWFnZS1tb2RlbC50c1xuaW1wb3J0IHtcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbWJpbmVIZWFkZXJzLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgZ2VuZXJhdGVJZCxcbiAgaXNQYXJzYWJsZUpzb24sXG4gIHBvc3RKc29uVG9BcGlcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG5cbi8vIHNyYy9jb252ZXJ0LXRvLW9wZW5haS1jaGF0LW1lc3NhZ2VzLnRzXG5pbXBvcnQge1xuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjb252ZXJ0VG9PcGVuQUlDaGF0TWVzc2FnZXMoe1xuICBwcm9tcHQsXG4gIHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIGZvciAoY29uc3QgeyByb2xlLCBjb250ZW50IH0gb2YgcHJvbXB0KSB7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgbWVzc2FnZXMucHVzaCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDEgJiYgY29udGVudFswXS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogY29udGVudFswXS50ZXh0IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHBhcnQudGV4dCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMID8gcGFydC5pbWFnZS50b1N0cmluZygpIDogYGRhdGE6JHsoX2EgPSBwYXJ0Lm1pbWVUeXBlKSAhPSBudWxsID8gX2EgOiBcImltYWdlL2pwZWdcIn07YmFzZTY0LCR7Y29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChwYXJ0LmltYWdlKX1gXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KHBhcnQuYXJncylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHBhcnQ7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nKSB7XG4gICAgICAgICAgaWYgKHRvb2xDYWxscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyB3aXRoIG11bHRpcGxlIHRvb2wgY2FsbHMgaW4gb25lIG1lc3NhZ2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IHRvb2xDYWxsc1swXS5mdW5jdGlvbiA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IHRvb2xDYWxscyA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xSZXNwb25zZSBvZiBjb250ZW50KSB7XG4gICAgICAgICAgaWYgKHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgbmFtZTogdG9vbFJlc3BvbnNlLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sUmVzcG9uc2UucmVzdWx0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0b29sUmVzcG9uc2UudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbFJlc3BvbnNlLnJlc3VsdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWVzc2FnZXM7XG59XG5cbi8vIHNyYy9tYXAtb3BlbmFpLWNoYXQtbG9ncHJvYnMudHNcbmZ1bmN0aW9uIG1hcE9wZW5BSUNoYXRMb2dQcm9ic091dHB1dChsb2dwcm9icykge1xuICB2YXIgX2EsIF9iO1xuICByZXR1cm4gKF9iID0gKF9hID0gbG9ncHJvYnMgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ3Byb2JzLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXAoKHsgdG9rZW4sIGxvZ3Byb2IsIHRvcF9sb2dwcm9icyB9KSA9PiAoe1xuICAgIHRva2VuLFxuICAgIGxvZ3Byb2IsXG4gICAgdG9wTG9ncHJvYnM6IHRvcF9sb2dwcm9icyA/IHRvcF9sb2dwcm9icy5tYXAoKHsgdG9rZW46IHRva2VuMiwgbG9ncHJvYjogbG9ncHJvYjIgfSkgPT4gKHtcbiAgICAgIHRva2VuOiB0b2tlbjIsXG4gICAgICBsb2dwcm9iOiBsb2dwcm9iMlxuICAgIH0pKSA6IFtdXG4gIH0pKSkgIT0gbnVsbCA/IF9iIDogdm9pZCAwO1xufVxuXG4vLyBzcmMvbWFwLW9wZW5haS1maW5pc2gtcmVhc29uLnRzXG5mdW5jdGlvbiBtYXBPcGVuQUlGaW5pc2hSZWFzb24oZmluaXNoUmVhc29uKSB7XG4gIHN3aXRjaCAoZmluaXNoUmVhc29uKSB7XG4gICAgY2FzZSBcInN0b3BcIjpcbiAgICAgIHJldHVybiBcInN0b3BcIjtcbiAgICBjYXNlIFwibGVuZ3RoXCI6XG4gICAgICByZXR1cm4gXCJsZW5ndGhcIjtcbiAgICBjYXNlIFwiY29udGVudF9maWx0ZXJcIjpcbiAgICAgIHJldHVybiBcImNvbnRlbnQtZmlsdGVyXCI7XG4gICAgY2FzZSBcImZ1bmN0aW9uX2NhbGxcIjpcbiAgICBjYXNlIFwidG9vbF9jYWxsc1wiOlxuICAgICAgcmV0dXJuIFwidG9vbC1jYWxsc1wiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cbn1cblxuLy8gc3JjL29wZW5haS1lcnJvci50c1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7IGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgb3BlbkFJRXJyb3JEYXRhU2NoZW1hID0gei5vYmplY3Qoe1xuICBlcnJvcjogei5vYmplY3Qoe1xuICAgIG1lc3NhZ2U6IHouc3RyaW5nKCksXG4gICAgdHlwZTogei5zdHJpbmcoKSxcbiAgICBwYXJhbTogei5hbnkoKS5udWxsYWJsZSgpLFxuICAgIGNvZGU6IHouc3RyaW5nKCkubnVsbGFibGUoKVxuICB9KVxufSk7XG52YXIgb3BlbmFpRmFpbGVkUmVzcG9uc2VIYW5kbGVyID0gY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyKHtcbiAgZXJyb3JTY2hlbWE6IG9wZW5BSUVycm9yRGF0YVNjaGVtYSxcbiAgZXJyb3JUb01lc3NhZ2U6IChkYXRhKSA9PiBkYXRhLmVycm9yLm1lc3NhZ2Vcbn0pO1xuXG4vLyBzcmMvb3BlbmFpLWNoYXQtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciBPcGVuQUlDaGF0TGFuZ3VhZ2VNb2RlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobW9kZWxJZCwgc2V0dGluZ3MsIGNvbmZpZykge1xuICAgIHRoaXMuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYxXCI7XG4gICAgdGhpcy5tb2RlbElkID0gbW9kZWxJZDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgZ2V0IHN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Muc3RydWN0dXJlZE91dHB1dHMgPT09IHRydWU7XG4gIH1cbiAgZ2V0IGRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gXCJqc29uXCIgOiBcInRvb2xcIjtcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIG1vZGUsXG4gICAgcHJvbXB0LFxuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlcyxcbiAgICByZXNwb25zZUZvcm1hdCxcbiAgICBzZWVkXG4gIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHlwZSA9IG1vZGUudHlwZTtcbiAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIixcbiAgICAgICAgc2V0dGluZzogXCJ0b3BLXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VGb3JtYXQgIT0gbnVsbCAmJiByZXNwb25zZUZvcm1hdC50eXBlID09PSBcImpzb25cIiAmJiByZXNwb25zZUZvcm1hdC5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidW5zdXBwb3J0ZWQtc2V0dGluZ1wiLFxuICAgICAgICBzZXR0aW5nOiBcInJlc3BvbnNlRm9ybWF0XCIsXG4gICAgICAgIGRldGFpbHM6IFwiSlNPTiByZXNwb25zZSBmb3JtYXQgc2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyA9IHRoaXMuc2V0dGluZ3MudXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nO1xuICAgIGlmICh1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgJiYgdGhpcy5zZXR0aW5ncy5wYXJhbGxlbFRvb2xDYWxscyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nIHdpdGggcGFyYWxsZWxUb29sQ2FsbHNcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgJiYgdGhpcy5zZXR0aW5ncy5zdHJ1Y3R1cmVkT3V0cHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwic3RydWN0dXJlZE91dHB1dHMgd2l0aCB1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VBcmdzID0ge1xuICAgICAgLy8gbW9kZWwgaWQ6XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbElkLFxuICAgICAgLy8gbW9kZWwgc3BlY2lmaWMgc2V0dGluZ3M6XG4gICAgICBsb2dpdF9iaWFzOiB0aGlzLnNldHRpbmdzLmxvZ2l0QmlhcyxcbiAgICAgIGxvZ3Byb2JzOiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSB0cnVlIHx8IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcIm51bWJlclwiID8gdHJ1ZSA6IHZvaWQgMCxcbiAgICAgIHRvcF9sb2dwcm9iczogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwibnVtYmVyXCIgPyB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzIDogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwiYm9vbGVhblwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA/IDAgOiB2b2lkIDAgOiB2b2lkIDAsXG4gICAgICB1c2VyOiB0aGlzLnNldHRpbmdzLnVzZXIsXG4gICAgICBwYXJhbGxlbF90b29sX2NhbGxzOiB0aGlzLnNldHRpbmdzLnBhcmFsbGVsVG9vbENhbGxzLFxuICAgICAgLy8gc3RhbmRhcmRpemVkIHNldHRpbmdzOlxuICAgICAgbWF4X3Rva2VuczogbWF4VG9rZW5zLFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICB0b3BfcDogdG9wUCxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgc3RvcDogc3RvcFNlcXVlbmNlcyxcbiAgICAgIHNlZWQsXG4gICAgICAvLyByZXNwb25zZSBmb3JtYXQ6XG4gICAgICByZXNwb25zZV9mb3JtYXQ6IChyZXNwb25zZUZvcm1hdCA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2VGb3JtYXQudHlwZSkgPT09IFwianNvblwiID8geyB0eXBlOiBcImpzb25fb2JqZWN0XCIgfSA6IHZvaWQgMCxcbiAgICAgIC8vIG1lc3NhZ2VzOlxuICAgICAgbWVzc2FnZXM6IGNvbnZlcnRUb09wZW5BSUNoYXRNZXNzYWdlcyh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgdXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nXG4gICAgICB9KVxuICAgIH07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwicmVndWxhclwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgLi4uYmFzZUFyZ3MsXG4gICAgICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgdXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nLFxuICAgICAgICAgICAgICBzdHJ1Y3R1cmVkT3V0cHV0czogdGhpcy5zZXR0aW5ncy5zdHJ1Y3R1cmVkT3V0cHV0c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhcm5pbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0LWpzb25cIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgIC4uLmJhc2VBcmdzLFxuICAgICAgICAgICAgcmVzcG9uc2VfZm9ybWF0OiB0aGlzLnNldHRpbmdzLnN0cnVjdHVyZWRPdXRwdXRzID09PSB0cnVlID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImpzb25fc2NoZW1hXCIsXG4gICAgICAgICAgICAgIGpzb25fc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBtb2RlLnNjaGVtYSxcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgbmFtZTogKF9hID0gbW9kZS5uYW1lKSAhPSBudWxsID8gX2EgOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1vZGUuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJqc29uX29iamVjdFwiIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhcm5pbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0LXRvb2xcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyA/IHtcbiAgICAgICAgICAgIC4uLmJhc2VBcmdzLFxuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDoge1xuICAgICAgICAgICAgICBuYW1lOiBtb2RlLnRvb2wubmFtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogbW9kZS50b29sLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1vZGUudG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBtb2RlLnRvb2wucGFyYW1ldGVyc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIC4uLmJhc2VBcmdzLFxuICAgICAgICAgICAgdG9vbF9jaG9pY2U6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICBmdW5jdGlvbjogeyBuYW1lOiBtb2RlLnRvb2wubmFtZSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogbW9kZS50b29sLm5hbWUsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbW9kZS50b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogbW9kZS50b29sLnBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cmljdDogdGhpcy5zZXR0aW5ncy5zdHJ1Y3R1cmVkT3V0cHV0cyA9PT0gdHJ1ZSA/IHRydWUgOiB2b2lkIDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FybmluZ3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkb0dlbmVyYXRlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgYXJncywgd2FybmluZ3MgfSA9IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7IHJlc3BvbnNlSGVhZGVycywgdmFsdWU6IHJlc3BvbnNlIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keTogYXJncyxcbiAgICAgIGZhaWxlZFJlc3BvbnNlSGFuZGxlcjogb3BlbmFpRmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcihcbiAgICAgICAgb3BlbkFJQ2hhdFJlc3BvbnNlU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB7IG1lc3NhZ2VzOiByYXdQcm9tcHQsIC4uLnJhd1NldHRpbmdzIH0gPSBhcmdzO1xuICAgIGNvbnN0IGNob2ljZSA9IHJlc3BvbnNlLmNob2ljZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IChfYSA9IGNob2ljZS5tZXNzYWdlLmNvbnRlbnQpICE9IG51bGwgPyBfYSA6IHZvaWQgMCxcbiAgICAgIHRvb2xDYWxsczogdGhpcy5zZXR0aW5ncy51c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgJiYgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA/IFtcbiAgICAgICAge1xuICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICB0b29sTmFtZTogY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgIGFyZ3M6IGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzXG4gICAgICAgIH1cbiAgICAgIF0gOiAoX2IgPSBjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWFwKCh0b29sQ2FsbCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IChfYTIgPSB0b29sQ2FsbC5pZCkgIT0gbnVsbCA/IF9hMiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgZmluaXNoUmVhc29uOiBtYXBPcGVuQUlGaW5pc2hSZWFzb24oY2hvaWNlLmZpbmlzaF9yZWFzb24pLFxuICAgICAgdXNhZ2U6IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiByZXNwb25zZS51c2FnZS5wcm9tcHRfdG9rZW5zLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiByZXNwb25zZS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1xuICAgICAgfSxcbiAgICAgIHJhd0NhbGw6IHsgcmF3UHJvbXB0LCByYXdTZXR0aW5ncyB9LFxuICAgICAgcmF3UmVzcG9uc2U6IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzIH0sXG4gICAgICB3YXJuaW5ncyxcbiAgICAgIGxvZ3Byb2JzOiBtYXBPcGVuQUlDaGF0TG9nUHJvYnNPdXRwdXQoY2hvaWNlLmxvZ3Byb2JzKVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZG9TdHJlYW0ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXJncywgd2FybmluZ3MgfSA9IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7IHJlc3BvbnNlSGVhZGVycywgdmFsdWU6IHJlc3BvbnNlIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keToge1xuICAgICAgICAuLi5hcmdzLFxuICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgIC8vIG9ubHkgaW5jbHVkZSBzdHJlYW1fb3B0aW9ucyB3aGVuIGluIHN0cmljdCBjb21wYXRpYmlsaXR5IG1vZGU6XG4gICAgICAgIHN0cmVhbV9vcHRpb25zOiB0aGlzLmNvbmZpZy5jb21wYXRpYmlsaXR5ID09PSBcInN0cmljdFwiID8geyBpbmNsdWRlX3VzYWdlOiB0cnVlIH0gOiB2b2lkIDBcbiAgICAgIH0sXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5haUZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBvcGVuYWlDaGF0Q2h1bmtTY2hlbWFcbiAgICAgICksXG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgIH0pO1xuICAgIGNvbnN0IHsgbWVzc2FnZXM6IHJhd1Byb21wdCwgLi4ucmF3U2V0dGluZ3MgfSA9IGFyZ3M7XG4gICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgbGV0IGZpbmlzaFJlYXNvbiA9IFwib3RoZXJcIjtcbiAgICBsZXQgdXNhZ2UgPSB7XG4gICAgICBwcm9tcHRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICBjb21wbGV0aW9uVG9rZW5zOiBOdW1iZXIuTmFOXG4gICAgfTtcbiAgICBsZXQgbG9ncHJvYnM7XG4gICAgY29uc3QgeyB1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgfSA9IHRoaXMuc2V0dGluZ3M7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogcmVzcG9uc2UucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2w7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiB2YWx1ZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdXNhZ2UgPSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaG9pY2UgPSB2YWx1ZS5jaG9pY2VzWzBdO1xuICAgICAgICAgICAgaWYgKChjaG9pY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGNob2ljZS5maW5pc2hfcmVhc29uKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IG1hcE9wZW5BSUZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmRlbHRhKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gY2hvaWNlLmRlbHRhO1xuICAgICAgICAgICAgaWYgKGRlbHRhLmNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRleHREZWx0YTogZGVsdGEuY29udGVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZExvZ3Byb2JzID0gbWFwT3BlbkFJQ2hhdExvZ1Byb2JzT3V0cHV0KFxuICAgICAgICAgICAgICBjaG9pY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGNob2ljZS5sb2dwcm9ic1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChtYXBwZWRMb2dwcm9icyA9PSBudWxsID8gdm9pZCAwIDogbWFwcGVkTG9ncHJvYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChsb2dwcm9icyA9PT0gdm9pZCAwKSBsb2dwcm9icyA9IFtdO1xuICAgICAgICAgICAgICBsb2dwcm9icy5wdXNoKC4uLm1hcHBlZExvZ3Byb2JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFRvb2xDYWxscyA9IHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyAmJiBkZWx0YS5mdW5jdGlvbl9jYWxsICE9IG51bGwgPyBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogZGVsdGEuZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdIDogZGVsdGEudG9vbF9jYWxscztcbiAgICAgICAgICAgIGlmIChtYXBwZWRUb29sQ2FsbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsRGVsdGEgb2YgbWFwcGVkVG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0b29sQ2FsbERlbHRhLmluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbHNbaW5kZXhdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbERlbHRhLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0b29sQ2FsbERlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAnZnVuY3Rpb24nIHR5cGUuYFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbERlbHRhLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXNwb25zZURhdGFFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogdG9vbENhbGxEZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJ2lkJyB0byBiZSBhIHN0cmluZy5gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0b29sQ2FsbERlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAnZnVuY3Rpb24ubmFtZScgdG8gYmUgYSBzdHJpbmcuYFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsc1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbERlbHRhLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGxEZWx0YS5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogKF9iID0gdG9vbENhbGxEZWx0YS5mdW5jdGlvbi5hcmd1bWVudHMpICE9IG51bGwgPyBfYiA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsMiA9IHRvb2xDYWxsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAoKChfYyA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm5hbWUpICE9IG51bGwgJiYgKChfZCA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFyZ3VtZW50cykgIT0gbnVsbCAmJiBpc1BhcnNhYmxlSnNvbih0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiB0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogKF9lID0gdG9vbENhbGwyLmlkKSAhPSBudWxsID8gX2UgOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsMi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRvb2xDYWxsMi5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSB0b29sQ2FsbHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICgoKF9mID0gdG9vbENhbGxEZWx0YS5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmFyZ3VtZW50cykgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzICs9IChfaCA9IChfZyA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZy5hcmd1bWVudHMpICE9IG51bGwgPyBfaCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogKF9pID0gdG9vbENhbGxEZWx0YS5mdW5jdGlvbi5hcmd1bWVudHMpICE9IG51bGwgPyBfaSA6IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoKChfaiA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2oubmFtZSkgIT0gbnVsbCAmJiAoKF9rID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfay5hcmd1bWVudHMpICE9IG51bGwgJiYgaXNQYXJzYWJsZUpzb24odG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IChfbCA9IHRvb2xDYWxsLmlkKSAhPSBudWxsID8gX2wgOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgICAgICAgdXNhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICByYXdDYWxsOiB7IHJhd1Byb21wdCwgcmF3U2V0dGluZ3MgfSxcbiAgICAgIHJhd1Jlc3BvbnNlOiB7IGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyB9LFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG59O1xudmFyIG9wZW5BSUNoYXRSZXNwb25zZVNjaGVtYSA9IHoyLm9iamVjdCh7XG4gIGNob2ljZXM6IHoyLmFycmF5KFxuICAgIHoyLm9iamVjdCh7XG4gICAgICBtZXNzYWdlOiB6Mi5vYmplY3Qoe1xuICAgICAgICByb2xlOiB6Mi5saXRlcmFsKFwiYXNzaXN0YW50XCIpLm51bGxpc2goKSxcbiAgICAgICAgY29udGVudDogejIuc3RyaW5nKCkubnVsbGlzaCgpLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB6Mi5vYmplY3Qoe1xuICAgICAgICAgIGFyZ3VtZW50czogejIuc3RyaW5nKCksXG4gICAgICAgICAgbmFtZTogejIuc3RyaW5nKClcbiAgICAgICAgfSkubnVsbGlzaCgpLFxuICAgICAgICB0b29sX2NhbGxzOiB6Mi5hcnJheShcbiAgICAgICAgICB6Mi5vYmplY3Qoe1xuICAgICAgICAgICAgaWQ6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICAgIHR5cGU6IHoyLmxpdGVyYWwoXCJmdW5jdGlvblwiKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB6Mi5vYmplY3Qoe1xuICAgICAgICAgICAgICBuYW1lOiB6Mi5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiB6Mi5zdHJpbmcoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApLm51bGxpc2goKVxuICAgICAgfSksXG4gICAgICBpbmRleDogejIubnVtYmVyKCksXG4gICAgICBsb2dwcm9iczogejIub2JqZWN0KHtcbiAgICAgICAgY29udGVudDogejIuYXJyYXkoXG4gICAgICAgICAgejIub2JqZWN0KHtcbiAgICAgICAgICAgIHRva2VuOiB6Mi5zdHJpbmcoKSxcbiAgICAgICAgICAgIGxvZ3Byb2I6IHoyLm51bWJlcigpLFxuICAgICAgICAgICAgdG9wX2xvZ3Byb2JzOiB6Mi5hcnJheShcbiAgICAgICAgICAgICAgejIub2JqZWN0KHtcbiAgICAgICAgICAgICAgICB0b2tlbjogejIuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbG9ncHJvYjogejIubnVtYmVyKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICApLm51bGxhYmxlKClcbiAgICAgIH0pLm51bGxpc2goKSxcbiAgICAgIGZpbmlzaF9yZWFzb246IHoyLnN0cmluZygpLm51bGxpc2goKVxuICAgIH0pXG4gICksXG4gIHVzYWdlOiB6Mi5vYmplY3Qoe1xuICAgIHByb21wdF90b2tlbnM6IHoyLm51bWJlcigpLFxuICAgIGNvbXBsZXRpb25fdG9rZW5zOiB6Mi5udW1iZXIoKVxuICB9KVxufSk7XG52YXIgb3BlbmFpQ2hhdENodW5rU2NoZW1hID0gejIudW5pb24oW1xuICB6Mi5vYmplY3Qoe1xuICAgIGNob2ljZXM6IHoyLmFycmF5KFxuICAgICAgejIub2JqZWN0KHtcbiAgICAgICAgZGVsdGE6IHoyLm9iamVjdCh7XG4gICAgICAgICAgcm9sZTogejIuZW51bShbXCJhc3Npc3RhbnRcIl0pLm51bGxpc2goKSxcbiAgICAgICAgICBjb250ZW50OiB6Mi5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgZnVuY3Rpb25fY2FsbDogejIub2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IHoyLnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBhcmd1bWVudHM6IHoyLnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICB9KS5udWxsaXNoKCksXG4gICAgICAgICAgdG9vbF9jYWxsczogejIuYXJyYXkoXG4gICAgICAgICAgICB6Mi5vYmplY3Qoe1xuICAgICAgICAgICAgICBpbmRleDogejIubnVtYmVyKCksXG4gICAgICAgICAgICAgIGlkOiB6Mi5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgICAgIHR5cGU6IHoyLmxpdGVyYWwoXCJmdW5jdGlvblwiKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBmdW5jdGlvbjogejIub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiB6Mi5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiB6Mi5zdHJpbmcoKS5udWxsaXNoKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5udWxsaXNoKClcbiAgICAgICAgfSkubnVsbGlzaCgpLFxuICAgICAgICBsb2dwcm9iczogejIub2JqZWN0KHtcbiAgICAgICAgICBjb250ZW50OiB6Mi5hcnJheShcbiAgICAgICAgICAgIHoyLm9iamVjdCh7XG4gICAgICAgICAgICAgIHRva2VuOiB6Mi5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgbG9ncHJvYjogejIubnVtYmVyKCksXG4gICAgICAgICAgICAgIHRvcF9sb2dwcm9iczogejIuYXJyYXkoXG4gICAgICAgICAgICAgICAgejIub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgIHRva2VuOiB6Mi5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIGxvZ3Byb2I6IHoyLm51bWJlcigpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLm51bGxhYmxlKClcbiAgICAgICAgfSkubnVsbGlzaCgpLFxuICAgICAgICBmaW5pc2hfcmVhc29uOiB6Mi5zdHJpbmcoKS5udWxsYWJsZSgpLm9wdGlvbmFsKCksXG4gICAgICAgIGluZGV4OiB6Mi5udW1iZXIoKVxuICAgICAgfSlcbiAgICApLFxuICAgIHVzYWdlOiB6Mi5vYmplY3Qoe1xuICAgICAgcHJvbXB0X3Rva2VuczogejIubnVtYmVyKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2VuczogejIubnVtYmVyKClcbiAgICB9KS5udWxsaXNoKClcbiAgfSksXG4gIG9wZW5BSUVycm9yRGF0YVNjaGVtYVxuXSk7XG5mdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgbW9kZSxcbiAgdXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nID0gZmFsc2UsXG4gIHN0cnVjdHVyZWRPdXRwdXRzID0gZmFsc2Vcbn0pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB0b29scyA9ICgoX2EgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA/IG1vZGUudG9vbHMgOiB2b2lkIDA7XG4gIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHsgdG9vbHM6IHZvaWQgMCwgdG9vbF9jaG9pY2U6IHZvaWQgMCB9O1xuICB9XG4gIGNvbnN0IHRvb2xDaG9pY2UgPSBtb2RlLnRvb2xDaG9pY2U7XG4gIGlmICh1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcpIHtcbiAgICBjb25zdCBtYXBwZWRGdW5jdGlvbnMgPSB0b29scy5tYXAoKHRvb2wpID0+ICh7XG4gICAgICBuYW1lOiB0b29sLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgIHBhcmFtZXRlcnM6IHRvb2wucGFyYW1ldGVyc1xuICAgIH0pKTtcbiAgICBpZiAodG9vbENob2ljZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBmdW5jdGlvbnM6IG1hcHBlZEZ1bmN0aW9ucywgZnVuY3Rpb25fY2FsbDogdm9pZCAwIH07XG4gICAgfVxuICAgIGNvbnN0IHR5cGUyID0gdG9vbENob2ljZS50eXBlO1xuICAgIHN3aXRjaCAodHlwZTIpIHtcbiAgICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnVuY3Rpb25zOiBtYXBwZWRGdW5jdGlvbnMsXG4gICAgICAgICAgZnVuY3Rpb25fY2FsbDogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMih7XG4gICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgYW5kIHRvb2xDaG9pY2U6IHJlcXVpcmVkXCJcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZ1bmN0aW9uczogbWFwcGVkRnVuY3Rpb25zLFxuICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHsgbmFtZTogdG9vbENob2ljZS50b29sTmFtZSB9XG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IG1hcHBlZFRvb2xzID0gdG9vbHMubWFwKCh0b29sKSA9PiAoe1xuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICBmdW5jdGlvbjoge1xuICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICBwYXJhbWV0ZXJzOiB0b29sLnBhcmFtZXRlcnNcbiAgICB9LFxuICAgIHN0cmljdDogc3RydWN0dXJlZE91dHB1dHMgPT09IHRydWUgPyB0cnVlIDogdm9pZCAwXG4gIH0pKTtcbiAgaWYgKHRvb2xDaG9pY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiB7IHRvb2xzOiBtYXBwZWRUb29scywgdG9vbF9jaG9pY2U6IHZvaWQgMCB9O1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0b29sQ2hvaWNlLnR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgIHJldHVybiB7IHRvb2xzOiBtYXBwZWRUb29scywgdG9vbF9jaG9pY2U6IHR5cGUgfTtcbiAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbHM6IG1hcHBlZFRvb2xzLFxuICAgICAgICB0b29sX2Nob2ljZToge1xuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogdG9vbENob2ljZS50b29sTmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gdHlwZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdG9vbCBjaG9pY2UgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvb3BlbmFpLWNvbXBsZXRpb24tbGFuZ3VhZ2UtbW9kZWwudHNcbmltcG9ydCB7XG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29tYmluZUhlYWRlcnMgYXMgY29tYmluZUhlYWRlcnMyLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciBhcyBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcjIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgYXMgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcjIsXG4gIHBvc3RKc29uVG9BcGkgYXMgcG9zdEpzb25Ub0FwaTJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejMgfSBmcm9tIFwiem9kXCI7XG5cbi8vIHNyYy9jb252ZXJ0LXRvLW9wZW5haS1jb21wbGV0aW9uLXByb21wdC50c1xuaW1wb3J0IHtcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSUNvbXBsZXRpb25Qcm9tcHQoe1xuICBwcm9tcHQsXG4gIGlucHV0Rm9ybWF0LFxuICB1c2VyID0gXCJ1c2VyXCIsXG4gIGFzc2lzdGFudCA9IFwiYXNzaXN0YW50XCJcbn0pIHtcbiAgaWYgKGlucHV0Rm9ybWF0ID09PSBcInByb21wdFwiICYmIHByb21wdC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdLnJvbGUgPT09IFwidXNlclwiICYmIHByb21wdFswXS5jb250ZW50Lmxlbmd0aCA9PT0gMSAmJiBwcm9tcHRbMF0uY29udGVudFswXS50eXBlID09PSBcInRleHRcIikge1xuICAgIHJldHVybiB7IHByb21wdDogcHJvbXB0WzBdLmNvbnRlbnRbMF0udGV4dCB9O1xuICB9XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgaWYgKHByb21wdFswXS5yb2xlID09PSBcInN5c3RlbVwiKSB7XG4gICAgdGV4dCArPSBgJHtwcm9tcHRbMF0uY29udGVudH1cblxuYDtcbiAgICBwcm9tcHQgPSBwcm9tcHQuc2xpY2UoMSk7XG4gIH1cbiAgZm9yIChjb25zdCB7IHJvbGUsIGNvbnRlbnQgfSBvZiBwcm9tcHQpIHtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlVuZXhwZWN0ZWQgc3lzdGVtIG1lc3NhZ2UgaW4gcHJvbXB0OiAke2NvbnRlbnR9XCIsXG4gICAgICAgICAgcHJvbXB0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjMoe1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiaW1hZ2VzXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke3VzZXJ9OlxuJHt1c2VyTWVzc2FnZX1cblxuYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZSA9IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzKHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInRvb2wtY2FsbCBtZXNzYWdlc1wiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgdGV4dCArPSBgJHthc3Npc3RhbnR9OlxuJHthc3Npc3RhbnRNZXNzYWdlfVxuXG5gO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMyh7XG4gICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sIG1lc3NhZ2VzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGV4dCArPSBgJHthc3Npc3RhbnR9OlxuYDtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHQ6IHRleHQsXG4gICAgc3RvcFNlcXVlbmNlczogW2BcbiR7dXNlcn06YF1cbiAgfTtcbn1cblxuLy8gc3JjL21hcC1vcGVuYWktY29tcGxldGlvbi1sb2dwcm9icy50c1xuZnVuY3Rpb24gbWFwT3BlbkFJQ29tcGxldGlvbkxvZ1Byb2JzKGxvZ3Byb2JzKSB7XG4gIHJldHVybiBsb2dwcm9icyA9PSBudWxsID8gdm9pZCAwIDogbG9ncHJvYnMudG9rZW5zLm1hcCgodG9rZW4sIGluZGV4KSA9PiAoe1xuICAgIHRva2VuLFxuICAgIGxvZ3Byb2I6IGxvZ3Byb2JzLnRva2VuX2xvZ3Byb2JzW2luZGV4XSxcbiAgICB0b3BMb2dwcm9iczogbG9ncHJvYnMudG9wX2xvZ3Byb2JzID8gT2JqZWN0LmVudHJpZXMobG9ncHJvYnMudG9wX2xvZ3Byb2JzW2luZGV4XSkubWFwKFxuICAgICAgKFt0b2tlbjIsIGxvZ3Byb2JdKSA9PiAoe1xuICAgICAgICB0b2tlbjogdG9rZW4yLFxuICAgICAgICBsb2dwcm9iXG4gICAgICB9KVxuICAgICkgOiBbXVxuICB9KSk7XG59XG5cbi8vIHNyYy9vcGVuYWktY29tcGxldGlvbi1sYW5ndWFnZS1tb2RlbC50c1xudmFyIE9wZW5BSUNvbXBsZXRpb25MYW5ndWFnZU1vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbElkLCBzZXR0aW5ncywgY29uZmlnKSB7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjFcIjtcbiAgICB0aGlzLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIG1vZGUsXG4gICAgaW5wdXRGb3JtYXQsXG4gICAgcHJvbXB0LFxuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczogdXNlclN0b3BTZXF1ZW5jZXMsXG4gICAgcmVzcG9uc2VGb3JtYXQsXG4gICAgc2VlZFxuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHR5cGUgPSBtb2RlLnR5cGU7XG4gICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgIHNldHRpbmc6IFwidG9wS1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlRm9ybWF0ICE9IG51bGwgJiYgcmVzcG9uc2VGb3JtYXQudHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIixcbiAgICAgICAgc2V0dGluZzogXCJyZXNwb25zZUZvcm1hdFwiLFxuICAgICAgICBkZXRhaWxzOiBcIkpTT04gcmVzcG9uc2UgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IHByb21wdDogY29tcGxldGlvblByb21wdCwgc3RvcFNlcXVlbmNlcyB9ID0gY29udmVydFRvT3BlbkFJQ29tcGxldGlvblByb21wdCh7IHByb21wdCwgaW5wdXRGb3JtYXQgfSk7XG4gICAgY29uc3Qgc3RvcCA9IFsuLi5zdG9wU2VxdWVuY2VzICE9IG51bGwgPyBzdG9wU2VxdWVuY2VzIDogW10sIC4uLnVzZXJTdG9wU2VxdWVuY2VzICE9IG51bGwgPyB1c2VyU3RvcFNlcXVlbmNlcyA6IFtdXTtcbiAgICBjb25zdCBiYXNlQXJncyA9IHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIC8vIG1vZGVsIHNwZWNpZmljIHNldHRpbmdzOlxuICAgICAgZWNobzogdGhpcy5zZXR0aW5ncy5lY2hvLFxuICAgICAgbG9naXRfYmlhczogdGhpcy5zZXR0aW5ncy5sb2dpdEJpYXMsXG4gICAgICBsb2dwcm9iczogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwibnVtYmVyXCIgPyB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzIDogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwiYm9vbGVhblwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA/IDAgOiB2b2lkIDAgOiB2b2lkIDAsXG4gICAgICBzdWZmaXg6IHRoaXMuc2V0dGluZ3Muc3VmZml4LFxuICAgICAgdXNlcjogdGhpcy5zZXR0aW5ncy51c2VyLFxuICAgICAgLy8gc3RhbmRhcmRpemVkIHNldHRpbmdzOlxuICAgICAgbWF4X3Rva2VuczogbWF4VG9rZW5zLFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICB0b3BfcDogdG9wUCxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgc2VlZCxcbiAgICAgIC8vIHByb21wdDpcbiAgICAgIHByb21wdDogY29tcGxldGlvblByb21wdCxcbiAgICAgIC8vIHN0b3Agc2VxdWVuY2VzOlxuICAgICAgc3RvcDogc3RvcC5sZW5ndGggPiAwID8gc3RvcCA6IHZvaWQgMFxuICAgIH07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwicmVndWxhclwiOiB7XG4gICAgICAgIGlmICgoX2EgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNCh7XG4gICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInRvb2xzXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZS50b29sQ2hvaWNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNCh7XG4gICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInRvb2xDaG9pY2VcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGFyZ3M6IGJhc2VBcmdzLCB3YXJuaW5ncyB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdC1qc29uXCI6IHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNCh7XG4gICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJvYmplY3QtanNvbiBtb2RlXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0LXRvb2xcIjoge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3I0KHtcbiAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcIm9iamVjdC10b29sIG1vZGVcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkb0dlbmVyYXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFyZ3MsIHdhcm5pbmdzIH0gPSB0aGlzLmdldEFyZ3Mob3B0aW9ucyk7XG4gICAgY29uc3QgeyByZXNwb25zZUhlYWRlcnMsIHZhbHVlOiByZXNwb25zZSB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaTIoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnMyKHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIGJvZHk6IGFyZ3MsXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5haUZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIyKFxuICAgICAgICBvcGVuQUlDb21wbGV0aW9uUmVzcG9uc2VTY2hlbWFcbiAgICAgICksXG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcHJvbXB0OiByYXdQcm9tcHQsIC4uLnJhd1NldHRpbmdzIH0gPSBhcmdzO1xuICAgIGNvbnN0IGNob2ljZSA9IHJlc3BvbnNlLmNob2ljZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGNob2ljZS50ZXh0LFxuICAgICAgdXNhZ2U6IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiByZXNwb25zZS51c2FnZS5wcm9tcHRfdG9rZW5zLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiByZXNwb25zZS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1xuICAgICAgfSxcbiAgICAgIGZpbmlzaFJlYXNvbjogbWFwT3BlbkFJRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKSxcbiAgICAgIGxvZ3Byb2JzOiBtYXBPcGVuQUlDb21wbGV0aW9uTG9nUHJvYnMoY2hvaWNlLmxvZ3Byb2JzKSxcbiAgICAgIHJhd0NhbGw6IHsgcmF3UHJvbXB0LCByYXdTZXR0aW5ncyB9LFxuICAgICAgcmF3UmVzcG9uc2U6IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzIH0sXG4gICAgICB3YXJuaW5nc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZG9TdHJlYW0ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXJncywgd2FybmluZ3MgfSA9IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7IHJlc3BvbnNlSGVhZGVycywgdmFsdWU6IHJlc3BvbnNlIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpMih7XG4gICAgICB1cmw6IHRoaXMuY29uZmlnLnVybCh7XG4gICAgICAgIHBhdGg6IFwiL2NvbXBsZXRpb25zXCIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZFxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVyczIodGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keToge1xuICAgICAgICAuLi5hcmdzLFxuICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgIC8vIG9ubHkgaW5jbHVkZSBzdHJlYW1fb3B0aW9ucyB3aGVuIGluIHN0cmljdCBjb21wYXRpYmlsaXR5IG1vZGU6XG4gICAgICAgIHN0cmVhbV9vcHRpb25zOiB0aGlzLmNvbmZpZy5jb21wYXRpYmlsaXR5ID09PSBcInN0cmljdFwiID8geyBpbmNsdWRlX3VzYWdlOiB0cnVlIH0gOiB2b2lkIDBcbiAgICAgIH0sXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5haUZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyMihcbiAgICAgICAgb3BlbmFpQ29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB7IHByb21wdDogcmF3UHJvbXB0LCAuLi5yYXdTZXR0aW5ncyB9ID0gYXJncztcbiAgICBsZXQgZmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgIGxldCB1c2FnZSA9IHtcbiAgICAgIHByb21wdFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE51bWJlci5OYU5cbiAgICB9O1xuICAgIGxldCBsb2dwcm9icztcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiB2YWx1ZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdXNhZ2UgPSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaG9pY2UgPSB2YWx1ZS5jaG9pY2VzWzBdO1xuICAgICAgICAgICAgaWYgKChjaG9pY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGNob2ljZS5maW5pc2hfcmVhc29uKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IG1hcE9wZW5BSUZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLnRleHQpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IGNob2ljZS50ZXh0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFwcGVkTG9ncHJvYnMgPSBtYXBPcGVuQUlDb21wbGV0aW9uTG9nUHJvYnMoXG4gICAgICAgICAgICAgIGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmxvZ3Byb2JzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG1hcHBlZExvZ3Byb2JzID09IG51bGwgPyB2b2lkIDAgOiBtYXBwZWRMb2dwcm9icy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGxvZ3Byb2JzID09PSB2b2lkIDApIGxvZ3Byb2JzID0gW107XG4gICAgICAgICAgICAgIGxvZ3Byb2JzLnB1c2goLi4ubWFwcGVkTG9ncHJvYnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgICAgICAgdXNhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICByYXdDYWxsOiB7IHJhd1Byb21wdCwgcmF3U2V0dGluZ3MgfSxcbiAgICAgIHJhd1Jlc3BvbnNlOiB7IGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyB9LFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG59O1xudmFyIG9wZW5BSUNvbXBsZXRpb25SZXNwb25zZVNjaGVtYSA9IHozLm9iamVjdCh7XG4gIGNob2ljZXM6IHozLmFycmF5KFxuICAgIHozLm9iamVjdCh7XG4gICAgICB0ZXh0OiB6My5zdHJpbmcoKSxcbiAgICAgIGZpbmlzaF9yZWFzb246IHozLnN0cmluZygpLFxuICAgICAgbG9ncHJvYnM6IHozLm9iamVjdCh7XG4gICAgICAgIHRva2VuczogejMuYXJyYXkoejMuc3RyaW5nKCkpLFxuICAgICAgICB0b2tlbl9sb2dwcm9iczogejMuYXJyYXkoejMubnVtYmVyKCkpLFxuICAgICAgICB0b3BfbG9ncHJvYnM6IHozLmFycmF5KHozLnJlY29yZCh6My5zdHJpbmcoKSwgejMubnVtYmVyKCkpKS5udWxsYWJsZSgpXG4gICAgICB9KS5udWxsYWJsZSgpLm9wdGlvbmFsKClcbiAgICB9KVxuICApLFxuICB1c2FnZTogejMub2JqZWN0KHtcbiAgICBwcm9tcHRfdG9rZW5zOiB6My5udW1iZXIoKSxcbiAgICBjb21wbGV0aW9uX3Rva2VuczogejMubnVtYmVyKClcbiAgfSlcbn0pO1xudmFyIG9wZW5haUNvbXBsZXRpb25DaHVua1NjaGVtYSA9IHozLnVuaW9uKFtcbiAgejMub2JqZWN0KHtcbiAgICBjaG9pY2VzOiB6My5hcnJheShcbiAgICAgIHozLm9iamVjdCh7XG4gICAgICAgIHRleHQ6IHozLnN0cmluZygpLFxuICAgICAgICBmaW5pc2hfcmVhc29uOiB6My5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgIGluZGV4OiB6My5udW1iZXIoKSxcbiAgICAgICAgbG9ncHJvYnM6IHozLm9iamVjdCh7XG4gICAgICAgICAgdG9rZW5zOiB6My5hcnJheSh6My5zdHJpbmcoKSksXG4gICAgICAgICAgdG9rZW5fbG9ncHJvYnM6IHozLmFycmF5KHozLm51bWJlcigpKSxcbiAgICAgICAgICB0b3BfbG9ncHJvYnM6IHozLmFycmF5KHozLnJlY29yZCh6My5zdHJpbmcoKSwgejMubnVtYmVyKCkpKS5udWxsYWJsZSgpXG4gICAgICAgIH0pLm51bGxhYmxlKCkub3B0aW9uYWwoKVxuICAgICAgfSlcbiAgICApLFxuICAgIHVzYWdlOiB6My5vYmplY3Qoe1xuICAgICAgcHJvbXB0X3Rva2VuczogejMubnVtYmVyKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2VuczogejMubnVtYmVyKClcbiAgICB9KS5vcHRpb25hbCgpLm51bGxhYmxlKClcbiAgfSksXG4gIG9wZW5BSUVycm9yRGF0YVNjaGVtYVxuXSk7XG5cbi8vIHNyYy9vcGVuYWktZmFjYWRlLnRzXG52YXIgT3BlbkFJID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBPcGVuQUkgcHJvdmlkZXIgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRoaXMuYmFzZVVSTCA9IChfYiA9IHdpdGhvdXRUcmFpbGluZ1NsYXNoKChfYSA9IG9wdGlvbnMuYmFzZVVSTCkgIT0gbnVsbCA/IF9hIDogb3B0aW9ucy5iYXNlVXJsKSkgIT0gbnVsbCA/IF9iIDogXCJodHRwczovL2FwaS5vcGVuYWkuY29tL3YxXCI7XG4gICAgdGhpcy5hcGlLZXkgPSBvcHRpb25zLmFwaUtleTtcbiAgICB0aGlzLm9yZ2FuaXphdGlvbiA9IG9wdGlvbnMub3JnYW5pemF0aW9uO1xuICAgIHRoaXMucHJvamVjdCA9IG9wdGlvbnMucHJvamVjdDtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gIH1cbiAgZ2V0IGJhc2VDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9yZ2FuaXphdGlvbjogdGhpcy5vcmdhbml6YXRpb24sXG4gICAgICBiYXNlVVJMOiB0aGlzLmJhc2VVUkwsXG4gICAgICBoZWFkZXJzOiAoKSA9PiAoe1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7bG9hZEFwaUtleSh7XG4gICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZTogXCJPUEVOQUlfQVBJX0tFWVwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk9wZW5BSVwiXG4gICAgICAgIH0pfWAsXG4gICAgICAgIFwiT3BlbkFJLU9yZ2FuaXphdGlvblwiOiB0aGlzLm9yZ2FuaXphdGlvbixcbiAgICAgICAgXCJPcGVuQUktUHJvamVjdFwiOiB0aGlzLnByb2plY3QsXG4gICAgICAgIC4uLnRoaXMuaGVhZGVyc1xuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGNoYXQobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkge1xuICAgIHJldHVybiBuZXcgT3BlbkFJQ2hhdExhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haS5jaGF0XCIsXG4gICAgICAuLi50aGlzLmJhc2VDb25maWcsXG4gICAgICBjb21wYXRpYmlsaXR5OiBcInN0cmljdFwiLFxuICAgICAgdXJsOiAoeyBwYXRoIH0pID0+IGAke3RoaXMuYmFzZVVSTH0ke3BhdGh9YFxuICAgIH0pO1xuICB9XG4gIGNvbXBsZXRpb24obW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkge1xuICAgIHJldHVybiBuZXcgT3BlbkFJQ29tcGxldGlvbkxhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haS5jb21wbGV0aW9uXCIsXG4gICAgICAuLi50aGlzLmJhc2VDb25maWcsXG4gICAgICBjb21wYXRpYmlsaXR5OiBcInN0cmljdFwiLFxuICAgICAgdXJsOiAoeyBwYXRoIH0pID0+IGAke3RoaXMuYmFzZVVSTH0ke3BhdGh9YFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvb3BlbmFpLXByb3ZpZGVyLnRzXG5pbXBvcnQgeyBsb2FkQXBpS2V5IGFzIGxvYWRBcGlLZXkyLCB3aXRob3V0VHJhaWxpbmdTbGFzaCBhcyB3aXRob3V0VHJhaWxpbmdTbGFzaDIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvb3BlbmFpLWVtYmVkZGluZy1tb2RlbC50c1xuaW1wb3J0IHtcbiAgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29tYmluZUhlYWRlcnMgYXMgY29tYmluZUhlYWRlcnMzLFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIzLFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGkzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo0IH0gZnJvbSBcInpvZFwiO1xudmFyIE9wZW5BSUVtYmVkZGluZ01vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbElkLCBzZXR0aW5ncywgY29uZmlnKSB7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjFcIjtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGdldCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuc2V0dGluZ3MubWF4RW1iZWRkaW5nc1BlckNhbGwpICE9IG51bGwgPyBfYSA6IDIwNDg7XG4gIH1cbiAgZ2V0IHN1cHBvcnRzUGFyYWxsZWxDYWxscygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuc2V0dGluZ3Muc3VwcG9ydHNQYXJhbGxlbENhbGxzKSAhPSBudWxsID8gX2EgOiB0cnVlO1xuICB9XG4gIGFzeW5jIGRvRW1iZWQoe1xuICAgIHZhbHVlcyxcbiAgICBoZWFkZXJzLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwpIHtcbiAgICAgIHRocm93IG5ldyBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yKHtcbiAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgICAgIHZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVzcG9uc2VIZWFkZXJzLCB2YWx1ZTogcmVzcG9uc2UgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkzKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvZW1iZWRkaW5nc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnMzKHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgaGVhZGVycyksXG4gICAgICBib2R5OiB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsSWQsXG4gICAgICAgIGlucHV0OiB2YWx1ZXMsXG4gICAgICAgIGVuY29kaW5nX2Zvcm1hdDogXCJmbG9hdFwiLFxuICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnNldHRpbmdzLmRpbWVuc2lvbnMsXG4gICAgICAgIHVzZXI6IHRoaXMuc2V0dGluZ3MudXNlclxuICAgICAgfSxcbiAgICAgIGZhaWxlZFJlc3BvbnNlSGFuZGxlcjogb3BlbmFpRmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcjMoXG4gICAgICAgIG9wZW5haVRleHRFbWJlZGRpbmdSZXNwb25zZVNjaGVtYVxuICAgICAgKSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVtYmVkZGluZ3M6IHJlc3BvbnNlLmRhdGEubWFwKChpdGVtKSA9PiBpdGVtLmVtYmVkZGluZyksXG4gICAgICB1c2FnZTogcmVzcG9uc2UudXNhZ2UgPyB7IHRva2VuczogcmVzcG9uc2UudXNhZ2UucHJvbXB0X3Rva2VucyB9IDogdm9pZCAwLFxuICAgICAgcmF3UmVzcG9uc2U6IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzIH1cbiAgICB9O1xuICB9XG59O1xudmFyIG9wZW5haVRleHRFbWJlZGRpbmdSZXNwb25zZVNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIGRhdGE6IHo0LmFycmF5KHo0Lm9iamVjdCh7IGVtYmVkZGluZzogejQuYXJyYXkoejQubnVtYmVyKCkpIH0pKSxcbiAgdXNhZ2U6IHo0Lm9iamVjdCh7IHByb21wdF90b2tlbnM6IHo0Lm51bWJlcigpIH0pLm51bGxpc2goKVxufSk7XG5cbi8vIHNyYy9vcGVuYWktcHJvdmlkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZU9wZW5BSShvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IGJhc2VVUkwgPSAoX2IgPSB3aXRob3V0VHJhaWxpbmdTbGFzaDIoKF9hID0gb3B0aW9ucy5iYXNlVVJMKSAhPSBudWxsID8gX2EgOiBvcHRpb25zLmJhc2VVcmwpKSAhPSBudWxsID8gX2IgOiBcImh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjFcIjtcbiAgY29uc3QgY29tcGF0aWJpbGl0eSA9IChfYyA9IG9wdGlvbnMuY29tcGF0aWJpbGl0eSkgIT0gbnVsbCA/IF9jIDogXCJjb21wYXRpYmxlXCI7XG4gIGNvbnN0IGdldEhlYWRlcnMgPSAoKSA9PiAoe1xuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtsb2FkQXBpS2V5Mih7XG4gICAgICBhcGlLZXk6IG9wdGlvbnMuYXBpS2V5LFxuICAgICAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWU6IFwiT1BFTkFJX0FQSV9LRVlcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk9wZW5BSVwiXG4gICAgfSl9YCxcbiAgICBcIk9wZW5BSS1Pcmdhbml6YXRpb25cIjogb3B0aW9ucy5vcmdhbml6YXRpb24sXG4gICAgXCJPcGVuQUktUHJvamVjdFwiOiBvcHRpb25zLnByb2plY3QsXG4gICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gIH0pO1xuICBjb25zdCBjcmVhdGVDaGF0TW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5BSUNoYXRMYW5ndWFnZU1vZGVsKG1vZGVsSWQsIHNldHRpbmdzLCB7XG4gICAgcHJvdmlkZXI6IFwib3BlbmFpLmNoYXRcIixcbiAgICB1cmw6ICh7IHBhdGggfSkgPT4gYCR7YmFzZVVSTH0ke3BhdGh9YCxcbiAgICBoZWFkZXJzOiBnZXRIZWFkZXJzLFxuICAgIGNvbXBhdGliaWxpdHksXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgfSk7XG4gIGNvbnN0IGNyZWF0ZUNvbXBsZXRpb25Nb2RlbCA9IChtb2RlbElkLCBzZXR0aW5ncyA9IHt9KSA9PiBuZXcgT3BlbkFJQ29tcGxldGlvbkxhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIHtcbiAgICBwcm92aWRlcjogXCJvcGVuYWkuY29tcGxldGlvblwiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgY29tcGF0aWJpbGl0eSxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaFxuICB9KTtcbiAgY29uc3QgY3JlYXRlRW1iZWRkaW5nTW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5BSUVtYmVkZGluZ01vZGVsKG1vZGVsSWQsIHNldHRpbmdzLCB7XG4gICAgcHJvdmlkZXI6IFwib3BlbmFpLmVtYmVkZGluZ1wiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgfSk7XG4gIGNvbnN0IGNyZWF0ZUxhbmd1YWdlTW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MpID0+IHtcbiAgICBpZiAobmV3LnRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSBPcGVuQUkgbW9kZWwgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcga2V5d29yZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVsSWQgPT09IFwiZ3B0LTMuNS10dXJiby1pbnN0cnVjdFwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcGxldGlvbk1vZGVsKFxuICAgICAgICBtb2RlbElkLFxuICAgICAgICBzZXR0aW5nc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYXRNb2RlbChtb2RlbElkLCBzZXR0aW5ncyk7XG4gIH07XG4gIGNvbnN0IHByb3ZpZGVyID0gZnVuY3Rpb24obW9kZWxJZCwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gY3JlYXRlTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncyk7XG4gIH07XG4gIHByb3ZpZGVyLmxhbmd1YWdlTW9kZWwgPSBjcmVhdGVMYW5ndWFnZU1vZGVsO1xuICBwcm92aWRlci5jaGF0ID0gY3JlYXRlQ2hhdE1vZGVsO1xuICBwcm92aWRlci5jb21wbGV0aW9uID0gY3JlYXRlQ29tcGxldGlvbk1vZGVsO1xuICBwcm92aWRlci5lbWJlZGRpbmcgPSBjcmVhdGVFbWJlZGRpbmdNb2RlbDtcbiAgcHJvdmlkZXIudGV4dEVtYmVkZGluZyA9IGNyZWF0ZUVtYmVkZGluZ01vZGVsO1xuICByZXR1cm4gcHJvdmlkZXI7XG59XG52YXIgb3BlbmFpID0gY3JlYXRlT3BlbkFJKHtcbiAgY29tcGF0aWJpbGl0eTogXCJzdHJpY3RcIlxuICAvLyBzdHJpY3QgZm9yIE9wZW5BSSBBUElcbn0pO1xuZXhwb3J0IHtcbiAgT3BlbkFJLFxuICBjcmVhdGVPcGVuQUksXG4gIG9wZW5haVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/openai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncGeneratorToReadableStream: () => (/* binding */ convertAsyncGeneratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isParseableJson: () => (/* binding */ isParseableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventsource-parser/stream */ \"(rsc)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-generator-to-readable-stream.ts\nfunction convertAsyncGeneratorToReadableStream(stream) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n\n// src/validate-types.ts\n\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const schema = isValidator(inputSchema) ? inputSchema : zodValidator(inputSchema);\n  try {\n    if (schema.validate == null) {\n      return { success: true, value };\n    }\n    const validationResult = schema.validate(value);\n    if (validationResult.success) {\n      return validationResult;\n    }\n    return {\n      success: false,\n      error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n        value,\n        cause: validationResult.error\n      })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isTypeValidationError(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isTypeValidationError(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar isParseableJson = isParsableJson;\n\n// src/post-to-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/post-to-api.ts\nvar getOriginalFetch = () => fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch: fetch2\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch: fetch2 = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch2(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/response-handler.ts\n\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__.EventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value\n  };\n};\n\n// src/uint8-utils.ts\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = globalThis.atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return globalThis.btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQsaUJBQWlCLGlFQUFjO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBZTtBQUM3QixrQkFBa0IsYUFBYTtBQUMvQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0Isa0JBQWtCLGFBQWEseUNBQXlDLG9CQUFvQjtBQUM1RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBZTtBQUM3QixrQkFBa0IsYUFBYSx5Q0FBeUMsb0JBQW9CLHFCQUFxQix5QkFBeUI7QUFDMUksS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZEQUFlO0FBQzdCLGtCQUFrQixhQUFhLDZDQUE2Qyx5QkFBeUI7QUFDckcsS0FBSztBQUNM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QTtBQUNBLDZEQUE2RCxrQ0FBa0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsMERBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBNkJFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3Vuc2VsbGluZy10aHJvdWdoLWJpYmxlLWZ1bGxzdGFjay8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyLXV0aWxzL2Rpc3QvaW5kZXgubWpzPzI4Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbWJpbmUtaGVhZGVycy50c1xuZnVuY3Rpb24gY29tYmluZUhlYWRlcnMoLi4uaGVhZGVycykge1xuICByZXR1cm4gaGVhZGVycy5yZWR1Y2UoXG4gICAgKGNvbWJpbmVkSGVhZGVycywgY3VycmVudEhlYWRlcnMpID0+ICh7XG4gICAgICAuLi5jb21iaW5lZEhlYWRlcnMsXG4gICAgICAuLi5jdXJyZW50SGVhZGVycyAhPSBudWxsID8gY3VycmVudEhlYWRlcnMgOiB7fVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbi8vIHNyYy9jb252ZXJ0LWFzeW5jLWdlbmVyYXRvci10by1yZWFkYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNvbnZlcnRBc3luY0dlbmVyYXRvclRvUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciB3YW50cyB0byBwdWxsIG1vcmUgZGF0YSBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VD59IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBlbnF1ZXVlIGRhdGEgaW50byB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29uc3VtZXIgY2FuY2VscyB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvZXh0cmFjdC1yZXNwb25zZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gc3JjL2dlbmVyYXRlLWlkLnRzXG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWQvbm9uLXNlY3VyZVwiO1xudmFyIGdlbmVyYXRlSWQgPSBjdXN0b21BbHBoYWJldChcbiAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA3XG4pO1xuXG4vLyBzcmMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2lzLWFib3J0LWVycm9yLnRzXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpO1xufVxuXG4vLyBzcmMvbG9hZC1hcGkta2V5LnRzXG5pbXBvcnQgeyBMb2FkQVBJS2V5RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gbG9hZEFwaUtleSh7XG4gIGFwaUtleSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIGFwaUtleVBhcmFtZXRlck5hbWUgPSBcImFwaUtleVwiLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIGFwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBhcGlLZXk7XG4gIH1cbiAgaWYgKGFwaUtleSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIGFwaUtleSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyIG9yIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZS5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcGlLZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXBpS2V5O1xufVxuXG4vLyBzcmMvbG9hZC1zZXR0aW5nLnRzXG5pbXBvcnQgeyBMb2FkU2V0dGluZ0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRTZXR0aW5nKHtcbiAgc2V0dGluZ1ZhbHVlLFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgc2V0dGluZ05hbWUsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbiAgfVxuICBpZiAoc2V0dGluZ1ZhbHVlICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBtdXN0IGJlIGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHtzZXR0aW5nTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgc2V0dGluZ1ZhbHVlID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoc2V0dGluZ1ZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHtzZXR0aW5nTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZXR0aW5nVmFsdWU7XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLnRzXG5pbXBvcnQgeyBKU09OUGFyc2VFcnJvciwgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgU2VjdXJlSlNPTiBmcm9tIFwic2VjdXJlLWpzb24tcGFyc2VcIjtcblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5pbXBvcnQgeyBUeXBlVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3ZhbGlkYXRvci50c1xudmFyIHZhbGlkYXRvclN5bWJvbCA9IFN5bWJvbC5mb3IoXCJ2ZXJjZWwuYWkudmFsaWRhdG9yXCIpO1xuZnVuY3Rpb24gdmFsaWRhdG9yKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7IFt2YWxpZGF0b3JTeW1ib2xdOiB0cnVlLCB2YWxpZGF0ZSB9O1xufVxuZnVuY3Rpb24gaXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWxpZGF0b3JTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbdmFsaWRhdG9yU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiB6b2RWYWxpZGF0b3Ioem9kU2NoZW1hKSB7XG4gIHJldHVybiB2YWxpZGF0b3IoKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gem9kU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hXG59KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQudmFsdWU7XG59XG5mdW5jdGlvbiBzYWZlVmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hXG59KSB7XG4gIGNvbnN0IHNjaGVtYSA9IGlzVmFsaWRhdG9yKGlucHV0U2NoZW1hKSA/IGlucHV0U2NoZW1hIDogem9kVmFsaWRhdG9yKGlucHV0U2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAoc2NoZW1hLnZhbGlkYXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBzY2hlbWEudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3JcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvci5pc1R5cGVWYWxpZGF0aW9uRXJyb3IoZXJyb3IpID8gZXJyb3IgOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLnRzXG5mdW5jdGlvbiBwYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNlY3VyZUpTT04ucGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoSlNPTlBhcnNlRXJyb3IuaXNKU09OUGFyc2VFcnJvcihlcnJvcikgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjIuaXNUeXBlVmFsaWRhdGlvbkVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBKU09OUGFyc2VFcnJvcih7IHRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZVBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gU2VjdXJlSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBKU09OUGFyc2VFcnJvci5pc0pTT05QYXJzZUVycm9yKGVycm9yKSA/IGVycm9yIDogbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBTZWN1cmVKU09OLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxudmFyIGlzUGFyc2VhYmxlSnNvbiA9IGlzUGFyc2FibGVKc29uO1xuXG4vLyBzcmMvcG9zdC10by1hcGkudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9yZW1vdmUtdW5kZWZpbmVkLWVudHJpZXMudHNcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMocmVjb3JkKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMocmVjb3JkKS5maWx0ZXIoKFtfa2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpXG4gICk7XG59XG5cbi8vIHNyYy9wb3N0LXRvLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBmZXRjaDtcbnZhciBwb3N0SnNvblRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaDogZmV0Y2gyXG59KSA9PiBwb3N0VG9BcGkoe1xuICB1cmwsXG4gIGhlYWRlcnM6IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAuLi5oZWFkZXJzXG4gIH0sXG4gIGJvZHk6IHtcbiAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB2YWx1ZXM6IGJvZHlcbiAgfSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2g6IGZldGNoMlxufSk7XG52YXIgcG9zdFRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGJvZHksXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoKClcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMih1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgLy8gcmV0cnkgd2hlbiBuZXR3b3JrIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLWhhbmRsZXIudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLCBFbXB0eVJlc3BvbnNlQm9keUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXIvc3RyZWFtXCI7XG52YXIgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyID0gKHtcbiAgZXJyb3JTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlLFxuICBpc1JldHJ5YWJsZVxufSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2VCb2R5LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiBlcnJvclRvTWVzc2FnZShwYXJzZWRFcnJvciksXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGRhdGE6IHBhcnNlZEVycm9yLFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlLCBwYXJzZWRFcnJvcilcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKHsgZGF0YSB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEsXG4gICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmtUZXh0LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rVGV4dC5lbmRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBidWZmZXIgKyBjaHVua1RleHQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1RleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZVNjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHNhZmVQYXJzZUpTT04oe1xuICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hXG4gIH0pO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFwYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlXG4gIH07XG59O1xuXG4vLyBzcmMvdWludDgtdXRpbHMudHNcbmZ1bmN0aW9uIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoYmFzZTY0U3RyaW5nKSB7XG4gIGNvbnN0IGJhc2U2NFVybCA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgY29uc3QgbGF0aW4xc3RyaW5nID0gZ2xvYmFsVGhpcy5hdG9iKGJhc2U2NFVybCk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20obGF0aW4xc3RyaW5nLCAoYnl0ZSkgPT4gYnl0ZS5jb2RlUG9pbnRBdCgwKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGFycmF5KSB7XG4gIGxldCBsYXRpbjFzdHJpbmcgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGF0aW4xc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGxhdGluMXN0cmluZyk7XG59XG5cbi8vIHNyYy93aXRob3V0LXRyYWlsaW5nLXNsYXNoLnRzXG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PSBudWxsID8gdm9pZCAwIDogdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbn1cbmV4cG9ydCB7XG4gIGNvbWJpbmVIZWFkZXJzLFxuICBjb252ZXJ0QXN5bmNHZW5lcmF0b3JUb1JlYWRhYmxlU3RyZWFtLFxuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0LFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVKc29uU3RyZWFtUmVzcG9uc2VIYW5kbGVyLFxuICBleHRyYWN0UmVzcG9uc2VIZWFkZXJzLFxuICBnZW5lcmF0ZUlkLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzQWJvcnRFcnJvcixcbiAgaXNQYXJzYWJsZUpzb24sXG4gIGlzUGFyc2VhYmxlSnNvbixcbiAgaXNWYWxpZGF0b3IsXG4gIGxvYWRBcGlLZXksXG4gIGxvYWRTZXR0aW5nLFxuICBwYXJzZUpTT04sXG4gIHBvc3RKc29uVG9BcGksXG4gIHBvc3RUb0FwaSxcbiAgc2FmZVBhcnNlSlNPTixcbiAgc2FmZVZhbGlkYXRlVHlwZXMsXG4gIHZhbGlkYXRlVHlwZXMsXG4gIHZhbGlkYXRvcixcbiAgdmFsaWRhdG9yU3ltYm9sLFxuICB3aXRob3V0VHJhaWxpbmdTbGFzaCxcbiAgem9kVmFsaWRhdG9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name12,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name12;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker13) {\n    const markerSymbol = Symbol.for(marker13);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message\n    };\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error) {\n    return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data\n    };\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(error) {\n    return error instanceof Error && error.name === name2;\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-prompt-error.ts\nvar name3 = \"AI_InvalidPromptError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({ prompt: prompt2, message }) {\n    super({\n      name: name3,\n      message: `Invalid prompt: ${message}`\n    });\n    this[_a4] = true;\n    this.prompt = prompt2;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error) {\n    return error instanceof Error && error.name === name3 && prompt != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      prompt: this.prompt\n    };\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-response-data-error.ts\nvar name4 = \"AI_InvalidResponseDataError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name4, message });\n    this[_a5] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(error) {\n    return error instanceof Error && error.name === name4 && error.data != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      data: this.data\n    };\n  }\n};\n_a5 = symbol5;\n\n// src/errors/json-parse-error.ts\nvar name5 = \"AI_JSONParseError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name5,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a6] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error) {\n    return error instanceof Error && error.name === name5 && typeof error.text === \"string\" && typeof error.cause === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      valueText: this.text\n    };\n  }\n};\n_a6 = symbol6;\n\n// src/errors/load-api-key-error.ts\nvar name6 = \"AI_LoadAPIKeyError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name6, message });\n    this[_a7] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-setting-error.ts\nvar name7 = \"AI_LoadSettingError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error) {\n    return error instanceof Error && error.name === name7;\n  }\n};\n_a8 = symbol8;\n\n// src/errors/no-content-generated-error.ts\nvar name8 = \"AI_NoContentGeneratedError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(error) {\n    return error instanceof Error && error.name === name8;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a9 = symbol9;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name9 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name9,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a10] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(error) {\n    return error instanceof Error && error.name === name9 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values\n    };\n  }\n};\n_a10 = symbol10;\n\n// src/errors/type-validation-error.ts\nvar name10 = \"AI_TypeValidationError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar TypeValidationError = class extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name10,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a11] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error) {\n    return error instanceof Error && error.name === name10;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      value: this.value\n    };\n  }\n};\n_a11 = symbol11;\n\n// src/errors/unsupported-functionality-error.ts\nvar name11 = \"AI_UnsupportedFunctionalityError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({ functionality }) {\n    super({\n      name: name11,\n      message: `'${functionality}' functionality not supported.`\n    });\n    this[_a12] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(error) {\n    return error instanceof Error && error.name === name11 && typeof error.functionality === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      functionality: this.functionality\n    };\n  }\n};\n_a12 = symbol12;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQyxJQUFJO0FBQ3RELFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3Vuc2VsbGluZy10aHJvdWdoLWJpYmxlLWZ1bGxzdGFjay8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXgubWpzP2ViN2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxMixcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTEyO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMykge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvci5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVycm9yJ3MgbmFtZSwgbWVzc2FnZSwgYW5kIGNhdXNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xudmFyIEFJU0RLRXJyb3IgPSBfQUlTREtFcnJvcjtcblxuLy8gc3JjL2Vycm9ycy9hcGktY2FsbC1lcnJvci50c1xudmFyIG5hbWUgPSBcIkFJX0FQSUNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBBUElDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICB1cmwsXG4gICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgcmVzcG9uc2VCb2R5LFxuICAgIGNhdXNlLFxuICAgIGlzUmV0cnlhYmxlID0gc3RhdHVzQ29kZSAhPSBudWxsICYmIChzdGF0dXNDb2RlID09PSA0MDggfHwgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDA5IHx8IC8vIGNvbmZsaWN0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDI5IHx8IC8vIHRvbyBtYW55IHJlcXVlc3RzXG4gICAgc3RhdHVzQ29kZSA+PSA1MDApLFxuICAgIC8vIHNlcnZlciBlcnJvclxuICAgIGRhdGFcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzID0gcmVxdWVzdEJvZHlWYWx1ZXM7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcbiAgICB0aGlzLnJlc3BvbnNlQm9keSA9IHJlc3BvbnNlQm9keTtcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gaXNSZXRyeWFibGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNBUElDYWxsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lICYmIHR5cGVvZiBlcnJvci51cmwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnJlcXVlc3RCb2R5VmFsdWVzID09PSBcIm9iamVjdFwiICYmIChlcnJvci5zdGF0dXNDb2RlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c0NvZGUgPT09IFwibnVtYmVyXCIpICYmIChlcnJvci5yZXNwb25zZUhlYWRlcnMgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IucmVzcG9uc2VIZWFkZXJzID09PSBcIm9iamVjdFwiKSAmJiAoZXJyb3IucmVzcG9uc2VCb2R5ID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnJlc3BvbnNlQm9keSA9PT0gXCJzdHJpbmdcIikgJiYgKGVycm9yLmNhdXNlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLmNhdXNlID09PSBcIm9iamVjdFwiKSAmJiB0eXBlb2YgZXJyb3IuaXNSZXRyeWFibGUgPT09IFwiYm9vbGVhblwiICYmIChlcnJvci5kYXRhID09IG51bGwgfHwgdHlwZW9mIGVycm9yLmRhdGEgPT09IFwib2JqZWN0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzOiB0aGlzLnJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdGhpcy5yZXNwb25zZUJvZHksXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIGlzUmV0cnlhYmxlOiB0aGlzLmlzUmV0cnlhYmxlLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHNyYy9lcnJvcnMvZW1wdHktcmVzcG9uc2UtYm9keS1lcnJvci50c1xudmFyIG5hbWUyID0gXCJBSV9FbXB0eVJlc3BvbnNlQm9keUVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBFbXB0eVJlc3BvbnNlQm9keUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiRW1wdHkgcmVzcG9uc2UgYm9keVwiIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzRW1wdHlSZXNwb25zZUJvZHlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUyO1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcblxuLy8gc3JjL2Vycm9ycy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyBwcm9tcHQ6IHByb21wdDIsIG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUzLFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgcHJvbXB0OiAke21lc3NhZ2V9YFxuICAgIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5wcm9tcHQgPSBwcm9tcHQyO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkUHJvbXB0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMyAmJiBwcm9tcHQgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcHJvbXB0OiB0aGlzLnByb21wdFxuICAgIH07XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcmVzcG9uc2UtZGF0YS1lcnJvci50c1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1O1xudmFyIEludmFsaWRSZXNwb25zZURhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCByZXNwb25zZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgZXJyb3IuZGF0YSAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gc3JjL2Vycm9ycy9qc29uLXBhcnNlLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0pTT05QYXJzZUVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBKU09OUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdGV4dCwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU1LFxuICAgICAgbWVzc2FnZTogYEpTT04gcGFyc2luZyBmYWlsZWQ6IFRleHQ6ICR7dGV4dH0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNKU09OUGFyc2VFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIHR5cGVvZiBlcnJvci50ZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5jYXVzZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB2YWx1ZVRleHQ6IHRoaXMudGV4dFxuICAgIH07XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTYsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNMb2FkQVBJS2V5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNjtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1zZXR0aW5nLWVycm9yLnRzXG52YXIgbmFtZTcgPSBcIkFJX0xvYWRTZXR0aW5nRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRTZXR0aW5nRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzTG9hZFNldHRpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU3O1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gc3JjL2Vycm9ycy9uby1jb250ZW50LWdlbmVyYXRlZC1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Ob0NvbnRlbnRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG52YXIgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGNvbnRlbnQgZ2VuZXJhdGVkLlwiXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU4O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH07XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBzcmMvZXJyb3JzL3Rvby1tYW55LWVtYmVkZGluZy12YWx1ZXMtZm9yLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTksXG4gICAgICBtZXNzYWdlOiBgVG9vIG1hbnkgdmFsdWVzIGZvciBhIHNpbmdsZSBlbWJlZGRpbmcgY2FsbC4gVGhlICR7b3B0aW9ucy5wcm92aWRlcn0gbW9kZWwgXCIke29wdGlvbnMubW9kZWxJZH1cIiBjYW4gb25seSBlbWJlZCB1cCB0byAke29wdGlvbnMubWF4RW1iZWRkaW5nc1BlckNhbGx9IHZhbHVlcyBwZXIgY2FsbCwgYnV0ICR7b3B0aW9ucy52YWx1ZXMubGVuZ3RofSB2YWx1ZXMgd2VyZSBwcm92aWRlZC5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdGlvbnMucHJvdmlkZXI7XG4gICAgdGhpcy5tb2RlbElkID0gb3B0aW9ucy5tb2RlbElkO1xuICAgIHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwgPSBvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTkgJiYgXCJwcm92aWRlclwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5wcm92aWRlciA9PT0gXCJzdHJpbmdcIiAmJiBcIm1vZGVsSWRcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiBcIm1heEVtYmVkZGluZ3NQZXJDYWxsXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1heEVtYmVkZGluZ3NQZXJDYWxsID09PSBcIm51bWJlclwiICYmIFwidmFsdWVzXCIgaW4gZXJyb3IgJiYgQXJyYXkuaXNBcnJheShlcnJvci52YWx1ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1heEVtYmVkZGluZ3NQZXJDYWxsOiB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xuICAgIH07XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEwID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExO1xudmFyIFR5cGVWYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEwLFxuICAgICAgbWVzc2FnZTogYFR5cGUgdmFsaWRhdGlvbiBmYWlsZWQ6IFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTExXSA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzVHlwZVZhbGlkYXRpb25FcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbn07XG5fYTExID0gc3ltYm9sMTE7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMSA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IGZ1bmN0aW9uYWxpdHkgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMSxcbiAgICAgIG1lc3NhZ2U6IGAnJHtmdW5jdGlvbmFsaXR5fScgZnVuY3Rpb25hbGl0eSBub3Qgc3VwcG9ydGVkLmBcbiAgICB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLmZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbmFsaXR5O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMSAmJiB0eXBlb2YgZXJyb3IuZnVuY3Rpb25hbGl0eSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgZnVuY3Rpb25hbGl0eTogdGhpcy5mdW5jdGlvbmFsaXR5XG4gICAgfTtcbiAgfVxufTtcbl9hMTIgPSBzeW1ib2wxMjtcbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IsXG4gIEFQSUNhbGxFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgZ2V0RXJyb3JNZXNzYWdlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   callChatApi: () => (/* binding */ callChatApi),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   formatStreamPart: () => (/* binding */ formatStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   parseStreamPart: () => (/* binding */ parseStreamPart),\n/* harmony export */   processChatStream: () => (/* binding */ processChatStream),\n/* harmony export */   processDataProtocolResponse: () => (/* binding */ processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* binding */ readDataStream),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/index.ts\n\n\n// src/process-data-protocol-response.ts\n\n\n// src/parse-partial-json.ts\n\n\n// src/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  try {\n    return {\n      value: secure_json_parse__WEBPACK_IMPORTED_MODULE_0__.parse(jsonText),\n      state: \"successful-parse\"\n    };\n  } catch (ignored) {\n    try {\n      return {\n        value: secure_json_parse__WEBPACK_IMPORTED_MODULE_0__.parse(fixJson(jsonText)),\n        state: \"repaired-parse\"\n      };\n    } catch (ignored2) {\n    }\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar functionCallStreamPart = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.'\n      );\n    }\n    return {\n      type: \"function_call\",\n      value\n    };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar toolCallsStreamPart = {\n  code: \"7\",\n  name: \"tool_calls\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some(\n      (tc) => tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\"\n    )) {\n      throw new Error(\n        '\"tool_calls\" parts expect an object with a ToolCallPayload.'\n      );\n    }\n    return {\n      type: \"tool_calls\",\n      value\n    };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"9\",\n  name: \"tool_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.'\n      );\n    }\n    return {\n      type: \"tool_call\",\n      value\n    };\n  }\n};\nvar toolResultStreamPart = {\n  code: \"a\",\n  name: \"tool_result\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.'\n      );\n    }\n    return {\n      type: \"tool_result\",\n      value\n    };\n  }\n};\nvar toolCallStreamingStartStreamPart = {\n  code: \"b\",\n  name: \"tool_call_streaming_start\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_streaming_start\",\n      value\n    };\n  }\n};\nvar toolCallDeltaStreamPart = {\n  code: \"c\",\n  name: \"tool_call_delta\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_delta\",\n      value\n    };\n  }\n};\nvar finishMessageStreamPart = {\n  code: \"d\",\n  name: \"finish_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    return {\n      type: \"finish_message\",\n      value: result\n    };\n  }\n};\nvar finishStepStreamPart = {\n  code: \"e\",\n  name: \"finish_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    return {\n      type: \"finish_step\",\n      value: result\n    };\n  }\n};\nvar streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n  toolCallsStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart\n];\nvar streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n  [toolCallsStreamPart.code]: toolCallsStreamPart,\n  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n  [toolCallStreamPart.code]: toolCallStreamPart,\n  [toolResultStreamPart.code]: toolResultStreamPart,\n  [toolCallStreamingStartStreamPart.code]: toolCallStreamingStartStreamPart,\n  [toolCallDeltaStreamPart.code]: toolCallDeltaStreamPart,\n  [finishMessageStreamPart.code]: finishMessageStreamPart,\n  [finishStepStreamPart.code]: finishStepStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n  [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n  [toolCallStreamPart.name]: toolCallStreamPart.code,\n  [toolResultStreamPart.name]: toolResultStreamPart.code,\n  [toolCallStreamingStartStreamPart.name]: toolCallStreamingStartStreamPart.code,\n  [toolCallDeltaStreamPart.name]: toolCallDeltaStreamPart.code,\n  [finishMessageStreamPart.name]: finishMessageStreamPart.code,\n  [finishStepStreamPart.name]: finishStepStreamPart.code\n};\nvar validCodes = streamParts.map((part) => part.code);\nvar parseStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n  const streamPart = streamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function* readDataStream(reader, {\n  isAborted\n} = {}) {\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts2 = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseStreamPart);\n    for (const streamPart of streamParts2) {\n      yield streamPart;\n    }\n    if (isAborted == null ? void 0 : isAborted()) {\n      reader.cancel();\n      break;\n    }\n  }\n}\n\n// src/process-data-protocol-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n  if (!message || !annotations || !annotations.length)\n    return message;\n  return { ...message, annotations: [...annotations] };\n}\nasync function processDataProtocolResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onToolCall,\n  onFinish,\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date()\n}) {\n  var _a;\n  const createdAt = getCurrentDate();\n  let prefixMap = {};\n  let nextPrefixMap = void 0;\n  const previousMessages = [];\n  const data = [];\n  let message_annotations = void 0;\n  const partialToolCalls = {};\n  let usage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN\n  };\n  let finishReason = \"unknown\";\n  for await (const { type, value } of readDataStream(reader, {\n    isAborted: () => (abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n  })) {\n    if (type === \"error\") {\n      throw new Error(value);\n    }\n    if (type === \"finish_step\") {\n      nextPrefixMap = {};\n      continue;\n    }\n    if (type === \"finish_message\") {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        const { completionTokens, promptTokens } = value.usage;\n        usage = {\n          completionTokens,\n          promptTokens,\n          totalTokens: completionTokens + promptTokens\n        };\n      }\n      continue;\n    }\n    if (nextPrefixMap) {\n      if (prefixMap.text) {\n        previousMessages.push(prefixMap.text);\n      }\n      if (prefixMap.function_call) {\n        previousMessages.push(prefixMap.function_call);\n      }\n      if (prefixMap.tool_calls) {\n        previousMessages.push(prefixMap.tool_calls);\n      }\n      prefixMap = nextPrefixMap;\n      nextPrefixMap = void 0;\n    }\n    if (type === \"text\") {\n      if (prefixMap[\"text\"]) {\n        prefixMap[\"text\"] = {\n          ...prefixMap[\"text\"],\n          content: (prefixMap[\"text\"].content || \"\") + value\n        };\n      } else {\n        prefixMap[\"text\"] = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: value,\n          createdAt\n        };\n      }\n    }\n    if (type === \"tool_call_streaming_start\") {\n      if (prefixMap.text == null) {\n        prefixMap.text = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: \"\",\n          createdAt\n        };\n      }\n      if (prefixMap.text.toolInvocations == null) {\n        prefixMap.text.toolInvocations = [];\n      }\n      partialToolCalls[value.toolCallId] = {\n        text: \"\",\n        toolName: value.toolName,\n        prefixMapIndex: prefixMap.text.toolInvocations.length\n      };\n      prefixMap.text.toolInvocations.push({\n        state: \"partial-call\",\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: void 0\n      });\n    } else if (type === \"tool_call_delta\") {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n      partialToolCall.text += value.argsTextDelta;\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n      prefixMap.text.toolInvocations[partialToolCall.prefixMapIndex] = {\n        state: \"partial-call\",\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs\n      };\n      prefixMap.text.internalUpdateId = generateId2();\n    } else if (type === \"tool_call\") {\n      if (partialToolCalls[value.toolCallId] != null) {\n        prefixMap.text.toolInvocations[partialToolCalls[value.toolCallId].prefixMapIndex] = { state: \"call\", ...value };\n      } else {\n        if (prefixMap.text == null) {\n          prefixMap.text = {\n            id: generateId2(),\n            role: \"assistant\",\n            content: \"\",\n            createdAt\n          };\n        }\n        if (prefixMap.text.toolInvocations == null) {\n          prefixMap.text.toolInvocations = [];\n        }\n        prefixMap.text.toolInvocations.push({\n          state: \"call\",\n          ...value\n        });\n      }\n      prefixMap.text.internalUpdateId = generateId2();\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          prefixMap.text.toolInvocations[prefixMap.text.toolInvocations.length - 1] = { state: \"result\", ...value, result };\n        }\n      }\n    } else if (type === \"tool_result\") {\n      const toolInvocations = (_a = prefixMap.text) == null ? void 0 : _a.toolInvocations;\n      if (toolInvocations == null) {\n        throw new Error(\"tool_result must be preceded by a tool_call\");\n      }\n      const toolInvocationIndex = toolInvocations.findIndex(\n        (invocation) => invocation.toolCallId === value.toolCallId\n      );\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          \"tool_result must be preceded by a tool_call with the same toolCallId\"\n        );\n      }\n      toolInvocations[toolInvocationIndex] = {\n        ...toolInvocations[toolInvocationIndex],\n        state: \"result\",\n        ...value\n      };\n    }\n    let functionCallMessage = null;\n    if (type === \"function_call\") {\n      prefixMap[\"function_call\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        function_call: value.function_call,\n        name: value.function_call.name,\n        createdAt\n      };\n      functionCallMessage = prefixMap[\"function_call\"];\n    }\n    let toolCallMessage = null;\n    if (type === \"tool_calls\") {\n      prefixMap[\"tool_calls\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        tool_calls: value.tool_calls,\n        createdAt\n      };\n      toolCallMessage = prefixMap[\"tool_calls\"];\n    }\n    if (type === \"data\") {\n      data.push(...value);\n    }\n    let responseMessage = prefixMap[\"text\"];\n    if (type === \"message_annotations\") {\n      if (!message_annotations) {\n        message_annotations = [...value];\n      } else {\n        message_annotations.push(...value);\n      }\n      functionCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"function_call\"],\n        message_annotations\n      );\n      toolCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"tool_calls\"],\n        message_annotations\n      );\n      responseMessage = assignAnnotationsToMessage(\n        prefixMap[\"text\"],\n        message_annotations\n      );\n    }\n    if (message_annotations == null ? void 0 : message_annotations.length) {\n      if (prefixMap.text) {\n        prefixMap.text.annotations = [...message_annotations];\n      }\n      if (prefixMap.function_call) {\n        prefixMap.function_call.annotations = [...message_annotations];\n      }\n      if (prefixMap.tool_calls) {\n        prefixMap.tool_calls.annotations = [...message_annotations];\n      }\n    }\n    const merged = [functionCallMessage, toolCallMessage, responseMessage].filter(Boolean).map((message) => ({\n      ...assignAnnotationsToMessage(message, message_annotations)\n    }));\n    update([...previousMessages, ...merged], [...data]);\n  }\n  onFinish == null ? void 0 : onFinish({ message: prefixMap.text, finishReason, usage });\n  return {\n    messages: [\n      prefixMap.text,\n      prefixMap.function_call,\n      prefixMap.tool_calls\n    ].filter(Boolean),\n    data\n  };\n}\n\n// src/call-chat-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callChatApi({\n  api,\n  body,\n  streamProtocol = \"data\",\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId2,\n  fetch: fetch2 = getOriginalFetch()\n}) {\n  var _a, _b;\n  const response = await fetch2(api, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n    credentials\n  }).catch((err) => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (_b = await response.text()) != null ? _b : \"Failed to fetch the chat response.\"\n    );\n  }\n  if (!response.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  const reader = response.body.getReader();\n  switch (streamProtocol) {\n    case \"text\": {\n      const decoder = createChunkDecoder();\n      const resultMessage = {\n        id: generateId2(),\n        createdAt: /* @__PURE__ */ new Date(),\n        role: \"assistant\",\n        content: \"\"\n      };\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n        resultMessage.content += decoder(value);\n        onUpdate([{ ...resultMessage }], []);\n        if ((abortController == null ? void 0 : abortController()) === null) {\n          reader.cancel();\n          break;\n        }\n      }\n      onFinish == null ? void 0 : onFinish(resultMessage, {\n        usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n        finishReason: \"unknown\"\n      });\n      return {\n        messages: [resultMessage],\n        data: []\n      };\n    }\n    case \"data\": {\n      return await processDataProtocolResponse({\n        reader,\n        abortControllerRef: abortController != null ? { current: abortController() } : void 0,\n        update: onUpdate,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId: generateId2\n      });\n    }\n    default: {\n      const exhaustiveCheck = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/call-completion-api.ts\nvar getOriginalFetch2 = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch: fetch2 = getOriginalFetch2()\n}) {\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const res = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (onResponse) {\n      try {\n        await onResponse(res);\n      } catch (err) {\n        throw err;\n      }\n    }\n    if (!res.ok) {\n      throw new Error(\n        await res.text() || \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!res.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    const reader = res.body.getReader();\n    switch (streamProtocol) {\n      case \"text\": {\n        const decoder = createChunkDecoder();\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n          result += decoder(value);\n          setCompletion(result);\n          if (abortController === null) {\n            reader.cancel();\n            break;\n          }\n        }\n        break;\n      }\n      case \"data\": {\n        for await (const { type, value } of readDataStream(reader, {\n          isAborted: () => abortController === null\n        })) {\n          switch (type) {\n            case \"text\": {\n              result += value;\n              setCompletion(result);\n              break;\n            }\n            case \"data\": {\n              onData == null ? void 0 : onData(value);\n              break;\n            }\n          }\n        }\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/create-chunk-decoder.ts\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\").filter((line) => line !== \"\");\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\n\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mimeType = header.split(\";\")[0].split(\":\")[1];\n  if (mimeType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/process-chat-stream.ts\nasync function processChatStream({\n  getStreamedResponse,\n  experimental_onFunctionCall,\n  experimental_onToolCall,\n  updateChatRequest,\n  getCurrentMessages\n}) {\n  while (true) {\n    const messagesAndDataOrJustMessage = await getStreamedResponse();\n    if (\"messages\" in messagesAndDataOrJustMessage) {\n      let hasFollowingResponse = false;\n      for (const message of messagesAndDataOrJustMessage.messages) {\n        if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n          continue;\n        }\n        hasFollowingResponse = true;\n        if (experimental_onFunctionCall) {\n          const functionCall = message.function_call;\n          if (typeof functionCall !== \"object\") {\n            console.warn(\n              \"experimental_onFunctionCall should not be defined when using tools\"\n            );\n            continue;\n          }\n          const functionCallResponse = await experimental_onFunctionCall(\n            getCurrentMessages(),\n            functionCall\n          );\n          if (functionCallResponse === void 0) {\n            hasFollowingResponse = false;\n            break;\n          }\n          updateChatRequest(functionCallResponse);\n        }\n        if (experimental_onToolCall) {\n          const toolCalls = message.tool_calls;\n          if (!Array.isArray(toolCalls) || toolCalls.some((toolCall) => typeof toolCall !== \"object\")) {\n            console.warn(\n              \"experimental_onToolCall should not be defined when using tools\"\n            );\n            continue;\n          }\n          const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n          if (toolCallResponse === void 0) {\n            hasFollowingResponse = false;\n            break;\n          }\n          updateChatRequest(toolCallResponse);\n        }\n      }\n      if (!hasFollowingResponse) {\n        break;\n      }\n    } else {\n      let fixFunctionCallArguments2 = function(response) {\n        for (const message of response.messages) {\n          if (message.tool_calls !== void 0) {\n            for (const toolCall of message.tool_calls) {\n              if (typeof toolCall === \"object\") {\n                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                  toolCall.function.arguments = JSON.stringify(\n                    toolCall.function.arguments\n                  );\n                }\n              }\n            }\n          }\n          if (message.function_call !== void 0) {\n            if (typeof message.function_call === \"object\") {\n              if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                message.function_call.arguments = JSON.stringify(\n                  message.function_call.arguments\n                );\n              }\n            }\n          }\n        }\n      };\n      var fixFunctionCallArguments = fixFunctionCallArguments2;\n      const streamedResponseMessage = messagesAndDataOrJustMessage;\n      if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n        break;\n      }\n      if (experimental_onFunctionCall) {\n        const functionCall = streamedResponseMessage.function_call;\n        if (!(typeof functionCall === \"object\")) {\n          console.warn(\n            \"experimental_onFunctionCall should not be defined when using tools\"\n          );\n          continue;\n        }\n        const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n        if (functionCallResponse === void 0)\n          break;\n        fixFunctionCallArguments2(functionCallResponse);\n        updateChatRequest(functionCallResponse);\n      }\n      if (experimental_onToolCall) {\n        const toolCalls = streamedResponseMessage.tool_calls;\n        if (!(typeof toolCalls === \"object\")) {\n          console.warn(\n            \"experimental_onToolCall should not be defined when using functions\"\n          );\n          continue;\n        }\n        const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n        if (toolCallResponse === void 0)\n          break;\n        fixFunctionCallArguments2(toolCallResponse);\n        updateChatRequest(toolCallResponse);\n      }\n    }\n  }\n}\n\n// src/schema.ts\n\n\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\nfunction zodSchema(zodSchema2) {\n  return jsonSchema(\n    // we assume that zodToJsonSchema will return a valid JSONSchema7:\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(zodSchema2),\n    {\n      validate: (value) => {\n        const result = zodSchema2.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNvRDs7QUFFcEQ7QUFDMEU7O0FBRTFFO0FBQzJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBZ0I7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZUFBZSxvREFBZ0I7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQWtCO0FBQzlDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOEZBQThGO0FBQzlGLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpQkFBaUI7QUFDM0Q7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5Qyw4Q0FBOEM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQTREO0FBQzdFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lEO0FBQ1I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1FQUFlO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFpQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvdW5zZWxsaW5nLXRocm91Z2gtYmlibGUtZnVsbHN0YWNrLy4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvdWktdXRpbHMvZGlzdC9pbmRleC5tanM/MTkxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvcHJvY2Vzcy1kYXRhLXByb3RvY29sLXJlc3BvbnNlLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmltcG9ydCBTZWN1cmVKU09OIGZyb20gXCJzZWN1cmUtanNvbi1wYXJzZVwiO1xuXG4vLyBzcmMvZml4LWpzb24udHNcbmZ1bmN0aW9uIGZpeEpzb24oaW5wdXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbXCJST09UXCJdO1xuICBsZXQgbGFzdFZhbGlkSW5kZXggPSAtMTtcbiAgbGV0IGxpdGVyYWxTdGFydCA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIHN3YXBTdGF0ZSkge1xuICAgIHtcbiAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgIGNhc2UgXCJuXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9MSVRFUkFMXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIntcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIltcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBzd2l0Y2ggKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgY2FzZSBcIlJPT1RcIjpcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJGSU5JU0hcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCI6XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdfRVNDQVBFXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX05VTUJFUlwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZVwiOlxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICBjYXNlIFwiLlwiOiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGkgKyAxKTtcbiAgICAgICAgaWYgKCFcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGlucHV0LnNsaWNlKDAsIGxhc3RWYWxpZEluZGV4ICsgMSk7XG4gIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN0YXRlID0gc3RhY2tbaV07XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICByZXN1bHQgKz0gJ1wiJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICBpZiAoXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJ0cnVlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJmYWxzZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJudWxsXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5mdW5jdGlvbiBwYXJzZVBhcnRpYWxKc29uKGpzb25UZXh0KSB7XG4gIGlmIChqc29uVGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwidW5kZWZpbmVkLWlucHV0XCIgfTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogU2VjdXJlSlNPTi5wYXJzZShqc29uVGV4dCksXG4gICAgICBzdGF0ZTogXCJzdWNjZXNzZnVsLXBhcnNlXCJcbiAgICB9O1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBTZWN1cmVKU09OLnBhcnNlKGZpeEpzb24oanNvblRleHQpKSxcbiAgICAgICAgc3RhdGU6IFwicmVwYWlyZWQtcGFyc2VcIlxuICAgICAgfTtcbiAgICB9IGNhdGNoIChpZ25vcmVkMikge1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBzdGF0ZTogXCJmYWlsZWQtcGFyc2VcIiB9O1xufVxuXG4vLyBzcmMvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNVwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidGhyZWFkSWRcIiBpbiB2YWx1ZSkgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI2XCIsXG4gIG5hbWU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJkYXRhXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiN1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbHNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbF9jYWxsc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHwgdmFsdWUudG9vbF9jYWxscy5zb21lKFxuICAgICAgKHRjKSA9PiB0YyA9PSBudWxsIHx8IHR5cGVvZiB0YyAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB0YykgfHwgdHlwZW9mIHRjLmlkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0eXBlXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy50eXBlICE9PSBcInN0cmluZ1wiIHx8ICEoXCJmdW5jdGlvblwiIGluIHRjKSB8fCB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdGMuZnVuY3Rpb24pIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOVwiLFxuICBuYW1lOiBcInRvb2xfY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0b29sTmFtZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIsIFwidG9vbE5hbWVcIiwgYW5kIFwiYXJnc1wiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xSZXN1bHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImFcIixcbiAgbmFtZTogXCJ0b29sX3Jlc3VsdFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJyZXN1bHRcIiBpbiB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9yZXN1bHRcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgYSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfcmVzdWx0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiYlwiLFxuICBuYW1lOiBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidG9vbE5hbWVcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgXCJ0b29sTmFtZVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbERlbHRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJjXCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsX2RlbHRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NUZXh0RGVsdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3NUZXh0RGVsdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsX2RlbHRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIgYW5kIFwiYXJnc1RleHREZWx0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbF9kZWx0YVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGZpbmlzaE1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImRcIixcbiAgbmFtZTogXCJmaW5pc2hfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmaW5pc2hSZWFzb25cIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZpbmlzaFJlYXNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmaW5pc2hfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZmluaXNoUmVhc29uXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZmluaXNoUmVhc29uOiB2YWx1ZS5maW5pc2hSZWFzb25cbiAgICB9O1xuICAgIGlmIChcInVzYWdlXCIgaW4gdmFsdWUgJiYgdmFsdWUudXNhZ2UgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudXNhZ2UgPT09IFwib2JqZWN0XCIgJiYgXCJwcm9tcHRUb2tlbnNcIiBpbiB2YWx1ZS51c2FnZSAmJiBcImNvbXBsZXRpb25Ub2tlbnNcIiBpbiB2YWx1ZS51c2FnZSkge1xuICAgICAgcmVzdWx0LnVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgOiBOdW1iZXIuTmFOLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgOiBOdW1iZXIuTmFOXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmaW5pc2hfbWVzc2FnZVwiLFxuICAgICAgdmFsdWU6IHJlc3VsdFxuICAgIH07XG4gIH1cbn07XG52YXIgZmluaXNoU3RlcFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZVwiLFxuICBuYW1lOiBcImZpbmlzaF9zdGVwXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZpbmlzaFJlYXNvblwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZmluaXNoUmVhc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZpbmlzaF9zdGVwXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmaW5pc2hSZWFzb25cIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvblxuICAgIH07XG4gICAgaWYgKFwidXNhZ2VcIiBpbiB2YWx1ZSAmJiB2YWx1ZS51c2FnZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS51c2FnZSA9PT0gXCJvYmplY3RcIiAmJiBcInByb21wdFRva2Vuc1wiIGluIHZhbHVlLnVzYWdlICYmIFwiY29tcGxldGlvblRva2Vuc1wiIGluIHZhbHVlLnVzYWdlKSB7XG4gICAgICByZXN1bHQudXNhZ2UgPSB7XG4gICAgICAgIHByb21wdFRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA6IE51bWJlci5OYU4sXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA6IE51bWJlci5OYU5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZpbmlzaF9zdGVwXCIsXG4gICAgICB2YWx1ZTogcmVzdWx0XG4gICAgfTtcbiAgfVxufTtcbnZhciBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxzU3RyZWFtUGFydCxcbiAgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICB0b29sUmVzdWx0U3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LFxuICBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCxcbiAgZmluaXNoU3RlcFN0cmVhbVBhcnRcbl07XG52YXIgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxzU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxzU3RyZWFtUGFydCxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgW3Rvb2xSZXN1bHRTdHJlYW1QYXJ0LmNvZGVdOiB0b29sUmVzdWx0U3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbERlbHRhU3RyZWFtUGFydCxcbiAgW2ZpbmlzaE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCxcbiAgW2ZpbmlzaFN0ZXBTdHJlYW1QYXJ0LmNvZGVdOiBmaW5pc2hTdGVwU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsc1N0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsc1N0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sUmVzdWx0U3RyZWFtUGFydC5uYW1lXTogdG9vbFJlc3VsdFN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxEZWx0YVN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmaW5pc2hNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2ZpbmlzaFN0ZXBTdHJlYW1QYXJ0Lm5hbWVdOiBmaW5pc2hTdGVwU3RyZWFtUGFydC5jb2RlXG59O1xudmFyIHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuY29kZSk7XG52YXIgcGFyc2VTdHJlYW1QYXJ0ID0gKGxpbmUpID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuICBjb25zdCBjb2RlID0gcHJlZml4O1xuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuICByZXR1cm4gc3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5mdW5jdGlvbiBmb3JtYXRTdHJlYW1QYXJ0KHR5cGUsIHZhbHVlKSB7XG4gIGNvbnN0IHN0cmVhbVBhcnQgPSBzdHJlYW1QYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0Lm5hbWUgPT09IHR5cGUpO1xuICBpZiAoIXN0cmVhbVBhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RyZWFtIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxuYDtcbn1cblxuLy8gc3JjL3JlYWQtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gIGlzQWJvcnRlZFxufSA9IHt9KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzMiA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMyKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cbiAgICBpZiAoaXNBYm9ydGVkID09IG51bGwgPyB2b2lkIDAgOiBpc0Fib3J0ZWQoKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9wcm9jZXNzLWRhdGEtcHJvdG9jb2wtcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIGFubm90YXRpb25zKSB7XG4gIGlmICghbWVzc2FnZSB8fCAhYW5ub3RhdGlvbnMgfHwgIWFubm90YXRpb25zLmxlbmd0aClcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgcmV0dXJuIHsgLi4ubWVzc2FnZSwgYW5ub3RhdGlvbnM6IFsuLi5hbm5vdGF0aW9uc10gfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uVG9vbENhbGwsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRGdW5jdGlvbixcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxufSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGxldCBwcmVmaXhNYXAgPSB7fTtcbiAgbGV0IG5leHRQcmVmaXhNYXAgPSB2b2lkIDA7XG4gIGNvbnN0IHByZXZpb3VzTWVzc2FnZXMgPSBbXTtcbiAgY29uc3QgZGF0YSA9IFtdO1xuICBsZXQgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IHZvaWQgMDtcbiAgY29uc3QgcGFydGlhbFRvb2xDYWxscyA9IHt9O1xuICBsZXQgdXNhZ2UgPSB7XG4gICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgIHByb21wdFRva2VuczogTmFOLFxuICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgfTtcbiAgbGV0IGZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICBpc0Fib3J0ZWQ6ICgpID0+IChhYm9ydENvbnRyb2xsZXJSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSA9PT0gbnVsbFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImZpbmlzaF9zdGVwXCIpIHtcbiAgICAgIG5leHRQcmVmaXhNYXAgPSB7fTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJmaW5pc2hfbWVzc2FnZVwiKSB7XG4gICAgICBmaW5pc2hSZWFzb24gPSB2YWx1ZS5maW5pc2hSZWFzb247XG4gICAgICBpZiAodmFsdWUudXNhZ2UgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGNvbXBsZXRpb25Ub2tlbnMsIHByb21wdFRva2VucyB9ID0gdmFsdWUudXNhZ2U7XG4gICAgICAgIHVzYWdlID0ge1xuICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgcHJvbXB0VG9rZW5zLFxuICAgICAgICAgIHRvdGFsVG9rZW5zOiBjb21wbGV0aW9uVG9rZW5zICsgcHJvbXB0VG9rZW5zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5leHRQcmVmaXhNYXApIHtcbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dCkge1xuICAgICAgICBwcmV2aW91c01lc3NhZ2VzLnB1c2gocHJlZml4TWFwLnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgIHByZXZpb3VzTWVzc2FnZXMucHVzaChwcmVmaXhNYXAuZnVuY3Rpb25fY2FsbCk7XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4TWFwLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgcHJldmlvdXNNZXNzYWdlcy5wdXNoKHByZWZpeE1hcC50b29sX2NhbGxzKTtcbiAgICAgIH1cbiAgICAgIHByZWZpeE1hcCA9IG5leHRQcmVmaXhNYXA7XG4gICAgICBuZXh0UHJlZml4TWFwID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbXCJ0ZXh0XCJdKSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgLi4ucHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwW1widGV4dFwiXS5jb250ZW50IHx8IFwiXCIpICsgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiKSB7XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dCA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICB9XG4gICAgICBwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdID0ge1xuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICB0b29sTmFtZTogdmFsdWUudG9vbE5hbWUsXG4gICAgICAgIHByZWZpeE1hcEluZGV4OiBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMubGVuZ3RoXG4gICAgICB9O1xuICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLnB1c2goe1xuICAgICAgICBzdGF0ZTogXCJwYXJ0aWFsLWNhbGxcIixcbiAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHZhbHVlLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxfZGVsdGFcIikge1xuICAgICAgY29uc3QgcGFydGlhbFRvb2xDYWxsID0gcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXTtcbiAgICAgIHBhcnRpYWxUb29sQ2FsbC50ZXh0ICs9IHZhbHVlLmFyZ3NUZXh0RGVsdGE7XG4gICAgICBjb25zdCB7IHZhbHVlOiBwYXJ0aWFsQXJncyB9ID0gcGFyc2VQYXJ0aWFsSnNvbihwYXJ0aWFsVG9vbENhbGwudGV4dCk7XG4gICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnNbcGFydGlhbFRvb2xDYWxsLnByZWZpeE1hcEluZGV4XSA9IHtcbiAgICAgICAgc3RhdGU6IFwicGFydGlhbC1jYWxsXCIsXG4gICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiBwYXJ0aWFsVG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgIGFyZ3M6IHBhcnRpYWxBcmdzXG4gICAgICB9O1xuICAgICAgcHJlZml4TWFwLnRleHQuaW50ZXJuYWxVcGRhdGVJZCA9IGdlbmVyYXRlSWQyKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRvb2xfY2FsbFwiKSB7XG4gICAgICBpZiAocGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXSAhPSBudWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9uc1twYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdLnByZWZpeE1hcEluZGV4XSA9IHsgc3RhdGU6IFwiY2FsbFwiLCAuLi52YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICBwcmVmaXhNYXAudGV4dCA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucy5wdXNoKHtcbiAgICAgICAgICBzdGF0ZTogXCJjYWxsXCIsXG4gICAgICAgICAgLi4udmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcmVmaXhNYXAudGV4dC5pbnRlcm5hbFVwZGF0ZUlkID0gZ2VuZXJhdGVJZDIoKTtcbiAgICAgIGlmIChvblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9uVG9vbENhbGwoeyB0b29sQ2FsbDogdmFsdWUgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9uc1twcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMubGVuZ3RoIC0gMV0gPSB7IHN0YXRlOiBcInJlc3VsdFwiLCAuLi52YWx1ZSwgcmVzdWx0IH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidG9vbF9yZXN1bHRcIikge1xuICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gKF9hID0gcHJlZml4TWFwLnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b29sSW52b2NhdGlvbnM7XG4gICAgICBpZiAodG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vbF9yZXN1bHQgbXVzdCBiZSBwcmVjZWRlZCBieSBhIHRvb2xfY2FsbFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uSW5kZXggPSB0b29sSW52b2NhdGlvbnMuZmluZEluZGV4KFxuICAgICAgICAoaW52b2NhdGlvbikgPT4gaW52b2NhdGlvbi50b29sQ2FsbElkID09PSB2YWx1ZS50b29sQ2FsbElkXG4gICAgICApO1xuICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcInRvb2xfcmVzdWx0IG11c3QgYmUgcHJlY2VkZWQgYnkgYSB0b29sX2NhbGwgd2l0aCB0aGUgc2FtZSB0b29sQ2FsbElkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRvb2xJbnZvY2F0aW9uc1t0b29sSW52b2NhdGlvbkluZGV4XSA9IHtcbiAgICAgICAgLi4udG9vbEludm9jYXRpb25zW3Rvb2xJbnZvY2F0aW9uSW5kZXhdLFxuICAgICAgICBzdGF0ZTogXCJyZXN1bHRcIixcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdO1xuICAgIH1cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICB0b29sX2NhbGxzOiB2YWx1ZS50b29sX2NhbGxzLFxuICAgICAgICBjcmVhdGVkQXRcbiAgICAgIH07XG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgIGRhdGEucHVzaCguLi52YWx1ZSk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0ZXh0XCJdO1xuICAgIGlmICh0eXBlID09PSBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIikge1xuICAgICAgaWYgKCFtZXNzYWdlX2Fubm90YXRpb25zKSB7XG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMgPSBbLi4udmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucy5wdXNoKC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlX2Fubm90YXRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlX2Fubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0KSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VfYW5ub3RhdGlvbnNdO1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsLmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VfYW5ub3RhdGlvbnNdO1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC50b29sX2NhbGxzKSB7XG4gICAgICAgIHByZWZpeE1hcC50b29sX2NhbGxzLmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VfYW5ub3RhdGlvbnNdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgdG9vbENhbGxNZXNzYWdlLCByZXNwb25zZU1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKS5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAuLi5hc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBtZXNzYWdlX2Fubm90YXRpb25zKVxuICAgIH0pKTtcbiAgICB1cGRhdGUoWy4uLnByZXZpb3VzTWVzc2FnZXMsIC4uLm1lcmdlZF0sIFsuLi5kYXRhXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHsgbWVzc2FnZTogcHJlZml4TWFwLnRleHQsIGZpbmlzaFJlYXNvbiwgdXNhZ2UgfSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGFcbiAgfTtcbn1cblxuLy8gc3JjL2NhbGwtY2hhdC1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ2hhdEFwaSh7XG4gIGFwaSxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIG9uVG9vbENhbGwsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfSxcbiAgICBzaWduYWw6IChfYSA9IGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduYWwsXG4gICAgY3JlZGVudGlhbHNcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKF9iID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2IgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICBjb25zdCByZXN1bHRNZXNzYWdlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgY3JlYXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogXCJcIlxuICAgICAgfTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TWVzc2FnZS5jb250ZW50ICs9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICBvblVwZGF0ZShbeyAuLi5yZXN1bHRNZXNzYWdlIH1dLCBbXSk7XG4gICAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT09IG51bGwpIHtcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaChyZXN1bHRNZXNzYWdlLCB7XG4gICAgICAgIHVzYWdlOiB7IGNvbXBsZXRpb25Ub2tlbnM6IE5hTiwgcHJvbXB0VG9rZW5zOiBOYU4sIHRvdGFsVG9rZW5zOiBOYU4gfSxcbiAgICAgICAgZmluaXNoUmVhc29uOiBcInVua25vd25cIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlczogW3Jlc3VsdE1lc3NhZ2VdLFxuICAgICAgICBkYXRhOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSh7XG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmOiBhYm9ydENvbnRyb2xsZXIgIT0gbnVsbCA/IHsgY3VycmVudDogYWJvcnRDb250cm9sbGVyKCkgfSA6IHZvaWQgMCxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25Ub29sQ2FsbCxcbiAgICAgICAgb25GaW5pc2goeyBtZXNzYWdlLCBmaW5pc2hSZWFzb24sIHVzYWdlIH0pIHtcbiAgICAgICAgICBpZiAob25GaW5pc2ggJiYgbWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBvbkZpbmlzaChtZXNzYWdlLCB7IHVzYWdlLCBmaW5pc2hSZWFzb24gfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMlxuICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHN0cmVhbVByb3RvY29sO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBwcm90b2NvbDogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaDIgPSAoKSA9PiBmZXRjaDtcbmFzeW5jIGZ1bmN0aW9uIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgYXBpLFxuICBwcm9tcHQsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Qcm90b2NvbCA9IFwiZGF0YVwiLFxuICBzZXRDb21wbGV0aW9uLFxuICBzZXRMb2FkaW5nLFxuICBzZXRFcnJvcixcbiAgc2V0QWJvcnRDb250cm9sbGVyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgb25EYXRhLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaDIoKVxufSkge1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG4gICAgc2V0Q29tcGxldGlvbihcIlwiKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBhd2FpdCByZXMudGV4dCgpIHx8IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgICAgICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXIgPT09IG51bGxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICAgICAgICBvbkRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YSh2YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvY3JlYXRlLWNodW5rLWRlY29kZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICBpZiAoIWNodW5rKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIik7XG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxuXG4vLyBzcmMvZGF0YS11cmwudHNcbmZ1bmN0aW9uIGdldFRleHRGcm9tRGF0YVVybChkYXRhVXJsKSB7XG4gIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gIGNvbnN0IG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBVUkwgZm9ybWF0XCIpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKGJhc2U2NENvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjb2RpbmcgZGF0YSBVUkxgKTtcbiAgfVxufVxuXG4vLyBzcmMvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIHVwZGF0ZUNoYXRSZXF1ZXN0LFxuICBnZXRDdXJyZW50TWVzc2FnZXNcbn0pIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSgpO1xuICAgIGlmIChcIm1lc3NhZ2VzXCIgaW4gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSkge1xuICAgICAgbGV0IGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgICBpZiAoKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwic3RyaW5nXCIpICYmIChtZXNzYWdlLnRvb2xfY2FsbHMgPT09IHZvaWQgMCB8fCB0eXBlb2YgbWVzc2FnZS50b29sX2NhbGxzID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IG1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uQ2FsbCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzKCksXG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRvb2xDYWxscykgfHwgdG9vbENhbGxzLnNvbWUoKHRvb2xDYWxsKSA9PiB0eXBlb2YgdG9vbENhbGwgIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0b29sQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsUmVzcG9uc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czIgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcmVzcG9uc2UubWVzc2FnZXMpIHtcbiAgICAgICAgICBpZiAobWVzc2FnZS50b29sX2NhbGxzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbENhbGwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzICYmIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgJiYgdHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMgPSBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyO1xuICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuICAgICAgaWYgKChzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDAgfHwgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwic3RyaW5nXCIpICYmIChzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSB2b2lkIDAgfHwgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICBpZiAoISh0eXBlb2YgZnVuY3Rpb25DYWxsID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCBmdW5jdGlvbkNhbGwpO1xuICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHZvaWQgMClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMihmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICBpZiAoISh0eXBlb2YgdG9vbENhbGxzID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgZnVuY3Rpb25zXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcbiAgICAgICAgaWYgKHRvb2xDYWxsUmVzcG9uc2UgPT09IHZvaWQgMClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMih0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9zY2hlbWEudHNcbmltcG9ydCB7IHZhbGlkYXRvclN5bWJvbCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcbnZhciBzY2hlbWFTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnNjaGVtYVwiKTtcbmZ1bmN0aW9uIGpzb25TY2hlbWEoanNvblNjaGVtYTIsIHtcbiAgdmFsaWRhdGVcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIFtzY2hlbWFTeW1ib2xdOiB0cnVlLFxuICAgIF90eXBlOiB2b2lkIDAsXG4gICAgLy8gc2hvdWxkIG5ldmVyIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSxcbiAgICBqc29uU2NoZW1hOiBqc29uU2NoZW1hMixcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gaXNTY2hlbWEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBzY2hlbWFTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbc2NoZW1hU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcImpzb25TY2hlbWFcIiBpbiB2YWx1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIGlzU2NoZW1hKHNjaGVtYSkgPyBzY2hlbWEgOiB6b2RTY2hlbWEoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIHpvZFNjaGVtYSh6b2RTY2hlbWEyKSB7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgIC8vIHdlIGFzc3VtZSB0aGF0IHpvZFRvSnNvblNjaGVtYSB3aWxsIHJldHVybiBhIHZhbGlkIEpTT05TY2hlbWE3OlxuICAgIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEyKSxcbiAgICB7XG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYTIuc2FmZVBhcnNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5leHBvcnQge1xuICBhc1NjaGVtYSxcbiAgY2FsbENoYXRBcGksXG4gIGNhbGxDb21wbGV0aW9uQXBpLFxuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBqc29uU2NoZW1hLFxuICBwYXJzZVBhcnRpYWxKc29uLFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHByb2Nlc3NDaGF0U3RyZWFtLFxuICBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2UsXG4gIHJlYWREYXRhU3RyZWFtLFxuICB6b2RTY2hlbWFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncGeneratorToReadableStream: () => (/* binding */ convertAsyncGeneratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isParseableJson: () => (/* binding */ isParseableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventsource-parser/stream */ \"(rsc)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-generator-to-readable-stream.ts\nfunction convertAsyncGeneratorToReadableStream(stream) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\nvar createIdGenerator = ({\n  prefix = \"\",\n  size: defaultSize = 7,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n} = {}) => {\n  const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n  return (size) => `${prefix}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n\n// src/validate-types.ts\n\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isTypeValidationError(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar isParseableJson = isParsableJson;\n\n// src/post-to-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/post-to-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/response-handler.ts\n\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__.EventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value\n  };\n};\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTixvQkFBb0IsaUVBQWM7QUFDbEMsc0JBQXNCLE9BQU8sRUFBRSxnQkFBZ0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBZTtBQUM3QixrQkFBa0IsYUFBYTtBQUMvQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0Isa0JBQWtCLGFBQWEseUNBQXlDLG9CQUFvQjtBQUM1RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBZTtBQUM3QixrQkFBa0IsYUFBYSx5Q0FBeUMsb0JBQW9CLHFCQUFx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LGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQSxjQUFjLG9FQUFzQixHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0NBQWtDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLDBEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFnQ0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvdW5zZWxsaW5nLXRocm91Z2gtYmlibGUtZnVsbHN0YWNrLy4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvdWktdXRpbHMvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanM/NTU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29tYmluZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBjb21iaW5lSGVhZGVycyguLi5oZWFkZXJzKSB7XG4gIHJldHVybiBoZWFkZXJzLnJlZHVjZShcbiAgICAoY29tYmluZWRIZWFkZXJzLCBjdXJyZW50SGVhZGVycykgPT4gKHtcbiAgICAgIC4uLmNvbWJpbmVkSGVhZGVycyxcbiAgICAgIC4uLmN1cnJlbnRIZWFkZXJzICE9IG51bGwgPyBjdXJyZW50SGVhZGVycyA6IHt9XG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuLy8gc3JjL2NvbnZlcnQtYXN5bmMtZ2VuZXJhdG9yLXRvLXJlYWRhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY29udmVydEFzeW5jR2VuZXJhdG9yVG9SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN1bWVyIHdhbnRzIHRvIHB1bGwgbW9yZSBkYXRhIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxUPn0gY29udHJvbGxlciAtIFRoZSBjb250cm9sbGVyIHRvIGVucXVldWUgZGF0YSBpbnRvIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciBjYW5jZWxzIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9leHRyYWN0LXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtaWQudHNcbmltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSBcIm5hbm9pZC9ub24tc2VjdXJlXCI7XG52YXIgY3JlYXRlSWRHZW5lcmF0b3IgPSAoe1xuICBwcmVmaXggPSBcIlwiLFxuICBzaXplOiBkZWZhdWx0U2l6ZSA9IDcsXG4gIGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiXG59ID0ge30pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gY3VzdG9tQWxwaGFiZXQoYWxwaGFiZXQsIGRlZmF1bHRTaXplKTtcbiAgcmV0dXJuIChzaXplKSA9PiBgJHtwcmVmaXh9JHtnZW5lcmF0b3Ioc2l6ZSl9YDtcbn07XG52YXIgZ2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCk7XG5cbi8vIHNyYy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvaXMtYWJvcnQtZXJyb3IudHNcbmZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyb3IubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIik7XG59XG5cbi8vIHNyYy9sb2FkLWFwaS1rZXkudHNcbmltcG9ydCB7IExvYWRBUElLZXlFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkQXBpS2V5KHtcbiAgYXBpS2V5LFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgYXBpS2V5UGFyYW1ldGVyTmFtZSA9IFwiYXBpS2V5XCIsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGFwaUtleTtcbiAgfVxuICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgYXBpS2V5ID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbi8vIHNyYy9sb2FkLXNldHRpbmcudHNcbmltcG9ydCB7IExvYWRTZXR0aW5nRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gbG9hZFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBzZXR0aW5nTmFtZSxcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBzZXR0aW5nVmFsdWUgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChzZXR0aW5nVmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyIG9yIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZS5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL2xvYWQtb3B0aW9uYWwtc2V0dGluZy50c1xuZnVuY3Rpb24gbG9hZE9wdGlvbmFsU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCB8fCB0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0dGluZ1ZhbHVlID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoc2V0dGluZ1ZhbHVlID09IG51bGwgfHwgdHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmltcG9ydCB7XG4gIEpTT05QYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgU2VjdXJlSlNPTiBmcm9tIFwic2VjdXJlLWpzb24tcGFyc2VcIjtcblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5pbXBvcnQgeyBUeXBlVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3ZhbGlkYXRvci50c1xudmFyIHZhbGlkYXRvclN5bWJvbCA9IFN5bWJvbC5mb3IoXCJ2ZXJjZWwuYWkudmFsaWRhdG9yXCIpO1xuZnVuY3Rpb24gdmFsaWRhdG9yKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7IFt2YWxpZGF0b3JTeW1ib2xdOiB0cnVlLCB2YWxpZGF0ZSB9O1xufVxuZnVuY3Rpb24gaXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWxpZGF0b3JTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbdmFsaWRhdG9yU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gaXNWYWxpZGF0b3IodmFsdWUpID8gdmFsdWUgOiB6b2RWYWxpZGF0b3IodmFsdWUpO1xufVxuZnVuY3Rpb24gem9kVmFsaWRhdG9yKHpvZFNjaGVtYSkge1xuICByZXR1cm4gdmFsaWRhdG9yKCh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYS5zYWZlUGFyc2UodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gIH0pO1xufVxuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkge1xuICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCB2YWxpZGF0b3IyID0gYXNWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAodmFsaWRhdG9yMi52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IyLnZhbGlkYXRlKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLnRzXG5mdW5jdGlvbiBwYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNlY3VyZUpTT04ucGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoSlNPTlBhcnNlRXJyb3IuaXNKU09OUGFyc2VFcnJvcihlcnJvcikgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjIuaXNUeXBlVmFsaWRhdGlvbkVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBKU09OUGFyc2VFcnJvcih7IHRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZVBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gU2VjdXJlSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBKU09OUGFyc2VFcnJvci5pc0pTT05QYXJzZUVycm9yKGVycm9yKSA/IGVycm9yIDogbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBTZWN1cmVKU09OLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxudmFyIGlzUGFyc2VhYmxlSnNvbiA9IGlzUGFyc2FibGVKc29uO1xuXG4vLyBzcmMvcG9zdC10by1hcGkudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9yZW1vdmUtdW5kZWZpbmVkLWVudHJpZXMudHNcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMocmVjb3JkKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMocmVjb3JkKS5maWx0ZXIoKFtfa2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpXG4gICk7XG59XG5cbi8vIHNyYy9wb3N0LXRvLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBnbG9iYWxUaGlzLmZldGNoO1xudmFyIHBvc3RKc29uVG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KSA9PiBwb3N0VG9BcGkoe1xuICB1cmwsXG4gIGhlYWRlcnM6IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAuLi5oZWFkZXJzXG4gIH0sXG4gIGJvZHk6IHtcbiAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB2YWx1ZXM6IGJvZHlcbiAgfSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pO1xudmFyIHBvc3RUb0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyA9IHt9LFxuICBib2R5LFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaCA9IGdldE9yaWdpbmFsRmV0Y2goKVxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhoZWFkZXJzKSxcbiAgICAgIGJvZHk6IGJvZHkuY29udGVudCxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JJbmZvcm1hdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9ySW5mb3JtYXRpb24gPSBhd2FpdCBmYWlsZWRSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IuaXNBUElDYWxsRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBlcnJvciByZXNwb25zZVwiLFxuICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvckluZm9ybWF0aW9uLnZhbHVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IuaXNBUElDYWxsRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSB7XG4gICAgICBjb25zdCBjYXVzZSA9IGVycm9yLmNhdXNlO1xuICAgICAgaWYgKGNhdXNlICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjb25uZWN0IHRvIEFQSTogJHtjYXVzZS5tZXNzYWdlfWAsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlcyxcbiAgICAgICAgICBpc1JldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIC8vIHJldHJ5IHdoZW4gbmV0d29yayBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNwb25zZS1oYW5kbGVyLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMiwgRW1wdHlSZXNwb25zZUJvZHlFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBFdmVudFNvdXJjZVBhcnNlclN0cmVhbVxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyL3N0cmVhbVwiO1xudmFyIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciA9ICh7XG4gIGVycm9yU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZSxcbiAgaXNSZXRyeWFibGVcbn0pID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlQm9keS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZEVycm9yID0gcGFyc2VKU09OKHtcbiAgICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICAgIHNjaGVtYTogZXJyb3JTY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3JUb01lc3NhZ2UocGFyc2VkRXJyb3IpLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBkYXRhOiBwYXJzZWRFcnJvcixcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSwgcGFyc2VkRXJyb3IpXG4gICAgICB9KVxuICAgIH07XG4gIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFbXB0eVJlc3BvbnNlQm9keUVycm9yKHt9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2gobmV3IEV2ZW50U291cmNlUGFyc2VyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybSh7IGRhdGEgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmIChkYXRhID09PSBcIltET05FXVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgIHNhZmVQYXJzZUpTT04oe1xuICAgICAgICAgICAgICB0ZXh0OiBkYXRhLFxuICAgICAgICAgICAgICBzY2hlbWE6IGNodW5rU2NoZW1hXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKVxuICB9O1xufTtcbnZhciBjcmVhdGVKc29uU3RyZWFtUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIGxldCBidWZmZXIgPSBcIlwiO1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rVGV4dCwgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmIChjaHVua1RleHQuZW5kc1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgICAgdGV4dDogYnVmZmVyICsgY2h1bmtUZXh0LFxuICAgICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtUZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2VTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHtcbiAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgc2NoZW1hOiByZXNwb25zZVNjaGVtYVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcGFyc2VkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgSlNPTiByZXNwb25zZVwiLFxuICAgICAgY2F1c2U6IHBhcnNlZFJlc3VsdC5lcnJvcixcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHBhcnNlZFJlc3VsdC52YWx1ZVxuICB9O1xufTtcblxuLy8gc3JjL3VpbnQ4LXV0aWxzLnRzXG52YXIgeyBidG9hLCBhdG9iIH0gPSBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gY29udmVydEJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpIHtcbiAgY29uc3QgYmFzZTY0VXJsID0gYmFzZTY0U3RyaW5nLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICBjb25zdCBsYXRpbjFzdHJpbmcgPSBhdG9iKGJhc2U2NFVybCk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20obGF0aW4xc3RyaW5nLCAoYnl0ZSkgPT4gYnl0ZS5jb2RlUG9pbnRBdCgwKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGFycmF5KSB7XG4gIGxldCBsYXRpbjFzdHJpbmcgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGF0aW4xc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gYnRvYShsYXRpbjFzdHJpbmcpO1xufVxuXG4vLyBzcmMvd2l0aG91dC10cmFpbGluZy1zbGFzaC50c1xuZnVuY3Rpb24gd2l0aG91dFRyYWlsaW5nU2xhc2godXJsKSB7XG4gIHJldHVybiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG59XG5leHBvcnQge1xuICBhc1ZhbGlkYXRvcixcbiAgY29tYmluZUhlYWRlcnMsXG4gIGNvbnZlcnRBc3luY0dlbmVyYXRvclRvUmVhZGFibGVTdHJlYW0sXG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQsXG4gIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVJZEdlbmVyYXRvcixcbiAgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVKc29uU3RyZWFtUmVzcG9uc2VIYW5kbGVyLFxuICBleHRyYWN0UmVzcG9uc2VIZWFkZXJzLFxuICBnZW5lcmF0ZUlkLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzQWJvcnRFcnJvcixcbiAgaXNQYXJzYWJsZUpzb24sXG4gIGlzUGFyc2VhYmxlSnNvbixcbiAgaXNWYWxpZGF0b3IsXG4gIGxvYWRBcGlLZXksXG4gIGxvYWRPcHRpb25hbFNldHRpbmcsXG4gIGxvYWRTZXR0aW5nLFxuICBwYXJzZUpTT04sXG4gIHBvc3RKc29uVG9BcGksXG4gIHBvc3RUb0FwaSxcbiAgc2FmZVBhcnNlSlNPTixcbiAgc2FmZVZhbGlkYXRlVHlwZXMsXG4gIHZhbGlkYXRlVHlwZXMsXG4gIHZhbGlkYXRvcixcbiAgdmFsaWRhdG9yU3ltYm9sLFxuICB3aXRob3V0VHJhaWxpbmdTbGFzaCxcbiAgem9kVmFsaWRhdG9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name13,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name13;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker14) {\n    const markerSymbol = Symbol.for(marker14);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message\n    };\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error) {\n    return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data\n    };\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(error) {\n    return error instanceof Error && error.name === name2;\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-prompt-error.ts\nvar name3 = \"AI_InvalidPromptError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt: prompt2,\n    message,\n    cause\n  }) {\n    super({ name: name3, message: `Invalid prompt: ${message}`, cause });\n    this[_a4] = true;\n    this.prompt = prompt2;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error) {\n    return error instanceof Error && error.name === name3 && prompt != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      prompt: this.prompt\n    };\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-response-data-error.ts\nvar name4 = \"AI_InvalidResponseDataError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name4, message });\n    this[_a5] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(error) {\n    return error instanceof Error && error.name === name4 && error.data != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      data: this.data\n    };\n  }\n};\n_a5 = symbol5;\n\n// src/errors/json-parse-error.ts\nvar name5 = \"AI_JSONParseError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name5,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a6] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error) {\n    return error instanceof Error && error.name === name5 && \"text\" in error && typeof error.text === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      valueText: this.text\n    };\n  }\n};\n_a6 = symbol6;\n\n// src/errors/load-api-key-error.ts\nvar name6 = \"AI_LoadAPIKeyError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name6, message });\n    this[_a7] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-setting-error.ts\nvar name7 = \"AI_LoadSettingError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error) {\n    return error instanceof Error && error.name === name7;\n  }\n};\n_a8 = symbol8;\n\n// src/errors/no-content-generated-error.ts\nvar name8 = \"AI_NoContentGeneratedError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(error) {\n    return error instanceof Error && error.name === name8;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-such-model-error.ts\nvar name9 = \"AI_NoSuchModelError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name9,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a10] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchModelError(error) {\n    return error instanceof Error && error.name === name9 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType\n    };\n  }\n};\n_a10 = symbol10;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name10 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name10,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a11] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(error) {\n    return error instanceof Error && error.name === name10 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values\n    };\n  }\n};\n_a11 = symbol11;\n\n// src/errors/type-validation-error.ts\nvar name11 = \"AI_TypeValidationError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name11,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a12] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error) {\n    return error instanceof Error && error.name === name11;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      value: this.value\n    };\n  }\n};\n_a12 = symbol12;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name12 = \"AI_UnsupportedFunctionalityError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({ functionality }) {\n    super({\n      name: name12,\n      message: `'${functionality}' functionality not supported.`\n    });\n    this[_a13] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(error) {\n    return error instanceof Error && error.name === name12 && typeof error.functionality === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      functionality: this.functionality\n    };\n  }\n};\n_a13 = symbol13;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsSUFBSTtBQUN0RCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FB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ZGVfbW9kdWxlcy9AYWktc2RrL3VpLXV0aWxzL25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXgubWpzPzE4ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxMyxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTEzO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNCkge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvci5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVycm9yJ3MgbmFtZSwgbWVzc2FnZSwgYW5kIGNhdXNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xudmFyIEFJU0RLRXJyb3IgPSBfQUlTREtFcnJvcjtcblxuLy8gc3JjL2Vycm9ycy9hcGktY2FsbC1lcnJvci50c1xudmFyIG5hbWUgPSBcIkFJX0FQSUNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBBUElDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICB1cmwsXG4gICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgcmVzcG9uc2VCb2R5LFxuICAgIGNhdXNlLFxuICAgIGlzUmV0cnlhYmxlID0gc3RhdHVzQ29kZSAhPSBudWxsICYmIChzdGF0dXNDb2RlID09PSA0MDggfHwgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDA5IHx8IC8vIGNvbmZsaWN0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDI5IHx8IC8vIHRvbyBtYW55IHJlcXVlc3RzXG4gICAgc3RhdHVzQ29kZSA+PSA1MDApLFxuICAgIC8vIHNlcnZlciBlcnJvclxuICAgIGRhdGFcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzID0gcmVxdWVzdEJvZHlWYWx1ZXM7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcbiAgICB0aGlzLnJlc3BvbnNlQm9keSA9IHJlc3BvbnNlQm9keTtcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gaXNSZXRyeWFibGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNBUElDYWxsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lICYmIHR5cGVvZiBlcnJvci51cmwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnJlcXVlc3RCb2R5VmFsdWVzID09PSBcIm9iamVjdFwiICYmIChlcnJvci5zdGF0dXNDb2RlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c0NvZGUgPT09IFwibnVtYmVyXCIpICYmIChlcnJvci5yZXNwb25zZUhlYWRlcnMgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IucmVzcG9uc2VIZWFkZXJzID09PSBcIm9iamVjdFwiKSAmJiAoZXJyb3IucmVzcG9uc2VCb2R5ID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnJlc3BvbnNlQm9keSA9PT0gXCJzdHJpbmdcIikgJiYgKGVycm9yLmNhdXNlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLmNhdXNlID09PSBcIm9iamVjdFwiKSAmJiB0eXBlb2YgZXJyb3IuaXNSZXRyeWFibGUgPT09IFwiYm9vbGVhblwiICYmIChlcnJvci5kYXRhID09IG51bGwgfHwgdHlwZW9mIGVycm9yLmRhdGEgPT09IFwib2JqZWN0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzOiB0aGlzLnJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdGhpcy5yZXNwb25zZUJvZHksXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIGlzUmV0cnlhYmxlOiB0aGlzLmlzUmV0cnlhYmxlLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHNyYy9lcnJvcnMvZW1wdHktcmVzcG9uc2UtYm9keS1lcnJvci50c1xudmFyIG5hbWUyID0gXCJBSV9FbXB0eVJlc3BvbnNlQm9keUVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBFbXB0eVJlc3BvbnNlQm9keUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiRW1wdHkgcmVzcG9uc2UgYm9keVwiIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzRW1wdHlSZXNwb25zZUJvZHlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUyO1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcblxuLy8gc3JjL2Vycm9ycy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdDogcHJvbXB0MixcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0MjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFByb21wdEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTMgJiYgcHJvbXB0ICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHByb21wdDogdGhpcy5wcm9tcHRcbiAgICB9O1xuICB9XG59O1xuX2E0ID0gc3ltYm9sNDtcblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLXJlc3BvbnNlLWRhdGEtZXJyb3IudHNcbnZhciBuYW1lNCA9IFwiQUlfSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgcmVzcG9uc2UgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRSZXNwb25zZURhdGFFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU0ICYmIGVycm9yLmRhdGEgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU1ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNSxcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSlNPTlBhcnNlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNSAmJiBcInRleHRcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IudGV4dCA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB2YWx1ZVRleHQ6IHRoaXMudGV4dFxuICAgIH07XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTYsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNMb2FkQVBJS2V5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNjtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1zZXR0aW5nLWVycm9yLnRzXG52YXIgbmFtZTcgPSBcIkFJX0xvYWRTZXR0aW5nRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRTZXR0aW5nRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzTG9hZFNldHRpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU3O1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gc3JjL2Vycm9ycy9uby1jb250ZW50LWdlbmVyYXRlZC1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Ob0NvbnRlbnRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG52YXIgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGNvbnRlbnQgZ2VuZXJhdGVkLlwiXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU4O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH07XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBzcmMvZXJyb3JzL25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9TdWNoTW9kZWxFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xudmFyIE5vU3VjaE1vZGVsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZXJyb3JOYW1lID0gbmFtZTksXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hNb2RlbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTkgJiYgdHlwZW9mIGVycm9yLm1vZGVsSWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLm1vZGVsVHlwZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbW9kZWxUeXBlOiB0aGlzLm1vZGVsVHlwZVxuICAgIH07XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIHNyYy9lcnJvcnMvdG9vLW1hbnktZW1iZWRkaW5nLXZhbHVlcy1mb3ItY2FsbC1lcnJvci50c1xudmFyIG5hbWUxMCA9IFwiQUlfVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMCxcbiAgICAgIG1lc3NhZ2U6IGBUb28gbWFueSB2YWx1ZXMgZm9yIGEgc2luZ2xlIGVtYmVkZGluZyBjYWxsLiBUaGUgJHtvcHRpb25zLnByb3ZpZGVyfSBtb2RlbCBcIiR7b3B0aW9ucy5tb2RlbElkfVwiIGNhbiBvbmx5IGVtYmVkIHVwIHRvICR7b3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbH0gdmFsdWVzIHBlciBjYWxsLCBidXQgJHtvcHRpb25zLnZhbHVlcy5sZW5ndGh9IHZhbHVlcyB3ZXJlIHByb3ZpZGVkLmBcbiAgICB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0aW9ucy5wcm92aWRlcjtcbiAgICB0aGlzLm1vZGVsSWQgPSBvcHRpb25zLm1vZGVsSWQ7XG4gICAgdGhpcy5tYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG9wdGlvbnMubWF4RW1iZWRkaW5nc1BlckNhbGw7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTEpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1Rvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTAgJiYgXCJwcm92aWRlclwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5wcm92aWRlciA9PT0gXCJzdHJpbmdcIiAmJiBcIm1vZGVsSWRcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiBcIm1heEVtYmVkZGluZ3NQZXJDYWxsXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1heEVtYmVkZGluZ3NQZXJDYWxsID09PSBcIm51bWJlclwiICYmIFwidmFsdWVzXCIgaW4gZXJyb3IgJiYgQXJyYXkuaXNBcnJheShlcnJvci52YWx1ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1heEVtYmVkZGluZ3NQZXJDYWxsOiB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xuICAgIH07XG4gIH1cbn07XG5fYTExID0gc3ltYm9sMTE7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMSxcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTIpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNUeXBlVmFsaWRhdGlvbkVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTExO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxufTtcbl9hMTIgPSBzeW1ib2wxMjtcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMiA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMyA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xudmFyIF9hMTM7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IGZ1bmN0aW9uYWxpdHkgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGAnJHtmdW5jdGlvbmFsaXR5fScgZnVuY3Rpb25hbGl0eSBub3Qgc3VwcG9ydGVkLmBcbiAgICB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLmZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbmFsaXR5O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMiAmJiB0eXBlb2YgZXJyb3IuZnVuY3Rpb25hbGl0eSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgZnVuY3Rpb25hbGl0eTogdGhpcy5mdW5jdGlvbmFsaXR5XG4gICAgfTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcblxuLy8gc3JjL2pzb24tdmFsdWUvaXMtanNvbi50c1xuZnVuY3Rpb24gaXNKU09OVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZXZlcnkoXG4gICAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0pTT05BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoaXNKU09OVmFsdWUpO1xufVxuZnVuY3Rpb24gaXNKU09OT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZXZlcnkoXG4gICAgKFtrZXksIHZhbF0pID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgaXNKU09OVmFsdWUodmFsKVxuICApO1xufVxuZXhwb3J0IHtcbiAgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIGlzSlNPTlZhbHVlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ })

};
;